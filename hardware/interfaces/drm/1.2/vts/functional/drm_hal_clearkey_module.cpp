/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_TAG "drm_hal_clearkey_module@1.2"

#include <gtest/gtest.h>
#include "drm_hal_clearkey_module.h"

namespace android {
namespace hardware {
namespace drm {
namespace V1_2 {
namespace vts {

std::vector<uint8_t> DrmHalVTSClearkeyModule::handleProvisioningRequest(
        const std::vector<uint8_t>& /*provisioningRequest*/,
        const std::string& /*url*/) {
    EXPECT_TRUE(false) << "Clearkey doesn't support provisioning";
    return {};
}

std::vector<DrmHalVTSClearkeyModule::ContentConfiguration>
        DrmHalVTSClearkeyModule::getContentConfigurations() const {
    DrmHalVTSClearkeyModule::ContentConfiguration conf = {
        .name = "DrmHalVTSClearkeyModule", // name
        .serverUrl = "", // serverUrl
        .initData = { // initData
            // BMFF box header (4 bytes size + 'pssh')
            0x00, 0x00, 0x00, 0x34, 0x70, 0x73, 0x73, 0x68,
            // full box header (version = 1 flags = 0)
            0x01, 0x00, 0x00, 0x00,
            // system id
            0x10, 0x77, 0xef, 0xec, 0xc0, 0xb2, 0x4d, 0x02, 0xac, 0xe3, 0x3c,
            0x1e, 0x52, 0xe2, 0xfb, 0x4b,
            // number of key ids
            0x00, 0x00, 0x00, 0x01,
            // key id
            0x60, 0x06, 0x1e, 0x01, 0x7e, 0x47, 0x7e, 0x87, 0x7e, 0x57, 0xd0,
            0x0d, 0x1e, 0xd0, 0x0d, 0x1e,
            // size of data, must be zero
            0x00, 0x00, 0x00, 0x00
        },
        .mimeType = "video/mp4", // mimeType
        .optionalParameters = {}, // optionalParameters
        .policy = { .allowOffline = true }, // allowOffline
        .keys = { // keys
            {
                .isSecure = false, // isSecure
                .keyId = { // keyId
                    0x60, 0x06, 0x1e, 0x01, 0x7e, 0x47, 0x7e, 0x87,
                    0x7e, 0x57, 0xd0, 0x0d, 0x1e, 0xd0, 0x0d, 0x1e
                },
                .clearContentKey = { // clearContentKey
                    0x1a, 0x8a, 0x20, 0x95, 0xe4, 0xde, 0xb2, 0xd2,
                    0x9e, 0xc8, 0x16, 0xac, 0x7b, 0xae, 0x20, 0x82
                }
            }
        }
    };
    return { conf };
}

std::vector<uint8_t> DrmHalVTSClearkeyModule::handleKeyRequest(
        const std::vector<uint8_t>& keyRequest,
        const std::string& /*serverUrl*/) {

    // {"kids":["YAYeAX5Hfod-V9ANHtANHg"],"type":"temporary"}
    std::vector<uint8_t> expectedKeyRequest = {
        0x7b, 0x22, 0x6b, 0x69, 0x64, 0x73, 0x22, 0x3a, 0x5b, 0x22, 0x59, 0x41, 0x59, 0x65,
        0x41, 0x58, 0x35, 0x48, 0x66, 0x6f, 0x64, 0x2d, 0x56, 0x39, 0x41, 0x4e, 0x48, 0x74,
        0x41, 0x4e, 0x48, 0x67, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a,
        0x22, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x72, 0x79, 0x22, 0x7d};

    // {"kids":["YAYeAX5Hfod-V9ANHtANHg"],"type":"persistent-license"}
    std::vector<uint8_t> expectedKeyRequestPersistent = {
        0x7b, 0x22, 0x6b, 0x69, 0x64, 0x73, 0x22, 0x3a, 0x5b, 0x22, 0x59, 0x41, 0x59, 0x65,
        0x41, 0x58, 0x35, 0x48, 0x66, 0x6f, 0x64, 0x2d, 0x56, 0x39, 0x41, 0x4e, 0x48, 0x74,
        0x41, 0x4e, 0x48, 0x67, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a,
        0x22, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x69,
        0x63, 0x65, 0x6e, 0x73, 0x65, 0x22, 0x7d};

    // {"keys":[{"kty":"oct","kid":"YAYeAX5Hfod-V9ANHtANHg","k":"GoogleTestKeyBase64ggg"}]}
    std::vector<uint8_t> knownKeyResponse = {
        0x7b, 0x22, 0x6b, 0x65, 0x79, 0x73, 0x22, 0x3a, 0x5b, 0x7b, 0x22, 0x6b, 0x74, 0x79, 0x22,
        0x3a, 0x22, 0x6f, 0x63, 0x74, 0x22, 0x2c, 0x22, 0x6b, 0x69, 0x64, 0x22, 0x3a, 0x22, 0x59,
        0x41, 0x59, 0x65, 0x41, 0x58, 0x35, 0x48, 0x66, 0x6f, 0x64, 0x2d, 0x56, 0x39, 0x41, 0x4e,
        0x48, 0x74, 0x41, 0x4e, 0x48, 0x67, 0x22, 0x2c, 0x22, 0x6b, 0x22, 0x3a, 0x22, 0x47, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x54, 0x65, 0x73, 0x74, 0x4b, 0x65, 0x79, 0x42, 0x61, 0x73, 0x65,
        0x36, 0x34, 0x67, 0x67, 0x67, 0x22, 0x7d, 0x5d, 0x7d};

    // {"keys":[{"kty":"oct","kid":"YAYeAX5Hfod-V9ANHtANHg","k":"GoogleTestKeyBase64ggg"}],"type":"persistent-license"}
    std::vector<uint8_t> knownKeyResponsePersistent = {
        0x7b, 0x22, 0x6b, 0x65, 0x79, 0x73, 0x22, 0x3a, 0x5b, 0x7b, 0x22, 0x6b, 0x74, 0x79, 0x22,
        0x3a, 0x22, 0x6f, 0x63, 0x74, 0x22, 0x2c, 0x22, 0x6b, 0x69, 0x64, 0x22, 0x3a, 0x22, 0x59,
        0x41, 0x59, 0x65, 0x41, 0x58, 0x35, 0x48, 0x66, 0x6f, 0x64, 0x2d, 0x56, 0x39, 0x41, 0x4e,
        0x48, 0x74, 0x41, 0x4e, 0x48, 0x67, 0x22, 0x2c, 0x22, 0x6b, 0x22, 0x3a, 0x22, 0x47, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x54, 0x65, 0x73, 0x74, 0x4b, 0x65, 0x79, 0x42, 0x61, 0x73, 0x65,
        0x36, 0x34, 0x67, 0x67, 0x67, 0x22, 0x7d, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22,
        0x3a, 0x22, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x69,
        0x63, 0x65, 0x6e, 0x73, 0x65, 0x22, 0x7d};

    std::string req(keyRequest.begin(), keyRequest.end());
    if (req.find("persistent-license") != std::string::npos) {
        EXPECT_EQ(expectedKeyRequestPersistent, keyRequest);
        return knownKeyResponsePersistent;
    } else {
        EXPECT_EQ(expectedKeyRequest, keyRequest);
        return knownKeyResponse;
    }

}

}  // namespace vts
}  // namespace V1_2
}  // namespace drm
}  // namespace hardware
}  // namespace android
