// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_
#define FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace chre {
namespace fbs {

struct NanoappMessage;
struct NanoappMessageBuilder;
struct NanoappMessageT;

struct HubInfoRequest;
struct HubInfoRequestBuilder;
struct HubInfoRequestT;

struct HubInfoResponse;
struct HubInfoResponseBuilder;
struct HubInfoResponseT;

struct NanoappListRequest;
struct NanoappListRequestBuilder;
struct NanoappListRequestT;

struct NanoappListEntry;
struct NanoappListEntryBuilder;
struct NanoappListEntryT;

struct NanoappListResponse;
struct NanoappListResponseBuilder;
struct NanoappListResponseT;

struct LoadNanoappRequest;
struct LoadNanoappRequestBuilder;
struct LoadNanoappRequestT;

struct LoadNanoappResponse;
struct LoadNanoappResponseBuilder;
struct LoadNanoappResponseT;

struct UnloadNanoappRequest;
struct UnloadNanoappRequestBuilder;
struct UnloadNanoappRequestT;

struct UnloadNanoappResponse;
struct UnloadNanoappResponseBuilder;
struct UnloadNanoappResponseT;

struct LogMessage;
struct LogMessageBuilder;
struct LogMessageT;

struct TimeSyncMessage;
struct TimeSyncMessageBuilder;
struct TimeSyncMessageT;

struct DebugDumpRequest;
struct DebugDumpRequestBuilder;
struct DebugDumpRequestT;

struct DebugDumpData;
struct DebugDumpDataBuilder;
struct DebugDumpDataT;

struct DebugDumpResponse;
struct DebugDumpResponseBuilder;
struct DebugDumpResponseT;

struct TimeSyncRequest;
struct TimeSyncRequestBuilder;
struct TimeSyncRequestT;

struct LowPowerMicAccessRequest;
struct LowPowerMicAccessRequestBuilder;
struct LowPowerMicAccessRequestT;

struct LowPowerMicAccessRelease;
struct LowPowerMicAccessReleaseBuilder;
struct LowPowerMicAccessReleaseT;

struct SettingChangeMessage;
struct SettingChangeMessageBuilder;
struct SettingChangeMessageT;

struct HostAddress;

struct MessageContainer;
struct MessageContainerBuilder;
struct MessageContainerT;

/// An enum describing the setting type.
enum class Setting : int8_t {
  LOCATION = 0,
  MIN = LOCATION,
  MAX = LOCATION
};

inline const Setting (&EnumValuesSetting())[1] {
  static const Setting values[] = {
    Setting::LOCATION
  };
  return values;
}

inline const char * const *EnumNamesSetting() {
  static const char * const names[2] = {
    "LOCATION",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetting(Setting e) {
  if (flatbuffers::IsOutRange(e, Setting::LOCATION, Setting::LOCATION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetting()[index];
}

/// An enum describing the state of a setting.
enum class SettingState : int8_t {
  DISABLED = 0,
  ENABLED = 1,
  MIN = DISABLED,
  MAX = ENABLED
};

inline const SettingState (&EnumValuesSettingState())[2] {
  static const SettingState values[] = {
    SettingState::DISABLED,
    SettingState::ENABLED
  };
  return values;
}

inline const char * const *EnumNamesSettingState() {
  static const char * const names[3] = {
    "DISABLED",
    "ENABLED",
    nullptr
  };
  return names;
}

inline const char *EnumNameSettingState(SettingState e) {
  if (flatbuffers::IsOutRange(e, SettingState::DISABLED, SettingState::ENABLED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSettingState()[index];
}

/// A union that joins together all possible messages. Note that in FlatBuffers,
/// unions have an implicit type
enum class ChreMessage : uint8_t {
  NONE = 0,
  NanoappMessage = 1,
  HubInfoRequest = 2,
  HubInfoResponse = 3,
  NanoappListRequest = 4,
  NanoappListResponse = 5,
  LoadNanoappRequest = 6,
  LoadNanoappResponse = 7,
  UnloadNanoappRequest = 8,
  UnloadNanoappResponse = 9,
  LogMessage = 10,
  TimeSyncMessage = 11,
  DebugDumpRequest = 12,
  DebugDumpData = 13,
  DebugDumpResponse = 14,
  TimeSyncRequest = 15,
  LowPowerMicAccessRequest = 16,
  LowPowerMicAccessRelease = 17,
  SettingChangeMessage = 18,
  MIN = NONE,
  MAX = SettingChangeMessage
};

inline const ChreMessage (&EnumValuesChreMessage())[19] {
  static const ChreMessage values[] = {
    ChreMessage::NONE,
    ChreMessage::NanoappMessage,
    ChreMessage::HubInfoRequest,
    ChreMessage::HubInfoResponse,
    ChreMessage::NanoappListRequest,
    ChreMessage::NanoappListResponse,
    ChreMessage::LoadNanoappRequest,
    ChreMessage::LoadNanoappResponse,
    ChreMessage::UnloadNanoappRequest,
    ChreMessage::UnloadNanoappResponse,
    ChreMessage::LogMessage,
    ChreMessage::TimeSyncMessage,
    ChreMessage::DebugDumpRequest,
    ChreMessage::DebugDumpData,
    ChreMessage::DebugDumpResponse,
    ChreMessage::TimeSyncRequest,
    ChreMessage::LowPowerMicAccessRequest,
    ChreMessage::LowPowerMicAccessRelease,
    ChreMessage::SettingChangeMessage
  };
  return values;
}

inline const char * const *EnumNamesChreMessage() {
  static const char * const names[20] = {
    "NONE",
    "NanoappMessage",
    "HubInfoRequest",
    "HubInfoResponse",
    "NanoappListRequest",
    "NanoappListResponse",
    "LoadNanoappRequest",
    "LoadNanoappResponse",
    "UnloadNanoappRequest",
    "UnloadNanoappResponse",
    "LogMessage",
    "TimeSyncMessage",
    "DebugDumpRequest",
    "DebugDumpData",
    "DebugDumpResponse",
    "TimeSyncRequest",
    "LowPowerMicAccessRequest",
    "LowPowerMicAccessRelease",
    "SettingChangeMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameChreMessage(ChreMessage e) {
  if (flatbuffers::IsOutRange(e, ChreMessage::NONE, ChreMessage::SettingChangeMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesChreMessage()[index];
}

template<typename T> struct ChreMessageTraits {
  static const ChreMessage enum_value = ChreMessage::NONE;
};

template<> struct ChreMessageTraits<chre::fbs::NanoappMessage> {
  static const ChreMessage enum_value = ChreMessage::NanoappMessage;
};

template<> struct ChreMessageTraits<chre::fbs::HubInfoRequest> {
  static const ChreMessage enum_value = ChreMessage::HubInfoRequest;
};

template<> struct ChreMessageTraits<chre::fbs::HubInfoResponse> {
  static const ChreMessage enum_value = ChreMessage::HubInfoResponse;
};

template<> struct ChreMessageTraits<chre::fbs::NanoappListRequest> {
  static const ChreMessage enum_value = ChreMessage::NanoappListRequest;
};

template<> struct ChreMessageTraits<chre::fbs::NanoappListResponse> {
  static const ChreMessage enum_value = ChreMessage::NanoappListResponse;
};

template<> struct ChreMessageTraits<chre::fbs::LoadNanoappRequest> {
  static const ChreMessage enum_value = ChreMessage::LoadNanoappRequest;
};

template<> struct ChreMessageTraits<chre::fbs::LoadNanoappResponse> {
  static const ChreMessage enum_value = ChreMessage::LoadNanoappResponse;
};

template<> struct ChreMessageTraits<chre::fbs::UnloadNanoappRequest> {
  static const ChreMessage enum_value = ChreMessage::UnloadNanoappRequest;
};

template<> struct ChreMessageTraits<chre::fbs::UnloadNanoappResponse> {
  static const ChreMessage enum_value = ChreMessage::UnloadNanoappResponse;
};

template<> struct ChreMessageTraits<chre::fbs::LogMessage> {
  static const ChreMessage enum_value = ChreMessage::LogMessage;
};

template<> struct ChreMessageTraits<chre::fbs::TimeSyncMessage> {
  static const ChreMessage enum_value = ChreMessage::TimeSyncMessage;
};

template<> struct ChreMessageTraits<chre::fbs::DebugDumpRequest> {
  static const ChreMessage enum_value = ChreMessage::DebugDumpRequest;
};

template<> struct ChreMessageTraits<chre::fbs::DebugDumpData> {
  static const ChreMessage enum_value = ChreMessage::DebugDumpData;
};

template<> struct ChreMessageTraits<chre::fbs::DebugDumpResponse> {
  static const ChreMessage enum_value = ChreMessage::DebugDumpResponse;
};

template<> struct ChreMessageTraits<chre::fbs::TimeSyncRequest> {
  static const ChreMessage enum_value = ChreMessage::TimeSyncRequest;
};

template<> struct ChreMessageTraits<chre::fbs::LowPowerMicAccessRequest> {
  static const ChreMessage enum_value = ChreMessage::LowPowerMicAccessRequest;
};

template<> struct ChreMessageTraits<chre::fbs::LowPowerMicAccessRelease> {
  static const ChreMessage enum_value = ChreMessage::LowPowerMicAccessRelease;
};

template<> struct ChreMessageTraits<chre::fbs::SettingChangeMessage> {
  static const ChreMessage enum_value = ChreMessage::SettingChangeMessage;
};

struct ChreMessageUnion {
  ChreMessage type;
  void *value;

  ChreMessageUnion() : type(ChreMessage::NONE), value(nullptr) {}
  ChreMessageUnion(ChreMessageUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ChreMessage::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ChreMessageUnion(const ChreMessageUnion &);
  ChreMessageUnion &operator=(const ChreMessageUnion &u)
    { ChreMessageUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ChreMessageUnion &operator=(ChreMessageUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ChreMessageUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ChreMessageTraits<typename RT::TableType>::enum_value;
    if (type != ChreMessage::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ChreMessage type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  chre::fbs::NanoappMessageT *AsNanoappMessage() {
    return type == ChreMessage::NanoappMessage ?
      reinterpret_cast<chre::fbs::NanoappMessageT *>(value) : nullptr;
  }
  const chre::fbs::NanoappMessageT *AsNanoappMessage() const {
    return type == ChreMessage::NanoappMessage ?
      reinterpret_cast<const chre::fbs::NanoappMessageT *>(value) : nullptr;
  }
  chre::fbs::HubInfoRequestT *AsHubInfoRequest() {
    return type == ChreMessage::HubInfoRequest ?
      reinterpret_cast<chre::fbs::HubInfoRequestT *>(value) : nullptr;
  }
  const chre::fbs::HubInfoRequestT *AsHubInfoRequest() const {
    return type == ChreMessage::HubInfoRequest ?
      reinterpret_cast<const chre::fbs::HubInfoRequestT *>(value) : nullptr;
  }
  chre::fbs::HubInfoResponseT *AsHubInfoResponse() {
    return type == ChreMessage::HubInfoResponse ?
      reinterpret_cast<chre::fbs::HubInfoResponseT *>(value) : nullptr;
  }
  const chre::fbs::HubInfoResponseT *AsHubInfoResponse() const {
    return type == ChreMessage::HubInfoResponse ?
      reinterpret_cast<const chre::fbs::HubInfoResponseT *>(value) : nullptr;
  }
  chre::fbs::NanoappListRequestT *AsNanoappListRequest() {
    return type == ChreMessage::NanoappListRequest ?
      reinterpret_cast<chre::fbs::NanoappListRequestT *>(value) : nullptr;
  }
  const chre::fbs::NanoappListRequestT *AsNanoappListRequest() const {
    return type == ChreMessage::NanoappListRequest ?
      reinterpret_cast<const chre::fbs::NanoappListRequestT *>(value) : nullptr;
  }
  chre::fbs::NanoappListResponseT *AsNanoappListResponse() {
    return type == ChreMessage::NanoappListResponse ?
      reinterpret_cast<chre::fbs::NanoappListResponseT *>(value) : nullptr;
  }
  const chre::fbs::NanoappListResponseT *AsNanoappListResponse() const {
    return type == ChreMessage::NanoappListResponse ?
      reinterpret_cast<const chre::fbs::NanoappListResponseT *>(value) : nullptr;
  }
  chre::fbs::LoadNanoappRequestT *AsLoadNanoappRequest() {
    return type == ChreMessage::LoadNanoappRequest ?
      reinterpret_cast<chre::fbs::LoadNanoappRequestT *>(value) : nullptr;
  }
  const chre::fbs::LoadNanoappRequestT *AsLoadNanoappRequest() const {
    return type == ChreMessage::LoadNanoappRequest ?
      reinterpret_cast<const chre::fbs::LoadNanoappRequestT *>(value) : nullptr;
  }
  chre::fbs::LoadNanoappResponseT *AsLoadNanoappResponse() {
    return type == ChreMessage::LoadNanoappResponse ?
      reinterpret_cast<chre::fbs::LoadNanoappResponseT *>(value) : nullptr;
  }
  const chre::fbs::LoadNanoappResponseT *AsLoadNanoappResponse() const {
    return type == ChreMessage::LoadNanoappResponse ?
      reinterpret_cast<const chre::fbs::LoadNanoappResponseT *>(value) : nullptr;
  }
  chre::fbs::UnloadNanoappRequestT *AsUnloadNanoappRequest() {
    return type == ChreMessage::UnloadNanoappRequest ?
      reinterpret_cast<chre::fbs::UnloadNanoappRequestT *>(value) : nullptr;
  }
  const chre::fbs::UnloadNanoappRequestT *AsUnloadNanoappRequest() const {
    return type == ChreMessage::UnloadNanoappRequest ?
      reinterpret_cast<const chre::fbs::UnloadNanoappRequestT *>(value) : nullptr;
  }
  chre::fbs::UnloadNanoappResponseT *AsUnloadNanoappResponse() {
    return type == ChreMessage::UnloadNanoappResponse ?
      reinterpret_cast<chre::fbs::UnloadNanoappResponseT *>(value) : nullptr;
  }
  const chre::fbs::UnloadNanoappResponseT *AsUnloadNanoappResponse() const {
    return type == ChreMessage::UnloadNanoappResponse ?
      reinterpret_cast<const chre::fbs::UnloadNanoappResponseT *>(value) : nullptr;
  }
  chre::fbs::LogMessageT *AsLogMessage() {
    return type == ChreMessage::LogMessage ?
      reinterpret_cast<chre::fbs::LogMessageT *>(value) : nullptr;
  }
  const chre::fbs::LogMessageT *AsLogMessage() const {
    return type == ChreMessage::LogMessage ?
      reinterpret_cast<const chre::fbs::LogMessageT *>(value) : nullptr;
  }
  chre::fbs::TimeSyncMessageT *AsTimeSyncMessage() {
    return type == ChreMessage::TimeSyncMessage ?
      reinterpret_cast<chre::fbs::TimeSyncMessageT *>(value) : nullptr;
  }
  const chre::fbs::TimeSyncMessageT *AsTimeSyncMessage() const {
    return type == ChreMessage::TimeSyncMessage ?
      reinterpret_cast<const chre::fbs::TimeSyncMessageT *>(value) : nullptr;
  }
  chre::fbs::DebugDumpRequestT *AsDebugDumpRequest() {
    return type == ChreMessage::DebugDumpRequest ?
      reinterpret_cast<chre::fbs::DebugDumpRequestT *>(value) : nullptr;
  }
  const chre::fbs::DebugDumpRequestT *AsDebugDumpRequest() const {
    return type == ChreMessage::DebugDumpRequest ?
      reinterpret_cast<const chre::fbs::DebugDumpRequestT *>(value) : nullptr;
  }
  chre::fbs::DebugDumpDataT *AsDebugDumpData() {
    return type == ChreMessage::DebugDumpData ?
      reinterpret_cast<chre::fbs::DebugDumpDataT *>(value) : nullptr;
  }
  const chre::fbs::DebugDumpDataT *AsDebugDumpData() const {
    return type == ChreMessage::DebugDumpData ?
      reinterpret_cast<const chre::fbs::DebugDumpDataT *>(value) : nullptr;
  }
  chre::fbs::DebugDumpResponseT *AsDebugDumpResponse() {
    return type == ChreMessage::DebugDumpResponse ?
      reinterpret_cast<chre::fbs::DebugDumpResponseT *>(value) : nullptr;
  }
  const chre::fbs::DebugDumpResponseT *AsDebugDumpResponse() const {
    return type == ChreMessage::DebugDumpResponse ?
      reinterpret_cast<const chre::fbs::DebugDumpResponseT *>(value) : nullptr;
  }
  chre::fbs::TimeSyncRequestT *AsTimeSyncRequest() {
    return type == ChreMessage::TimeSyncRequest ?
      reinterpret_cast<chre::fbs::TimeSyncRequestT *>(value) : nullptr;
  }
  const chre::fbs::TimeSyncRequestT *AsTimeSyncRequest() const {
    return type == ChreMessage::TimeSyncRequest ?
      reinterpret_cast<const chre::fbs::TimeSyncRequestT *>(value) : nullptr;
  }
  chre::fbs::LowPowerMicAccessRequestT *AsLowPowerMicAccessRequest() {
    return type == ChreMessage::LowPowerMicAccessRequest ?
      reinterpret_cast<chre::fbs::LowPowerMicAccessRequestT *>(value) : nullptr;
  }
  const chre::fbs::LowPowerMicAccessRequestT *AsLowPowerMicAccessRequest() const {
    return type == ChreMessage::LowPowerMicAccessRequest ?
      reinterpret_cast<const chre::fbs::LowPowerMicAccessRequestT *>(value) : nullptr;
  }
  chre::fbs::LowPowerMicAccessReleaseT *AsLowPowerMicAccessRelease() {
    return type == ChreMessage::LowPowerMicAccessRelease ?
      reinterpret_cast<chre::fbs::LowPowerMicAccessReleaseT *>(value) : nullptr;
  }
  const chre::fbs::LowPowerMicAccessReleaseT *AsLowPowerMicAccessRelease() const {
    return type == ChreMessage::LowPowerMicAccessRelease ?
      reinterpret_cast<const chre::fbs::LowPowerMicAccessReleaseT *>(value) : nullptr;
  }
  chre::fbs::SettingChangeMessageT *AsSettingChangeMessage() {
    return type == ChreMessage::SettingChangeMessage ?
      reinterpret_cast<chre::fbs::SettingChangeMessageT *>(value) : nullptr;
  }
  const chre::fbs::SettingChangeMessageT *AsSettingChangeMessage() const {
    return type == ChreMessage::SettingChangeMessage ?
      reinterpret_cast<const chre::fbs::SettingChangeMessageT *>(value) : nullptr;
  }
};

bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj, ChreMessage type);
bool VerifyChreMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) HostAddress FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t client_id_;

 public:
  HostAddress() {
    memset(static_cast<void *>(this), 0, sizeof(HostAddress));
  }
  HostAddress(uint16_t _client_id)
      : client_id_(flatbuffers::EndianScalar(_client_id)) {
  }
  uint16_t client_id() const {
    return flatbuffers::EndianScalar(client_id_);
  }
  void mutate_client_id(uint16_t _client_id) {
    flatbuffers::WriteScalar(&client_id_, _client_id);
  }
};
FLATBUFFERS_STRUCT_END(HostAddress, 2);

struct NanoappMessageT : public flatbuffers::NativeTable {
  typedef NanoappMessage TableType;
  uint64_t app_id;
  uint32_t message_type;
  uint16_t host_endpoint;
  std::vector<uint8_t> message;
  NanoappMessageT()
      : app_id(0),
        message_type(0),
        host_endpoint(65534) {
  }
};

/// Represents a message sent to/from a nanoapp from/to a client on the host
struct NanoappMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappMessageT NativeTableType;
  typedef NanoappMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APP_ID = 4,
    VT_MESSAGE_TYPE = 6,
    VT_HOST_ENDPOINT = 8,
    VT_MESSAGE = 10
  };
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  uint32_t message_type() const {
    return GetField<uint32_t>(VT_MESSAGE_TYPE, 0);
  }
  bool mutate_message_type(uint32_t _message_type) {
    return SetField<uint32_t>(VT_MESSAGE_TYPE, _message_type, 0);
  }
  /// Identifies the host-side endpoint on the host that sent or should receive
  /// this message. The default value is a special value defined in the HAL and
  /// elsewhere that indicates that the endpoint is unspecified.
  uint16_t host_endpoint() const {
    return GetField<uint16_t>(VT_HOST_ENDPOINT, 65534);
  }
  bool mutate_host_endpoint(uint16_t _host_endpoint) {
    return SetField<uint16_t>(VT_HOST_ENDPOINT, _host_endpoint, 65534);
  }
  /// Vector containing arbitrary application-specific message data
  const flatbuffers::Vector<uint8_t> *message() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MESSAGE);
  }
  flatbuffers::Vector<uint8_t> *mutable_message() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_HOST_ENDPOINT) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.VerifyVector(message()) &&
           verifier.EndTable();
  }
  NanoappMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappMessageBuilder {
  typedef NanoappMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(NanoappMessage::VT_APP_ID, app_id, 0);
  }
  void add_message_type(uint32_t message_type) {
    fbb_.AddElement<uint32_t>(NanoappMessage::VT_MESSAGE_TYPE, message_type, 0);
  }
  void add_host_endpoint(uint16_t host_endpoint) {
    fbb_.AddElement<uint16_t>(NanoappMessage::VT_HOST_ENDPOINT, host_endpoint, 65534);
  }
  void add_message(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> message) {
    fbb_.AddOffset(NanoappMessage::VT_MESSAGE, message);
  }
  explicit NanoappMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappMessageBuilder &operator=(const NanoappMessageBuilder &);
  flatbuffers::Offset<NanoappMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappMessage>(end);
    fbb_.Required(o, NanoappMessage::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t message_type = 0,
    uint16_t host_endpoint = 65534,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> message = 0) {
  NanoappMessageBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  builder_.add_host_endpoint(host_endpoint);
  return builder_.Finish();
}

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t message_type = 0,
    uint16_t host_endpoint = 65534,
    const std::vector<uint8_t> *message = nullptr) {
  auto message__ = message ? _fbb.CreateVector<uint8_t>(*message) : 0;
  return chre::fbs::CreateNanoappMessage(
      _fbb,
      app_id,
      message_type,
      host_endpoint,
      message__);
}

flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HubInfoRequestT : public flatbuffers::NativeTable {
  typedef HubInfoRequest TableType;
  HubInfoRequestT() {
  }
};

struct HubInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HubInfoRequestT NativeTableType;
  typedef HubInfoRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HubInfoRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HubInfoRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HubInfoRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HubInfoRequestBuilder {
  typedef HubInfoRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HubInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HubInfoRequestBuilder &operator=(const HubInfoRequestBuilder &);
  flatbuffers::Offset<HubInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HubInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HubInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HubInfoResponseT : public flatbuffers::NativeTable {
  typedef HubInfoResponse TableType;
  std::vector<int8_t> name;
  std::vector<int8_t> vendor;
  std::vector<int8_t> toolchain;
  uint32_t platform_version;
  uint32_t toolchain_version;
  float peak_mips;
  float stopped_power;
  float sleep_power;
  float peak_power;
  uint32_t max_msg_len;
  uint64_t platform_id;
  uint32_t chre_platform_version;
  HubInfoResponseT()
      : platform_version(0),
        toolchain_version(0),
        peak_mips(0.0f),
        stopped_power(0.0f),
        sleep_power(0.0f),
        peak_power(0.0f),
        max_msg_len(0),
        platform_id(0),
        chre_platform_version(0) {
  }
};

struct HubInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HubInfoResponseT NativeTableType;
  typedef HubInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VENDOR = 6,
    VT_TOOLCHAIN = 8,
    VT_PLATFORM_VERSION = 10,
    VT_TOOLCHAIN_VERSION = 12,
    VT_PEAK_MIPS = 14,
    VT_STOPPED_POWER = 16,
    VT_SLEEP_POWER = 18,
    VT_PEAK_POWER = 20,
    VT_MAX_MSG_LEN = 22,
    VT_PLATFORM_ID = 24,
    VT_CHRE_PLATFORM_VERSION = 26
  };
  /// The name of the hub. Nominally a UTF-8 string, but note that we're not
  /// using the built-in "string" data type from FlatBuffers here, because the
  /// generated C++ uses std::string which is not well-supported in CHRE. This
  /// applies for vendor and toolchain as well.
  const flatbuffers::Vector<int8_t> *name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_NAME);
  }
  const flatbuffers::Vector<int8_t> *vendor() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VENDOR);
  }
  flatbuffers::Vector<int8_t> *mutable_vendor() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_VENDOR);
  }
  const flatbuffers::Vector<int8_t> *toolchain() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TOOLCHAIN);
  }
  flatbuffers::Vector<int8_t> *mutable_toolchain() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_TOOLCHAIN);
  }
  /// Legacy platform version reported in the HAL; semantics not strictly
  /// defined
  uint32_t platform_version() const {
    return GetField<uint32_t>(VT_PLATFORM_VERSION, 0);
  }
  bool mutate_platform_version(uint32_t _platform_version) {
    return SetField<uint32_t>(VT_PLATFORM_VERSION, _platform_version, 0);
  }
  /// Toolchain version reported in the HAL; semantics not strictly defined
  uint32_t toolchain_version() const {
    return GetField<uint32_t>(VT_TOOLCHAIN_VERSION, 0);
  }
  bool mutate_toolchain_version(uint32_t _toolchain_version) {
    return SetField<uint32_t>(VT_TOOLCHAIN_VERSION, _toolchain_version, 0);
  }
  float peak_mips() const {
    return GetField<float>(VT_PEAK_MIPS, 0.0f);
  }
  bool mutate_peak_mips(float _peak_mips) {
    return SetField<float>(VT_PEAK_MIPS, _peak_mips, 0.0f);
  }
  float stopped_power() const {
    return GetField<float>(VT_STOPPED_POWER, 0.0f);
  }
  bool mutate_stopped_power(float _stopped_power) {
    return SetField<float>(VT_STOPPED_POWER, _stopped_power, 0.0f);
  }
  float sleep_power() const {
    return GetField<float>(VT_SLEEP_POWER, 0.0f);
  }
  bool mutate_sleep_power(float _sleep_power) {
    return SetField<float>(VT_SLEEP_POWER, _sleep_power, 0.0f);
  }
  float peak_power() const {
    return GetField<float>(VT_PEAK_POWER, 0.0f);
  }
  bool mutate_peak_power(float _peak_power) {
    return SetField<float>(VT_PEAK_POWER, _peak_power, 0.0f);
  }
  /// Maximum size message that can be sent to a nanoapp
  uint32_t max_msg_len() const {
    return GetField<uint32_t>(VT_MAX_MSG_LEN, 0);
  }
  bool mutate_max_msg_len(uint32_t _max_msg_len) {
    return SetField<uint32_t>(VT_MAX_MSG_LEN, _max_msg_len, 0);
  }
  /// @see chreGetPlatformId()
  uint64_t platform_id() const {
    return GetField<uint64_t>(VT_PLATFORM_ID, 0);
  }
  bool mutate_platform_id(uint64_t _platform_id) {
    return SetField<uint64_t>(VT_PLATFORM_ID, _platform_id, 0);
  }
  /// @see chreGetVersion()
  uint32_t chre_platform_version() const {
    return GetField<uint32_t>(VT_CHRE_PLATFORM_VERSION, 0);
  }
  bool mutate_chre_platform_version(uint32_t _chre_platform_version) {
    return SetField<uint32_t>(VT_CHRE_PLATFORM_VERSION, _chre_platform_version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyVector(name()) &&
           VerifyOffset(verifier, VT_VENDOR) &&
           verifier.VerifyVector(vendor()) &&
           VerifyOffset(verifier, VT_TOOLCHAIN) &&
           verifier.VerifyVector(toolchain()) &&
           VerifyField<uint32_t>(verifier, VT_PLATFORM_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_TOOLCHAIN_VERSION) &&
           VerifyField<float>(verifier, VT_PEAK_MIPS) &&
           VerifyField<float>(verifier, VT_STOPPED_POWER) &&
           VerifyField<float>(verifier, VT_SLEEP_POWER) &&
           VerifyField<float>(verifier, VT_PEAK_POWER) &&
           VerifyField<uint32_t>(verifier, VT_MAX_MSG_LEN) &&
           VerifyField<uint64_t>(verifier, VT_PLATFORM_ID) &&
           VerifyField<uint32_t>(verifier, VT_CHRE_PLATFORM_VERSION) &&
           verifier.EndTable();
  }
  HubInfoResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HubInfoResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HubInfoResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HubInfoResponseBuilder {
  typedef HubInfoResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> name) {
    fbb_.AddOffset(HubInfoResponse::VT_NAME, name);
  }
  void add_vendor(flatbuffers::Offset<flatbuffers::Vector<int8_t>> vendor) {
    fbb_.AddOffset(HubInfoResponse::VT_VENDOR, vendor);
  }
  void add_toolchain(flatbuffers::Offset<flatbuffers::Vector<int8_t>> toolchain) {
    fbb_.AddOffset(HubInfoResponse::VT_TOOLCHAIN, toolchain);
  }
  void add_platform_version(uint32_t platform_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_PLATFORM_VERSION, platform_version, 0);
  }
  void add_toolchain_version(uint32_t toolchain_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_TOOLCHAIN_VERSION, toolchain_version, 0);
  }
  void add_peak_mips(float peak_mips) {
    fbb_.AddElement<float>(HubInfoResponse::VT_PEAK_MIPS, peak_mips, 0.0f);
  }
  void add_stopped_power(float stopped_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_STOPPED_POWER, stopped_power, 0.0f);
  }
  void add_sleep_power(float sleep_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_SLEEP_POWER, sleep_power, 0.0f);
  }
  void add_peak_power(float peak_power) {
    fbb_.AddElement<float>(HubInfoResponse::VT_PEAK_POWER, peak_power, 0.0f);
  }
  void add_max_msg_len(uint32_t max_msg_len) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_MAX_MSG_LEN, max_msg_len, 0);
  }
  void add_platform_id(uint64_t platform_id) {
    fbb_.AddElement<uint64_t>(HubInfoResponse::VT_PLATFORM_ID, platform_id, 0);
  }
  void add_chre_platform_version(uint32_t chre_platform_version) {
    fbb_.AddElement<uint32_t>(HubInfoResponse::VT_CHRE_PLATFORM_VERSION, chre_platform_version, 0);
  }
  explicit HubInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HubInfoResponseBuilder &operator=(const HubInfoResponseBuilder &);
  flatbuffers::Offset<HubInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HubInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> vendor = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> toolchain = 0,
    uint32_t platform_version = 0,
    uint32_t toolchain_version = 0,
    float peak_mips = 0.0f,
    float stopped_power = 0.0f,
    float sleep_power = 0.0f,
    float peak_power = 0.0f,
    uint32_t max_msg_len = 0,
    uint64_t platform_id = 0,
    uint32_t chre_platform_version = 0) {
  HubInfoResponseBuilder builder_(_fbb);
  builder_.add_platform_id(platform_id);
  builder_.add_chre_platform_version(chre_platform_version);
  builder_.add_max_msg_len(max_msg_len);
  builder_.add_peak_power(peak_power);
  builder_.add_sleep_power(sleep_power);
  builder_.add_stopped_power(stopped_power);
  builder_.add_peak_mips(peak_mips);
  builder_.add_toolchain_version(toolchain_version);
  builder_.add_platform_version(platform_version);
  builder_.add_toolchain(toolchain);
  builder_.add_vendor(vendor);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *name = nullptr,
    const std::vector<int8_t> *vendor = nullptr,
    const std::vector<int8_t> *toolchain = nullptr,
    uint32_t platform_version = 0,
    uint32_t toolchain_version = 0,
    float peak_mips = 0.0f,
    float stopped_power = 0.0f,
    float sleep_power = 0.0f,
    float peak_power = 0.0f,
    uint32_t max_msg_len = 0,
    uint64_t platform_id = 0,
    uint32_t chre_platform_version = 0) {
  auto name__ = name ? _fbb.CreateVector<int8_t>(*name) : 0;
  auto vendor__ = vendor ? _fbb.CreateVector<int8_t>(*vendor) : 0;
  auto toolchain__ = toolchain ? _fbb.CreateVector<int8_t>(*toolchain) : 0;
  return chre::fbs::CreateHubInfoResponse(
      _fbb,
      name__,
      vendor__,
      toolchain__,
      platform_version,
      toolchain_version,
      peak_mips,
      stopped_power,
      sleep_power,
      peak_power,
      max_msg_len,
      platform_id,
      chre_platform_version);
}

flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListRequestT : public flatbuffers::NativeTable {
  typedef NanoappListRequest TableType;
  NanoappListRequestT() {
  }
};

struct NanoappListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListRequestT NativeTableType;
  typedef NanoappListRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NanoappListRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListRequestBuilder {
  typedef NanoappListRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NanoappListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListRequestBuilder &operator=(const NanoappListRequestBuilder &);
  flatbuffers::Offset<NanoappListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NanoappListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListEntryT : public flatbuffers::NativeTable {
  typedef NanoappListEntry TableType;
  uint64_t app_id;
  uint32_t version;
  bool enabled;
  bool is_system;
  NanoappListEntryT()
      : app_id(0),
        version(0),
        enabled(true),
        is_system(false) {
  }
};

struct NanoappListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListEntryT NativeTableType;
  typedef NanoappListEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APP_ID = 4,
    VT_VERSION = 6,
    VT_ENABLED = 8,
    VT_IS_SYSTEM = 10
  };
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 1) != 0;
  }
  bool mutate_enabled(bool _enabled) {
    return SetField<uint8_t>(VT_ENABLED, static_cast<uint8_t>(_enabled), 1);
  }
  /// Whether the nanoapp is a pre-loaded "system" nanoapp, i.e. one that should
  /// not show up in the list of nanoapps in the context hub HAL. System
  /// nanoapps are typically used to leverage CHRE for some device functionality
  /// and do not interact via the context hub HAL.
  bool is_system() const {
    return GetField<uint8_t>(VT_IS_SYSTEM, 0) != 0;
  }
  bool mutate_is_system(bool _is_system) {
    return SetField<uint8_t>(VT_IS_SYSTEM, static_cast<uint8_t>(_is_system), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYSTEM) &&
           verifier.EndTable();
  }
  NanoappListEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListEntryBuilder {
  typedef NanoappListEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(NanoappListEntry::VT_APP_ID, app_id, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(NanoappListEntry::VT_VERSION, version, 0);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(NanoappListEntry::VT_ENABLED, static_cast<uint8_t>(enabled), 1);
  }
  void add_is_system(bool is_system) {
    fbb_.AddElement<uint8_t>(NanoappListEntry::VT_IS_SYSTEM, static_cast<uint8_t>(is_system), 0);
  }
  explicit NanoappListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListEntryBuilder &operator=(const NanoappListEntryBuilder &);
  flatbuffers::Offset<NanoappListEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0,
    uint32_t version = 0,
    bool enabled = true,
    bool is_system = false) {
  NanoappListEntryBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_version(version);
  builder_.add_is_system(is_system);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappListResponseT : public flatbuffers::NativeTable {
  typedef NanoappListResponse TableType;
  std::vector<std::unique_ptr<chre::fbs::NanoappListEntryT>> nanoapps;
  NanoappListResponseT() {
  }
};

struct NanoappListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappListResponseT NativeTableType;
  typedef NanoappListResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NANOAPPS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *nanoapps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *>(VT_NANOAPPS);
  }
  flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *mutable_nanoapps() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *>(VT_NANOAPPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NANOAPPS) &&
           verifier.VerifyVector(nanoapps()) &&
           verifier.VerifyVectorOfTables(nanoapps()) &&
           verifier.EndTable();
  }
  NanoappListResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappListResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappListResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappListResponseBuilder {
  typedef NanoappListResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nanoapps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>>> nanoapps) {
    fbb_.AddOffset(NanoappListResponse::VT_NANOAPPS, nanoapps);
  }
  explicit NanoappListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappListResponseBuilder &operator=(const NanoappListResponseBuilder &);
  flatbuffers::Offset<NanoappListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappListResponse>(end);
    fbb_.Required(o, NanoappListResponse::VT_NANOAPPS);
    return o;
  }
};

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>>> nanoapps = 0) {
  NanoappListResponseBuilder builder_(_fbb);
  builder_.add_nanoapps(nanoapps);
  return builder_.Finish();
}

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> *nanoapps = nullptr) {
  auto nanoapps__ = nanoapps ? _fbb.CreateVector<flatbuffers::Offset<chre::fbs::NanoappListEntry>>(*nanoapps) : 0;
  return chre::fbs::CreateNanoappListResponse(
      _fbb,
      nanoapps__);
}

flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoadNanoappRequestT : public flatbuffers::NativeTable {
  typedef LoadNanoappRequest TableType;
  uint32_t transaction_id;
  uint64_t app_id;
  uint32_t app_version;
  uint32_t target_api_version;
  std::vector<uint8_t> app_binary;
  uint32_t fragment_id;
  uint32_t total_app_size;
  std::vector<int8_t> app_binary_file_name;
  LoadNanoappRequestT()
      : transaction_id(0),
        app_id(0),
        app_version(0),
        target_api_version(0),
        fragment_id(0),
        total_app_size(0) {
  }
};

/// Represents a request for loading a nanoapp.
/// The nanaopp can either be requested to be loaded via a file or via a buffer.
/// For loading via a file, the following steps will be taken:
/// 1. The loader sends a LoadNanoappRequest message to CHRE. app_binary must
///    be set for legacy purposes, but should be empty. Additionally,
///    fragment_id and total_app_size are unused in this request. The loading
///    that happens as part of this request is serialized, but asynchronous
///    meaning that load requests will be processed in the order they are sent
///    but multiple requests can be outstanding at any given time.
/// 2. CHRE stores the filename and waits until its event loop is able to
///    process the request.
/// 3. Once ready, the nanoapp will be loaded from the file specified in the
///    original request and will send a callback indicating the
///    completion/failure of the request.
/// For loading via a buffer, loading may optionally be fragmented into multiple
/// sequential requests, which will follow the following steps:
/// 1. The loader sends a LoadNanoappRequest message to CHRE. If the request
///    is fragmented, then the fields fragment_id and total_app_size must
///    be defined. Once the first fragment is sent to CHRE, all subsequent
///    fragments must be delivered before a new LoadNanoappRequest can be
///    issued. If a new request is received while a current request has
///    outstanding fragments, the current request will be overridden with the
///    new one.
/// 2. CHRE preallocates the required amount of memory, and loads app_binary,
///    appending to already loaded fragments as appropriate.
/// 3. If the request is fragmented, then the requestor must sequentially send
///    multiple LoadNanoappRequest with incremental nanoapp binary fragments.
///    CHRE will respond with LoadNanoappResponse for each request. For
///    requests starting from the second fragment, all fields except
///    fragment_id and app_binary should be ignored by CHRE.
///
///    Once the LoadNanoappRepsonse for the last fragment is received
///    by the HAL, the HAL client will receive a callback indicating the
///    completion/failure of a load request.
///
/// If any request fragment is lost, then the entire load request will be
/// considered to have failed. If the request times out (e.g. the requestor
/// process crashes), then the load request will be cancelled at CHRE and fail.
struct LoadNanoappRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoadNanoappRequestT NativeTableType;
  typedef LoadNanoappRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_APP_ID = 6,
    VT_APP_VERSION = 8,
    VT_TARGET_API_VERSION = 10,
    VT_APP_BINARY = 12,
    VT_FRAGMENT_ID = 14,
    VT_TOTAL_APP_SIZE = 16,
    VT_APP_BINARY_FILE_NAME = 18
  };
  uint32_t transaction_id() const {
    return GetField<uint32_t>(VT_TRANSACTION_ID, 0);
  }
  bool mutate_transaction_id(uint32_t _transaction_id) {
    return SetField<uint32_t>(VT_TRANSACTION_ID, _transaction_id, 0);
  }
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  uint32_t app_version() const {
    return GetField<uint32_t>(VT_APP_VERSION, 0);
  }
  bool mutate_app_version(uint32_t _app_version) {
    return SetField<uint32_t>(VT_APP_VERSION, _app_version, 0);
  }
  uint32_t target_api_version() const {
    return GetField<uint32_t>(VT_TARGET_API_VERSION, 0);
  }
  bool mutate_target_api_version(uint32_t _target_api_version) {
    return SetField<uint32_t>(VT_TARGET_API_VERSION, _target_api_version, 0);
  }
  const flatbuffers::Vector<uint8_t> *app_binary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_APP_BINARY);
  }
  flatbuffers::Vector<uint8_t> *mutable_app_binary() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_APP_BINARY);
  }
  /// Fields that are relevant for fragmented loading
  /// The framgent count starts at 1 and should end at the total number of
  /// fragments. For clients that do not support fragmented loading, the
  /// default behavior should be to assume one fragment.
  uint32_t fragment_id() const {
    return GetField<uint32_t>(VT_FRAGMENT_ID, 0);
  }
  bool mutate_fragment_id(uint32_t _fragment_id) {
    return SetField<uint32_t>(VT_FRAGMENT_ID, _fragment_id, 0);
  }
  uint32_t total_app_size() const {
    return GetField<uint32_t>(VT_TOTAL_APP_SIZE, 0);
  }
  bool mutate_total_app_size(uint32_t _total_app_size) {
    return SetField<uint32_t>(VT_TOTAL_APP_SIZE, _total_app_size, 0);
  }
  /// Null-terminated ASCII string containing the file name that contains the
  /// app binary to be loaded.
  const flatbuffers::Vector<int8_t> *app_binary_file_name() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_APP_BINARY_FILE_NAME);
  }
  flatbuffers::Vector<int8_t> *mutable_app_binary_file_name() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_APP_BINARY_FILE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTION_ID) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint32_t>(verifier, VT_APP_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_TARGET_API_VERSION) &&
           VerifyOffsetRequired(verifier, VT_APP_BINARY) &&
           verifier.VerifyVector(app_binary()) &&
           VerifyField<uint32_t>(verifier, VT_FRAGMENT_ID) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_APP_SIZE) &&
           VerifyOffset(verifier, VT_APP_BINARY_FILE_NAME) &&
           verifier.VerifyVector(app_binary_file_name()) &&
           verifier.EndTable();
  }
  LoadNanoappRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoadNanoappRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoadNanoappRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoadNanoappRequestBuilder {
  typedef LoadNanoappRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction_id(uint32_t transaction_id) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(LoadNanoappRequest::VT_APP_ID, app_id, 0);
  }
  void add_app_version(uint32_t app_version) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_APP_VERSION, app_version, 0);
  }
  void add_target_api_version(uint32_t target_api_version) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_TARGET_API_VERSION, target_api_version, 0);
  }
  void add_app_binary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> app_binary) {
    fbb_.AddOffset(LoadNanoappRequest::VT_APP_BINARY, app_binary);
  }
  void add_fragment_id(uint32_t fragment_id) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_FRAGMENT_ID, fragment_id, 0);
  }
  void add_total_app_size(uint32_t total_app_size) {
    fbb_.AddElement<uint32_t>(LoadNanoappRequest::VT_TOTAL_APP_SIZE, total_app_size, 0);
  }
  void add_app_binary_file_name(flatbuffers::Offset<flatbuffers::Vector<int8_t>> app_binary_file_name) {
    fbb_.AddOffset(LoadNanoappRequest::VT_APP_BINARY_FILE_NAME, app_binary_file_name);
  }
  explicit LoadNanoappRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadNanoappRequestBuilder &operator=(const LoadNanoappRequestBuilder &);
  flatbuffers::Offset<LoadNanoappRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadNanoappRequest>(end);
    fbb_.Required(o, LoadNanoappRequest::VT_APP_BINARY);
    return o;
  }
};

inline flatbuffers::Offset<LoadNanoappRequest> CreateLoadNanoappRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    uint64_t app_id = 0,
    uint32_t app_version = 0,
    uint32_t target_api_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> app_binary = 0,
    uint32_t fragment_id = 0,
    uint32_t total_app_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> app_binary_file_name = 0) {
  LoadNanoappRequestBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_app_binary_file_name(app_binary_file_name);
  builder_.add_total_app_size(total_app_size);
  builder_.add_fragment_id(fragment_id);
  builder_.add_app_binary(app_binary);
  builder_.add_target_api_version(target_api_version);
  builder_.add_app_version(app_version);
  builder_.add_transaction_id(transaction_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoadNanoappRequest> CreateLoadNanoappRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    uint64_t app_id = 0,
    uint32_t app_version = 0,
    uint32_t target_api_version = 0,
    const std::vector<uint8_t> *app_binary = nullptr,
    uint32_t fragment_id = 0,
    uint32_t total_app_size = 0,
    const std::vector<int8_t> *app_binary_file_name = nullptr) {
  auto app_binary__ = app_binary ? _fbb.CreateVector<uint8_t>(*app_binary) : 0;
  auto app_binary_file_name__ = app_binary_file_name ? _fbb.CreateVector<int8_t>(*app_binary_file_name) : 0;
  return chre::fbs::CreateLoadNanoappRequest(
      _fbb,
      transaction_id,
      app_id,
      app_version,
      target_api_version,
      app_binary__,
      fragment_id,
      total_app_size,
      app_binary_file_name__);
}

flatbuffers::Offset<LoadNanoappRequest> CreateLoadNanoappRequest(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoadNanoappResponseT : public flatbuffers::NativeTable {
  typedef LoadNanoappResponse TableType;
  uint32_t transaction_id;
  bool success;
  uint32_t fragment_id;
  LoadNanoappResponseT()
      : transaction_id(0),
        success(false),
        fragment_id(0) {
  }
};

struct LoadNanoappResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoadNanoappResponseT NativeTableType;
  typedef LoadNanoappResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_SUCCESS = 6,
    VT_FRAGMENT_ID = 8
  };
  uint32_t transaction_id() const {
    return GetField<uint32_t>(VT_TRANSACTION_ID, 0);
  }
  bool mutate_transaction_id(uint32_t _transaction_id) {
    return SetField<uint32_t>(VT_TRANSACTION_ID, _transaction_id, 0);
  }
  /// Denotes whether a load request succeeded or failed.
  /// If any fragment of a load request fails, the entire load request for
  /// the same transaction will fail.
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  /// The fragment count of the load reponse is for.
  uint32_t fragment_id() const {
    return GetField<uint32_t>(VT_FRAGMENT_ID, 0);
  }
  bool mutate_fragment_id(uint32_t _fragment_id) {
    return SetField<uint32_t>(VT_FRAGMENT_ID, _fragment_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTION_ID) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<uint32_t>(verifier, VT_FRAGMENT_ID) &&
           verifier.EndTable();
  }
  LoadNanoappResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoadNanoappResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoadNanoappResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoadNanoappResponseBuilder {
  typedef LoadNanoappResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction_id(uint32_t transaction_id) {
    fbb_.AddElement<uint32_t>(LoadNanoappResponse::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(LoadNanoappResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_fragment_id(uint32_t fragment_id) {
    fbb_.AddElement<uint32_t>(LoadNanoappResponse::VT_FRAGMENT_ID, fragment_id, 0);
  }
  explicit LoadNanoappResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadNanoappResponseBuilder &operator=(const LoadNanoappResponseBuilder &);
  flatbuffers::Offset<LoadNanoappResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoadNanoappResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoadNanoappResponse> CreateLoadNanoappResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    bool success = false,
    uint32_t fragment_id = 0) {
  LoadNanoappResponseBuilder builder_(_fbb);
  builder_.add_fragment_id(fragment_id);
  builder_.add_transaction_id(transaction_id);
  builder_.add_success(success);
  return builder_.Finish();
}

flatbuffers::Offset<LoadNanoappResponse> CreateLoadNanoappResponse(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnloadNanoappRequestT : public flatbuffers::NativeTable {
  typedef UnloadNanoappRequest TableType;
  uint32_t transaction_id;
  uint64_t app_id;
  bool allow_system_nanoapp_unload;
  UnloadNanoappRequestT()
      : transaction_id(0),
        app_id(0),
        allow_system_nanoapp_unload(false) {
  }
};

struct UnloadNanoappRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnloadNanoappRequestT NativeTableType;
  typedef UnloadNanoappRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_APP_ID = 6,
    VT_ALLOW_SYSTEM_NANOAPP_UNLOAD = 8
  };
  uint32_t transaction_id() const {
    return GetField<uint32_t>(VT_TRANSACTION_ID, 0);
  }
  bool mutate_transaction_id(uint32_t _transaction_id) {
    return SetField<uint32_t>(VT_TRANSACTION_ID, _transaction_id, 0);
  }
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool mutate_app_id(uint64_t _app_id) {
    return SetField<uint64_t>(VT_APP_ID, _app_id, 0);
  }
  /// Set to true to allow this request to unload nanoapps identified as "system
  /// nanoapps", i.e. ones with is_system set to true in NanoappListResponse.
  bool allow_system_nanoapp_unload() const {
    return GetField<uint8_t>(VT_ALLOW_SYSTEM_NANOAPP_UNLOAD, 0) != 0;
  }
  bool mutate_allow_system_nanoapp_unload(bool _allow_system_nanoapp_unload) {
    return SetField<uint8_t>(VT_ALLOW_SYSTEM_NANOAPP_UNLOAD, static_cast<uint8_t>(_allow_system_nanoapp_unload), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTION_ID) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           VerifyField<uint8_t>(verifier, VT_ALLOW_SYSTEM_NANOAPP_UNLOAD) &&
           verifier.EndTable();
  }
  UnloadNanoappRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnloadNanoappRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnloadNanoappRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnloadNanoappRequestBuilder {
  typedef UnloadNanoappRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction_id(uint32_t transaction_id) {
    fbb_.AddElement<uint32_t>(UnloadNanoappRequest::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(UnloadNanoappRequest::VT_APP_ID, app_id, 0);
  }
  void add_allow_system_nanoapp_unload(bool allow_system_nanoapp_unload) {
    fbb_.AddElement<uint8_t>(UnloadNanoappRequest::VT_ALLOW_SYSTEM_NANOAPP_UNLOAD, static_cast<uint8_t>(allow_system_nanoapp_unload), 0);
  }
  explicit UnloadNanoappRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnloadNanoappRequestBuilder &operator=(const UnloadNanoappRequestBuilder &);
  flatbuffers::Offset<UnloadNanoappRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnloadNanoappRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnloadNanoappRequest> CreateUnloadNanoappRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    uint64_t app_id = 0,
    bool allow_system_nanoapp_unload = false) {
  UnloadNanoappRequestBuilder builder_(_fbb);
  builder_.add_app_id(app_id);
  builder_.add_transaction_id(transaction_id);
  builder_.add_allow_system_nanoapp_unload(allow_system_nanoapp_unload);
  return builder_.Finish();
}

flatbuffers::Offset<UnloadNanoappRequest> CreateUnloadNanoappRequest(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnloadNanoappResponseT : public flatbuffers::NativeTable {
  typedef UnloadNanoappResponse TableType;
  uint32_t transaction_id;
  bool success;
  UnloadNanoappResponseT()
      : transaction_id(0),
        success(false) {
  }
};

struct UnloadNanoappResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnloadNanoappResponseT NativeTableType;
  typedef UnloadNanoappResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_SUCCESS = 6
  };
  uint32_t transaction_id() const {
    return GetField<uint32_t>(VT_TRANSACTION_ID, 0);
  }
  bool mutate_transaction_id(uint32_t _transaction_id) {
    return SetField<uint32_t>(VT_TRANSACTION_ID, _transaction_id, 0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTION_ID) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
  UnloadNanoappResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnloadNanoappResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnloadNanoappResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnloadNanoappResponseBuilder {
  typedef UnloadNanoappResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction_id(uint32_t transaction_id) {
    fbb_.AddElement<uint32_t>(UnloadNanoappResponse::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(UnloadNanoappResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit UnloadNanoappResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnloadNanoappResponseBuilder &operator=(const UnloadNanoappResponseBuilder &);
  flatbuffers::Offset<UnloadNanoappResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnloadNanoappResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnloadNanoappResponse> CreateUnloadNanoappResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t transaction_id = 0,
    bool success = false) {
  UnloadNanoappResponseBuilder builder_(_fbb);
  builder_.add_transaction_id(transaction_id);
  builder_.add_success(success);
  return builder_.Finish();
}

flatbuffers::Offset<UnloadNanoappResponse> CreateUnloadNanoappResponse(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogMessageT : public flatbuffers::NativeTable {
  typedef LogMessage TableType;
  std::vector<int8_t> buffer;
  LogMessageT() {
  }
};

/// Represents log messages from CHRE.
struct LogMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogMessageT NativeTableType;
  typedef LogMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  /// A buffer containing formatted log data. A flat array is used here to avoid
  /// overhead in serializing and deserializing. The format is as follows:
  ///
  /// uint8_t                 - log level (1 = error, 2 = warning,
  ///                                      3 = info, 4 = debug)
  /// uint64_t, little-endian - timestamp in nanoseconds
  /// char[]                  - message to log
  /// char, \0                - null-terminator
  ///
  /// This pattern repeats until the end of the buffer for multiple log
  /// messages. The last byte will always be a null-terminator. There are no
  /// padding bytes between these fields. Treat this like a packed struct and be
  /// cautious with unaligned access when reading/writing this buffer.
  const flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  flatbuffers::Vector<int8_t> *mutable_buffer() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
  LogMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogMessageBuilder {
  typedef LogMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(LogMessage::VT_BUFFER, buffer);
  }
  explicit LogMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogMessageBuilder &operator=(const LogMessageBuilder &);
  flatbuffers::Offset<LogMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogMessage> CreateLogMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer = 0) {
  LogMessageBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogMessage> CreateLogMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<int8_t>(*buffer) : 0;
  return chre::fbs::CreateLogMessage(
      _fbb,
      buffer__);
}

flatbuffers::Offset<LogMessage> CreateLogMessage(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TimeSyncMessageT : public flatbuffers::NativeTable {
  typedef TimeSyncMessage TableType;
  int64_t offset;
  TimeSyncMessageT()
      : offset(0) {
  }
};

/// Represents a message sent to CHRE to indicate AP timestamp for time sync
struct TimeSyncMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeSyncMessageT NativeTableType;
  typedef TimeSyncMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4
  };
  /// Offset between AP and CHRE timestamp
  int64_t offset() const {
    return GetField<int64_t>(VT_OFFSET, 0);
  }
  bool mutate_offset(int64_t _offset) {
    return SetField<int64_t>(VT_OFFSET, _offset, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
  TimeSyncMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimeSyncMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TimeSyncMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimeSyncMessageBuilder {
  typedef TimeSyncMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(int64_t offset) {
    fbb_.AddElement<int64_t>(TimeSyncMessage::VT_OFFSET, offset, 0);
  }
  explicit TimeSyncMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeSyncMessageBuilder &operator=(const TimeSyncMessageBuilder &);
  flatbuffers::Offset<TimeSyncMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeSyncMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeSyncMessage> CreateTimeSyncMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t offset = 0) {
  TimeSyncMessageBuilder builder_(_fbb);
  builder_.add_offset(offset);
  return builder_.Finish();
}

flatbuffers::Offset<TimeSyncMessage> CreateTimeSyncMessage(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugDumpRequestT : public flatbuffers::NativeTable {
  typedef DebugDumpRequest TableType;
  DebugDumpRequestT() {
  }
};

/// A request to gather and return debugging information. Only one debug dump
/// session can be active at a time. Upon accepting a request, zero or more
/// DebugDumpData messages are generated, followed by a DebugDumpResponse
/// indicating the completion of the operation.
struct DebugDumpRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugDumpRequestT NativeTableType;
  typedef DebugDumpRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DebugDumpRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugDumpRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugDumpRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugDumpRequestBuilder {
  typedef DebugDumpRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DebugDumpRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugDumpRequestBuilder &operator=(const DebugDumpRequestBuilder &);
  flatbuffers::Offset<DebugDumpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugDumpRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugDumpRequest> CreateDebugDumpRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DebugDumpRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DebugDumpRequest> CreateDebugDumpRequest(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugDumpDataT : public flatbuffers::NativeTable {
  typedef DebugDumpData TableType;
  std::vector<int8_t> debug_str;
  DebugDumpDataT() {
  }
};

struct DebugDumpData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugDumpDataT NativeTableType;
  typedef DebugDumpDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEBUG_STR = 4
  };
  /// Null-terminated ASCII string containing debugging information
  const flatbuffers::Vector<int8_t> *debug_str() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DEBUG_STR);
  }
  flatbuffers::Vector<int8_t> *mutable_debug_str() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_DEBUG_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEBUG_STR) &&
           verifier.VerifyVector(debug_str()) &&
           verifier.EndTable();
  }
  DebugDumpDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugDumpDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugDumpData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugDumpDataBuilder {
  typedef DebugDumpData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debug_str(flatbuffers::Offset<flatbuffers::Vector<int8_t>> debug_str) {
    fbb_.AddOffset(DebugDumpData::VT_DEBUG_STR, debug_str);
  }
  explicit DebugDumpDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugDumpDataBuilder &operator=(const DebugDumpDataBuilder &);
  flatbuffers::Offset<DebugDumpData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugDumpData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugDumpData> CreateDebugDumpData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> debug_str = 0) {
  DebugDumpDataBuilder builder_(_fbb);
  builder_.add_debug_str(debug_str);
  return builder_.Finish();
}

inline flatbuffers::Offset<DebugDumpData> CreateDebugDumpDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *debug_str = nullptr) {
  auto debug_str__ = debug_str ? _fbb.CreateVector<int8_t>(*debug_str) : 0;
  return chre::fbs::CreateDebugDumpData(
      _fbb,
      debug_str__);
}

flatbuffers::Offset<DebugDumpData> CreateDebugDumpData(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugDumpResponseT : public flatbuffers::NativeTable {
  typedef DebugDumpResponse TableType;
  bool success;
  uint32_t data_count;
  DebugDumpResponseT()
      : success(false),
        data_count(0) {
  }
};

struct DebugDumpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugDumpResponseT NativeTableType;
  typedef DebugDumpResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_DATA_COUNT = 6
  };
  /// true if the request was accepted and a dump was performed, false if it was
  /// rejected or failed to complete for some reason
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  /// The number of DebugDumpData messages sent in this session
  uint32_t data_count() const {
    return GetField<uint32_t>(VT_DATA_COUNT, 0);
  }
  bool mutate_data_count(uint32_t _data_count) {
    return SetField<uint32_t>(VT_DATA_COUNT, _data_count, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<uint32_t>(verifier, VT_DATA_COUNT) &&
           verifier.EndTable();
  }
  DebugDumpResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugDumpResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugDumpResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugDumpResponseBuilder {
  typedef DebugDumpResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(DebugDumpResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_data_count(uint32_t data_count) {
    fbb_.AddElement<uint32_t>(DebugDumpResponse::VT_DATA_COUNT, data_count, 0);
  }
  explicit DebugDumpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DebugDumpResponseBuilder &operator=(const DebugDumpResponseBuilder &);
  flatbuffers::Offset<DebugDumpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugDumpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugDumpResponse> CreateDebugDumpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    uint32_t data_count = 0) {
  DebugDumpResponseBuilder builder_(_fbb);
  builder_.add_data_count(data_count);
  builder_.add_success(success);
  return builder_.Finish();
}

flatbuffers::Offset<DebugDumpResponse> CreateDebugDumpResponse(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TimeSyncRequestT : public flatbuffers::NativeTable {
  typedef TimeSyncRequest TableType;
  TimeSyncRequestT() {
  }
};

/// A request from CHRE for host to initiate a time sync message
/// (system feature, platform-specific - not all platforms necessarily use this)
struct TimeSyncRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeSyncRequestT NativeTableType;
  typedef TimeSyncRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TimeSyncRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimeSyncRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TimeSyncRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimeSyncRequestBuilder {
  typedef TimeSyncRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TimeSyncRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeSyncRequestBuilder &operator=(const TimeSyncRequestBuilder &);
  flatbuffers::Offset<TimeSyncRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeSyncRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeSyncRequest> CreateTimeSyncRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TimeSyncRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TimeSyncRequest> CreateTimeSyncRequest(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LowPowerMicAccessRequestT : public flatbuffers::NativeTable {
  typedef LowPowerMicAccessRequest TableType;
  LowPowerMicAccessRequestT() {
  }
};

/// Request from CHRE to enable direct access to data from the low-power
/// microphone. On some systems, coordination via the AP (e.g. with
/// SoundTrigger HAL) is needed to ensure this capability is powered up when
/// CHRE needs it. The host does not send a response.
struct LowPowerMicAccessRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LowPowerMicAccessRequestT NativeTableType;
  typedef LowPowerMicAccessRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LowPowerMicAccessRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LowPowerMicAccessRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LowPowerMicAccessRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LowPowerMicAccessRequestBuilder {
  typedef LowPowerMicAccessRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LowPowerMicAccessRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LowPowerMicAccessRequestBuilder &operator=(const LowPowerMicAccessRequestBuilder &);
  flatbuffers::Offset<LowPowerMicAccessRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LowPowerMicAccessRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<LowPowerMicAccessRequest> CreateLowPowerMicAccessRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LowPowerMicAccessRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LowPowerMicAccessRequest> CreateLowPowerMicAccessRequest(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LowPowerMicAccessReleaseT : public flatbuffers::NativeTable {
  typedef LowPowerMicAccessRelease TableType;
  LowPowerMicAccessReleaseT() {
  }
};

/// Notification from CHRE that it no longer needs direct access to low-power
/// microphone data.
struct LowPowerMicAccessRelease FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LowPowerMicAccessReleaseT NativeTableType;
  typedef LowPowerMicAccessReleaseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LowPowerMicAccessReleaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LowPowerMicAccessReleaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LowPowerMicAccessRelease> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessReleaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LowPowerMicAccessReleaseBuilder {
  typedef LowPowerMicAccessRelease Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LowPowerMicAccessReleaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LowPowerMicAccessReleaseBuilder &operator=(const LowPowerMicAccessReleaseBuilder &);
  flatbuffers::Offset<LowPowerMicAccessRelease> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LowPowerMicAccessRelease>(end);
    return o;
  }
};

inline flatbuffers::Offset<LowPowerMicAccessRelease> CreateLowPowerMicAccessRelease(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LowPowerMicAccessReleaseBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LowPowerMicAccessRelease> CreateLowPowerMicAccessRelease(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessReleaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SettingChangeMessageT : public flatbuffers::NativeTable {
  typedef SettingChangeMessage TableType;
  chre::fbs::Setting setting;
  chre::fbs::SettingState state;
  SettingChangeMessageT()
      : setting(chre::fbs::Setting::LOCATION),
        state(chre::fbs::SettingState::DISABLED) {
  }
};

/// Notification from the host that a system setting has changed
struct SettingChangeMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingChangeMessageT NativeTableType;
  typedef SettingChangeMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTING = 4,
    VT_STATE = 6
  };
  /// The setting that has changed
  chre::fbs::Setting setting() const {
    return static_cast<chre::fbs::Setting>(GetField<int8_t>(VT_SETTING, 0));
  }
  bool mutate_setting(chre::fbs::Setting _setting) {
    return SetField<int8_t>(VT_SETTING, static_cast<int8_t>(_setting), 0);
  }
  /// The new setting value
  chre::fbs::SettingState state() const {
    return static_cast<chre::fbs::SettingState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool mutate_state(chre::fbs::SettingState _state) {
    return SetField<int8_t>(VT_STATE, static_cast<int8_t>(_state), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SETTING) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
  SettingChangeMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SettingChangeMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SettingChangeMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SettingChangeMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SettingChangeMessageBuilder {
  typedef SettingChangeMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_setting(chre::fbs::Setting setting) {
    fbb_.AddElement<int8_t>(SettingChangeMessage::VT_SETTING, static_cast<int8_t>(setting), 0);
  }
  void add_state(chre::fbs::SettingState state) {
    fbb_.AddElement<int8_t>(SettingChangeMessage::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit SettingChangeMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SettingChangeMessageBuilder &operator=(const SettingChangeMessageBuilder &);
  flatbuffers::Offset<SettingChangeMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingChangeMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingChangeMessage> CreateSettingChangeMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    chre::fbs::Setting setting = chre::fbs::Setting::LOCATION,
    chre::fbs::SettingState state = chre::fbs::SettingState::DISABLED) {
  SettingChangeMessageBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_setting(setting);
  return builder_.Finish();
}

flatbuffers::Offset<SettingChangeMessage> CreateSettingChangeMessage(flatbuffers::FlatBufferBuilder &_fbb, const SettingChangeMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageContainerT : public flatbuffers::NativeTable {
  typedef MessageContainer TableType;
  chre::fbs::ChreMessageUnion message;
  std::unique_ptr<chre::fbs::HostAddress> host_addr;
  MessageContainerT() {
  }
};

/// The top-level container that encapsulates all possible messages. Note that
/// per FlatBuffers requirements, we can't use a union as the top-level
/// structure (root type), so we must wrap it in a table.
struct MessageContainer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageContainerT NativeTableType;
  typedef MessageContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_HOST_ADDR = 8
  };
  chre::fbs::ChreMessage message_type() const {
    return static_cast<chre::fbs::ChreMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const chre::fbs::NanoappMessage *message_as_NanoappMessage() const {
    return message_type() == chre::fbs::ChreMessage::NanoappMessage ? static_cast<const chre::fbs::NanoappMessage *>(message()) : nullptr;
  }
  const chre::fbs::HubInfoRequest *message_as_HubInfoRequest() const {
    return message_type() == chre::fbs::ChreMessage::HubInfoRequest ? static_cast<const chre::fbs::HubInfoRequest *>(message()) : nullptr;
  }
  const chre::fbs::HubInfoResponse *message_as_HubInfoResponse() const {
    return message_type() == chre::fbs::ChreMessage::HubInfoResponse ? static_cast<const chre::fbs::HubInfoResponse *>(message()) : nullptr;
  }
  const chre::fbs::NanoappListRequest *message_as_NanoappListRequest() const {
    return message_type() == chre::fbs::ChreMessage::NanoappListRequest ? static_cast<const chre::fbs::NanoappListRequest *>(message()) : nullptr;
  }
  const chre::fbs::NanoappListResponse *message_as_NanoappListResponse() const {
    return message_type() == chre::fbs::ChreMessage::NanoappListResponse ? static_cast<const chre::fbs::NanoappListResponse *>(message()) : nullptr;
  }
  const chre::fbs::LoadNanoappRequest *message_as_LoadNanoappRequest() const {
    return message_type() == chre::fbs::ChreMessage::LoadNanoappRequest ? static_cast<const chre::fbs::LoadNanoappRequest *>(message()) : nullptr;
  }
  const chre::fbs::LoadNanoappResponse *message_as_LoadNanoappResponse() const {
    return message_type() == chre::fbs::ChreMessage::LoadNanoappResponse ? static_cast<const chre::fbs::LoadNanoappResponse *>(message()) : nullptr;
  }
  const chre::fbs::UnloadNanoappRequest *message_as_UnloadNanoappRequest() const {
    return message_type() == chre::fbs::ChreMessage::UnloadNanoappRequest ? static_cast<const chre::fbs::UnloadNanoappRequest *>(message()) : nullptr;
  }
  const chre::fbs::UnloadNanoappResponse *message_as_UnloadNanoappResponse() const {
    return message_type() == chre::fbs::ChreMessage::UnloadNanoappResponse ? static_cast<const chre::fbs::UnloadNanoappResponse *>(message()) : nullptr;
  }
  const chre::fbs::LogMessage *message_as_LogMessage() const {
    return message_type() == chre::fbs::ChreMessage::LogMessage ? static_cast<const chre::fbs::LogMessage *>(message()) : nullptr;
  }
  const chre::fbs::TimeSyncMessage *message_as_TimeSyncMessage() const {
    return message_type() == chre::fbs::ChreMessage::TimeSyncMessage ? static_cast<const chre::fbs::TimeSyncMessage *>(message()) : nullptr;
  }
  const chre::fbs::DebugDumpRequest *message_as_DebugDumpRequest() const {
    return message_type() == chre::fbs::ChreMessage::DebugDumpRequest ? static_cast<const chre::fbs::DebugDumpRequest *>(message()) : nullptr;
  }
  const chre::fbs::DebugDumpData *message_as_DebugDumpData() const {
    return message_type() == chre::fbs::ChreMessage::DebugDumpData ? static_cast<const chre::fbs::DebugDumpData *>(message()) : nullptr;
  }
  const chre::fbs::DebugDumpResponse *message_as_DebugDumpResponse() const {
    return message_type() == chre::fbs::ChreMessage::DebugDumpResponse ? static_cast<const chre::fbs::DebugDumpResponse *>(message()) : nullptr;
  }
  const chre::fbs::TimeSyncRequest *message_as_TimeSyncRequest() const {
    return message_type() == chre::fbs::ChreMessage::TimeSyncRequest ? static_cast<const chre::fbs::TimeSyncRequest *>(message()) : nullptr;
  }
  const chre::fbs::LowPowerMicAccessRequest *message_as_LowPowerMicAccessRequest() const {
    return message_type() == chre::fbs::ChreMessage::LowPowerMicAccessRequest ? static_cast<const chre::fbs::LowPowerMicAccessRequest *>(message()) : nullptr;
  }
  const chre::fbs::LowPowerMicAccessRelease *message_as_LowPowerMicAccessRelease() const {
    return message_type() == chre::fbs::ChreMessage::LowPowerMicAccessRelease ? static_cast<const chre::fbs::LowPowerMicAccessRelease *>(message()) : nullptr;
  }
  const chre::fbs::SettingChangeMessage *message_as_SettingChangeMessage() const {
    return message_type() == chre::fbs::ChreMessage::SettingChangeMessage ? static_cast<const chre::fbs::SettingChangeMessage *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  /// The originating or destination client ID on the host side, used to direct
  /// responses only to the client that sent the request. Although initially
  /// populated by the requesting client, this is enforced to be the correct
  /// value by the entity guarding access to CHRE.
  /// This is wrapped in a struct to ensure that it is always included when
  /// encoding the message, so it can be mutated by the host daemon.
  const chre::fbs::HostAddress *host_addr() const {
    return GetStruct<const chre::fbs::HostAddress *>(VT_HOST_ADDR);
  }
  chre::fbs::HostAddress *mutable_host_addr() {
    return GetStruct<chre::fbs::HostAddress *>(VT_HOST_ADDR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           VerifyChreMessage(verifier, message(), message_type()) &&
           VerifyFieldRequired<chre::fbs::HostAddress>(verifier, VT_HOST_ADDR) &&
           verifier.EndTable();
  }
  MessageContainerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageContainerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageContainer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const chre::fbs::NanoappMessage *MessageContainer::message_as<chre::fbs::NanoappMessage>() const {
  return message_as_NanoappMessage();
}

template<> inline const chre::fbs::HubInfoRequest *MessageContainer::message_as<chre::fbs::HubInfoRequest>() const {
  return message_as_HubInfoRequest();
}

template<> inline const chre::fbs::HubInfoResponse *MessageContainer::message_as<chre::fbs::HubInfoResponse>() const {
  return message_as_HubInfoResponse();
}

template<> inline const chre::fbs::NanoappListRequest *MessageContainer::message_as<chre::fbs::NanoappListRequest>() const {
  return message_as_NanoappListRequest();
}

template<> inline const chre::fbs::NanoappListResponse *MessageContainer::message_as<chre::fbs::NanoappListResponse>() const {
  return message_as_NanoappListResponse();
}

template<> inline const chre::fbs::LoadNanoappRequest *MessageContainer::message_as<chre::fbs::LoadNanoappRequest>() const {
  return message_as_LoadNanoappRequest();
}

template<> inline const chre::fbs::LoadNanoappResponse *MessageContainer::message_as<chre::fbs::LoadNanoappResponse>() const {
  return message_as_LoadNanoappResponse();
}

template<> inline const chre::fbs::UnloadNanoappRequest *MessageContainer::message_as<chre::fbs::UnloadNanoappRequest>() const {
  return message_as_UnloadNanoappRequest();
}

template<> inline const chre::fbs::UnloadNanoappResponse *MessageContainer::message_as<chre::fbs::UnloadNanoappResponse>() const {
  return message_as_UnloadNanoappResponse();
}

template<> inline const chre::fbs::LogMessage *MessageContainer::message_as<chre::fbs::LogMessage>() const {
  return message_as_LogMessage();
}

template<> inline const chre::fbs::TimeSyncMessage *MessageContainer::message_as<chre::fbs::TimeSyncMessage>() const {
  return message_as_TimeSyncMessage();
}

template<> inline const chre::fbs::DebugDumpRequest *MessageContainer::message_as<chre::fbs::DebugDumpRequest>() const {
  return message_as_DebugDumpRequest();
}

template<> inline const chre::fbs::DebugDumpData *MessageContainer::message_as<chre::fbs::DebugDumpData>() const {
  return message_as_DebugDumpData();
}

template<> inline const chre::fbs::DebugDumpResponse *MessageContainer::message_as<chre::fbs::DebugDumpResponse>() const {
  return message_as_DebugDumpResponse();
}

template<> inline const chre::fbs::TimeSyncRequest *MessageContainer::message_as<chre::fbs::TimeSyncRequest>() const {
  return message_as_TimeSyncRequest();
}

template<> inline const chre::fbs::LowPowerMicAccessRequest *MessageContainer::message_as<chre::fbs::LowPowerMicAccessRequest>() const {
  return message_as_LowPowerMicAccessRequest();
}

template<> inline const chre::fbs::LowPowerMicAccessRelease *MessageContainer::message_as<chre::fbs::LowPowerMicAccessRelease>() const {
  return message_as_LowPowerMicAccessRelease();
}

template<> inline const chre::fbs::SettingChangeMessage *MessageContainer::message_as<chre::fbs::SettingChangeMessage>() const {
  return message_as_SettingChangeMessage();
}

struct MessageContainerBuilder {
  typedef MessageContainer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(chre::fbs::ChreMessage message_type) {
    fbb_.AddElement<uint8_t>(MessageContainer::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(MessageContainer::VT_MESSAGE, message);
  }
  void add_host_addr(const chre::fbs::HostAddress *host_addr) {
    fbb_.AddStruct(MessageContainer::VT_HOST_ADDR, host_addr);
  }
  explicit MessageContainerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageContainerBuilder &operator=(const MessageContainerBuilder &);
  flatbuffers::Offset<MessageContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageContainer>(end);
    fbb_.Required(o, MessageContainer::VT_MESSAGE);
    fbb_.Required(o, MessageContainer::VT_HOST_ADDR);
    return o;
  }
};

inline flatbuffers::Offset<MessageContainer> CreateMessageContainer(
    flatbuffers::FlatBufferBuilder &_fbb,
    chre::fbs::ChreMessage message_type = chre::fbs::ChreMessage::NONE,
    flatbuffers::Offset<void> message = 0,
    const chre::fbs::HostAddress *host_addr = 0) {
  MessageContainerBuilder builder_(_fbb);
  builder_.add_host_addr(host_addr);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageContainer> CreateMessageContainer(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline NanoappMessageT *NanoappMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappMessageT> _o = std::unique_ptr<chre::fbs::NanoappMessageT>(new NanoappMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappMessage::UnPackTo(NanoappMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = message_type(); _o->message_type = _e; }
  { auto _e = host_endpoint(); _o->host_endpoint = _e; }
  { auto _e = message(); if (_e) { _o->message.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->message[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<NanoappMessage> NanoappMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappMessage> CreateNanoappMessage(flatbuffers::FlatBufferBuilder &_fbb, const NanoappMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _app_id = _o->app_id;
  auto _message_type = _o->message_type;
  auto _host_endpoint = _o->host_endpoint;
  auto _message = _fbb.CreateVector(_o->message);
  return chre::fbs::CreateNanoappMessage(
      _fbb,
      _app_id,
      _message_type,
      _host_endpoint,
      _message);
}

inline HubInfoRequestT *HubInfoRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::HubInfoRequestT> _o = std::unique_ptr<chre::fbs::HubInfoRequestT>(new HubInfoRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HubInfoRequest::UnPackTo(HubInfoRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HubInfoRequest> HubInfoRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHubInfoRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HubInfoRequest> CreateHubInfoRequest(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HubInfoRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateHubInfoRequest(
      _fbb);
}

inline HubInfoResponseT *HubInfoResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::HubInfoResponseT> _o = std::unique_ptr<chre::fbs::HubInfoResponseT>(new HubInfoResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HubInfoResponse::UnPackTo(HubInfoResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) { _o->name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name[_i] = _e->Get(_i); } } }
  { auto _e = vendor(); if (_e) { _o->vendor.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vendor[_i] = _e->Get(_i); } } }
  { auto _e = toolchain(); if (_e) { _o->toolchain.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->toolchain[_i] = _e->Get(_i); } } }
  { auto _e = platform_version(); _o->platform_version = _e; }
  { auto _e = toolchain_version(); _o->toolchain_version = _e; }
  { auto _e = peak_mips(); _o->peak_mips = _e; }
  { auto _e = stopped_power(); _o->stopped_power = _e; }
  { auto _e = sleep_power(); _o->sleep_power = _e; }
  { auto _e = peak_power(); _o->peak_power = _e; }
  { auto _e = max_msg_len(); _o->max_msg_len = _e; }
  { auto _e = platform_id(); _o->platform_id = _e; }
  { auto _e = chre_platform_version(); _o->chre_platform_version = _e; }
}

inline flatbuffers::Offset<HubInfoResponse> HubInfoResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHubInfoResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HubInfoResponse> CreateHubInfoResponse(flatbuffers::FlatBufferBuilder &_fbb, const HubInfoResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HubInfoResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.size() ? _fbb.CreateVector(_o->name) : 0;
  auto _vendor = _o->vendor.size() ? _fbb.CreateVector(_o->vendor) : 0;
  auto _toolchain = _o->toolchain.size() ? _fbb.CreateVector(_o->toolchain) : 0;
  auto _platform_version = _o->platform_version;
  auto _toolchain_version = _o->toolchain_version;
  auto _peak_mips = _o->peak_mips;
  auto _stopped_power = _o->stopped_power;
  auto _sleep_power = _o->sleep_power;
  auto _peak_power = _o->peak_power;
  auto _max_msg_len = _o->max_msg_len;
  auto _platform_id = _o->platform_id;
  auto _chre_platform_version = _o->chre_platform_version;
  return chre::fbs::CreateHubInfoResponse(
      _fbb,
      _name,
      _vendor,
      _toolchain,
      _platform_version,
      _toolchain_version,
      _peak_mips,
      _stopped_power,
      _sleep_power,
      _peak_power,
      _max_msg_len,
      _platform_id,
      _chre_platform_version);
}

inline NanoappListRequestT *NanoappListRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappListRequestT> _o = std::unique_ptr<chre::fbs::NanoappListRequestT>(new NanoappListRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappListRequest::UnPackTo(NanoappListRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NanoappListRequest> NanoappListRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListRequest> CreateNanoappListRequest(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappListRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateNanoappListRequest(
      _fbb);
}

inline NanoappListEntryT *NanoappListEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappListEntryT> _o = std::unique_ptr<chre::fbs::NanoappListEntryT>(new NanoappListEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappListEntry::UnPackTo(NanoappListEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = version(); _o->version = _e; }
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = is_system(); _o->is_system = _e; }
}

inline flatbuffers::Offset<NanoappListEntry> NanoappListEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListEntry> CreateNanoappListEntry(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappListEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _app_id = _o->app_id;
  auto _version = _o->version;
  auto _enabled = _o->enabled;
  auto _is_system = _o->is_system;
  return chre::fbs::CreateNanoappListEntry(
      _fbb,
      _app_id,
      _version,
      _enabled,
      _is_system);
}

inline NanoappListResponseT *NanoappListResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::NanoappListResponseT> _o = std::unique_ptr<chre::fbs::NanoappListResponseT>(new NanoappListResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappListResponse::UnPackTo(NanoappListResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nanoapps(); if (_e) { _o->nanoapps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nanoapps[_i] = std::unique_ptr<chre::fbs::NanoappListEntryT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<NanoappListResponse> NanoappListResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappListResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappListResponse> CreateNanoappListResponse(flatbuffers::FlatBufferBuilder &_fbb, const NanoappListResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappListResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nanoapps = _fbb.CreateVector<flatbuffers::Offset<chre::fbs::NanoappListEntry>> (_o->nanoapps.size(), [](size_t i, _VectorArgs *__va) { return CreateNanoappListEntry(*__va->__fbb, __va->__o->nanoapps[i].get(), __va->__rehasher); }, &_va );
  return chre::fbs::CreateNanoappListResponse(
      _fbb,
      _nanoapps);
}

inline LoadNanoappRequestT *LoadNanoappRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LoadNanoappRequestT> _o = std::unique_ptr<chre::fbs::LoadNanoappRequestT>(new LoadNanoappRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoadNanoappRequest::UnPackTo(LoadNanoappRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction_id(); _o->transaction_id = _e; }
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = app_version(); _o->app_version = _e; }
  { auto _e = target_api_version(); _o->target_api_version = _e; }
  { auto _e = app_binary(); if (_e) { _o->app_binary.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->app_binary[_i] = _e->Get(_i); } } }
  { auto _e = fragment_id(); _o->fragment_id = _e; }
  { auto _e = total_app_size(); _o->total_app_size = _e; }
  { auto _e = app_binary_file_name(); if (_e) { _o->app_binary_file_name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->app_binary_file_name[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<LoadNanoappRequest> LoadNanoappRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoadNanoappRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoadNanoappRequest> CreateLoadNanoappRequest(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoadNanoappRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transaction_id = _o->transaction_id;
  auto _app_id = _o->app_id;
  auto _app_version = _o->app_version;
  auto _target_api_version = _o->target_api_version;
  auto _app_binary = _fbb.CreateVector(_o->app_binary);
  auto _fragment_id = _o->fragment_id;
  auto _total_app_size = _o->total_app_size;
  auto _app_binary_file_name = _o->app_binary_file_name.size() ? _fbb.CreateVector(_o->app_binary_file_name) : 0;
  return chre::fbs::CreateLoadNanoappRequest(
      _fbb,
      _transaction_id,
      _app_id,
      _app_version,
      _target_api_version,
      _app_binary,
      _fragment_id,
      _total_app_size,
      _app_binary_file_name);
}

inline LoadNanoappResponseT *LoadNanoappResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LoadNanoappResponseT> _o = std::unique_ptr<chre::fbs::LoadNanoappResponseT>(new LoadNanoappResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoadNanoappResponse::UnPackTo(LoadNanoappResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction_id(); _o->transaction_id = _e; }
  { auto _e = success(); _o->success = _e; }
  { auto _e = fragment_id(); _o->fragment_id = _e; }
}

inline flatbuffers::Offset<LoadNanoappResponse> LoadNanoappResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoadNanoappResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoadNanoappResponse> CreateLoadNanoappResponse(flatbuffers::FlatBufferBuilder &_fbb, const LoadNanoappResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoadNanoappResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transaction_id = _o->transaction_id;
  auto _success = _o->success;
  auto _fragment_id = _o->fragment_id;
  return chre::fbs::CreateLoadNanoappResponse(
      _fbb,
      _transaction_id,
      _success,
      _fragment_id);
}

inline UnloadNanoappRequestT *UnloadNanoappRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::UnloadNanoappRequestT> _o = std::unique_ptr<chre::fbs::UnloadNanoappRequestT>(new UnloadNanoappRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnloadNanoappRequest::UnPackTo(UnloadNanoappRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction_id(); _o->transaction_id = _e; }
  { auto _e = app_id(); _o->app_id = _e; }
  { auto _e = allow_system_nanoapp_unload(); _o->allow_system_nanoapp_unload = _e; }
}

inline flatbuffers::Offset<UnloadNanoappRequest> UnloadNanoappRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnloadNanoappRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnloadNanoappRequest> CreateUnloadNanoappRequest(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnloadNanoappRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transaction_id = _o->transaction_id;
  auto _app_id = _o->app_id;
  auto _allow_system_nanoapp_unload = _o->allow_system_nanoapp_unload;
  return chre::fbs::CreateUnloadNanoappRequest(
      _fbb,
      _transaction_id,
      _app_id,
      _allow_system_nanoapp_unload);
}

inline UnloadNanoappResponseT *UnloadNanoappResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::UnloadNanoappResponseT> _o = std::unique_ptr<chre::fbs::UnloadNanoappResponseT>(new UnloadNanoappResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnloadNanoappResponse::UnPackTo(UnloadNanoappResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction_id(); _o->transaction_id = _e; }
  { auto _e = success(); _o->success = _e; }
}

inline flatbuffers::Offset<UnloadNanoappResponse> UnloadNanoappResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnloadNanoappResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnloadNanoappResponse> CreateUnloadNanoappResponse(flatbuffers::FlatBufferBuilder &_fbb, const UnloadNanoappResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnloadNanoappResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transaction_id = _o->transaction_id;
  auto _success = _o->success;
  return chre::fbs::CreateUnloadNanoappResponse(
      _fbb,
      _transaction_id,
      _success);
}

inline LogMessageT *LogMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LogMessageT> _o = std::unique_ptr<chre::fbs::LogMessageT>(new LogMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogMessage::UnPackTo(LogMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffer(); if (_e) { _o->buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffer[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<LogMessage> LogMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogMessage> CreateLogMessage(flatbuffers::FlatBufferBuilder &_fbb, const LogMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffer = _o->buffer.size() ? _fbb.CreateVector(_o->buffer) : 0;
  return chre::fbs::CreateLogMessage(
      _fbb,
      _buffer);
}

inline TimeSyncMessageT *TimeSyncMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::TimeSyncMessageT> _o = std::unique_ptr<chre::fbs::TimeSyncMessageT>(new TimeSyncMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TimeSyncMessage::UnPackTo(TimeSyncMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = offset(); _o->offset = _e; }
}

inline flatbuffers::Offset<TimeSyncMessage> TimeSyncMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimeSyncMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TimeSyncMessage> CreateTimeSyncMessage(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TimeSyncMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _offset = _o->offset;
  return chre::fbs::CreateTimeSyncMessage(
      _fbb,
      _offset);
}

inline DebugDumpRequestT *DebugDumpRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::DebugDumpRequestT> _o = std::unique_ptr<chre::fbs::DebugDumpRequestT>(new DebugDumpRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugDumpRequest::UnPackTo(DebugDumpRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DebugDumpRequest> DebugDumpRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugDumpRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugDumpRequest> CreateDebugDumpRequest(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugDumpRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateDebugDumpRequest(
      _fbb);
}

inline DebugDumpDataT *DebugDumpData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::DebugDumpDataT> _o = std::unique_ptr<chre::fbs::DebugDumpDataT>(new DebugDumpDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugDumpData::UnPackTo(DebugDumpDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = debug_str(); if (_e) { _o->debug_str.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->debug_str[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<DebugDumpData> DebugDumpData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugDumpData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugDumpData> CreateDebugDumpData(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugDumpDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _debug_str = _o->debug_str.size() ? _fbb.CreateVector(_o->debug_str) : 0;
  return chre::fbs::CreateDebugDumpData(
      _fbb,
      _debug_str);
}

inline DebugDumpResponseT *DebugDumpResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::DebugDumpResponseT> _o = std::unique_ptr<chre::fbs::DebugDumpResponseT>(new DebugDumpResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugDumpResponse::UnPackTo(DebugDumpResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = success(); _o->success = _e; }
  { auto _e = data_count(); _o->data_count = _e; }
}

inline flatbuffers::Offset<DebugDumpResponse> DebugDumpResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugDumpResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugDumpResponse> CreateDebugDumpResponse(flatbuffers::FlatBufferBuilder &_fbb, const DebugDumpResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugDumpResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _success = _o->success;
  auto _data_count = _o->data_count;
  return chre::fbs::CreateDebugDumpResponse(
      _fbb,
      _success,
      _data_count);
}

inline TimeSyncRequestT *TimeSyncRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::TimeSyncRequestT> _o = std::unique_ptr<chre::fbs::TimeSyncRequestT>(new TimeSyncRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TimeSyncRequest::UnPackTo(TimeSyncRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TimeSyncRequest> TimeSyncRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimeSyncRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TimeSyncRequest> CreateTimeSyncRequest(flatbuffers::FlatBufferBuilder &_fbb, const TimeSyncRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TimeSyncRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateTimeSyncRequest(
      _fbb);
}

inline LowPowerMicAccessRequestT *LowPowerMicAccessRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LowPowerMicAccessRequestT> _o = std::unique_ptr<chre::fbs::LowPowerMicAccessRequestT>(new LowPowerMicAccessRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LowPowerMicAccessRequest::UnPackTo(LowPowerMicAccessRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LowPowerMicAccessRequest> LowPowerMicAccessRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLowPowerMicAccessRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LowPowerMicAccessRequest> CreateLowPowerMicAccessRequest(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LowPowerMicAccessRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateLowPowerMicAccessRequest(
      _fbb);
}

inline LowPowerMicAccessReleaseT *LowPowerMicAccessRelease::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::LowPowerMicAccessReleaseT> _o = std::unique_ptr<chre::fbs::LowPowerMicAccessReleaseT>(new LowPowerMicAccessReleaseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LowPowerMicAccessRelease::UnPackTo(LowPowerMicAccessReleaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LowPowerMicAccessRelease> LowPowerMicAccessRelease::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessReleaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLowPowerMicAccessRelease(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LowPowerMicAccessRelease> CreateLowPowerMicAccessRelease(flatbuffers::FlatBufferBuilder &_fbb, const LowPowerMicAccessReleaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LowPowerMicAccessReleaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return chre::fbs::CreateLowPowerMicAccessRelease(
      _fbb);
}

inline SettingChangeMessageT *SettingChangeMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::SettingChangeMessageT> _o = std::unique_ptr<chre::fbs::SettingChangeMessageT>(new SettingChangeMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SettingChangeMessage::UnPackTo(SettingChangeMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = setting(); _o->setting = _e; }
  { auto _e = state(); _o->state = _e; }
}

inline flatbuffers::Offset<SettingChangeMessage> SettingChangeMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SettingChangeMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSettingChangeMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SettingChangeMessage> CreateSettingChangeMessage(flatbuffers::FlatBufferBuilder &_fbb, const SettingChangeMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SettingChangeMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _setting = _o->setting;
  auto _state = _o->state;
  return chre::fbs::CreateSettingChangeMessage(
      _fbb,
      _setting,
      _state);
}

inline MessageContainerT *MessageContainer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::fbs::MessageContainerT> _o = std::unique_ptr<chre::fbs::MessageContainerT>(new MessageContainerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageContainer::UnPackTo(MessageContainerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; }
  { auto _e = message(); if (_e) _o->message.value = chre::fbs::ChreMessageUnion::UnPack(_e, message_type(), _resolver); }
  { auto _e = host_addr(); if (_e) _o->host_addr = std::unique_ptr<chre::fbs::HostAddress>(new chre::fbs::HostAddress(*_e)); }
}

inline flatbuffers::Offset<MessageContainer> MessageContainer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageContainer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageContainer> CreateMessageContainer(flatbuffers::FlatBufferBuilder &_fbb, const MessageContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageContainerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  auto _host_addr = _o->host_addr ? _o->host_addr.get() : 0;
  return chre::fbs::CreateMessageContainer(
      _fbb,
      _message_type,
      _message,
      _host_addr);
}

inline bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj, ChreMessage type) {
  switch (type) {
    case ChreMessage::NONE: {
      return true;
    }
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LoadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LoadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::UnloadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::UnloadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LogMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::TimeSyncMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::DebugDumpRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::DebugDumpData: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::DebugDumpResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::TimeSyncRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRelease *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ChreMessage::SettingChangeMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::SettingChangeMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyChreMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyChreMessage(
        verifier,  values->Get(i), types->GetEnum<ChreMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ChreMessageUnion::UnPack(const void *obj, ChreMessage type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LoadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LoadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::UnloadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::UnloadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LogMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::TimeSyncMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::DebugDumpRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::DebugDumpData: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpData *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::DebugDumpResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::TimeSyncRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRelease *>(obj);
      return ptr->UnPack(resolver);
    }
    case ChreMessage::SettingChangeMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::SettingChangeMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ChreMessageUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappMessageT *>(value);
      return CreateNanoappMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoRequestT *>(value);
      return CreateHubInfoRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::HubInfoResponseT *>(value);
      return CreateHubInfoResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListRequestT *>(value);
      return CreateNanoappListRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::NanoappListResponseT *>(value);
      return CreateNanoappListResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LoadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappRequestT *>(value);
      return CreateLoadNanoappRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LoadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::LoadNanoappResponseT *>(value);
      return CreateLoadNanoappResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::UnloadNanoappRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappRequestT *>(value);
      return CreateUnloadNanoappRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::UnloadNanoappResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::UnloadNanoappResponseT *>(value);
      return CreateUnloadNanoappResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LogMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::LogMessageT *>(value);
      return CreateLogMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::TimeSyncMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncMessageT *>(value);
      return CreateTimeSyncMessage(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::DebugDumpRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpRequestT *>(value);
      return CreateDebugDumpRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::DebugDumpData: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpDataT *>(value);
      return CreateDebugDumpData(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::DebugDumpResponse: {
      auto ptr = reinterpret_cast<const chre::fbs::DebugDumpResponseT *>(value);
      return CreateDebugDumpResponse(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::TimeSyncRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::TimeSyncRequestT *>(value);
      return CreateTimeSyncRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessRequestT *>(value);
      return CreateLowPowerMicAccessRequest(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      auto ptr = reinterpret_cast<const chre::fbs::LowPowerMicAccessReleaseT *>(value);
      return CreateLowPowerMicAccessRelease(_fbb, ptr, _rehasher).Union();
    }
    case ChreMessage::SettingChangeMessage: {
      auto ptr = reinterpret_cast<const chre::fbs::SettingChangeMessageT *>(value);
      return CreateSettingChangeMessage(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ChreMessageUnion::ChreMessageUnion(const ChreMessageUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      value = new chre::fbs::NanoappMessageT(*reinterpret_cast<chre::fbs::NanoappMessageT *>(u.value));
      break;
    }
    case ChreMessage::HubInfoRequest: {
      value = new chre::fbs::HubInfoRequestT(*reinterpret_cast<chre::fbs::HubInfoRequestT *>(u.value));
      break;
    }
    case ChreMessage::HubInfoResponse: {
      value = new chre::fbs::HubInfoResponseT(*reinterpret_cast<chre::fbs::HubInfoResponseT *>(u.value));
      break;
    }
    case ChreMessage::NanoappListRequest: {
      value = new chre::fbs::NanoappListRequestT(*reinterpret_cast<chre::fbs::NanoappListRequestT *>(u.value));
      break;
    }
    case ChreMessage::NanoappListResponse: {
      FLATBUFFERS_ASSERT(false);  // chre::fbs::NanoappListResponseT not copyable.
      break;
    }
    case ChreMessage::LoadNanoappRequest: {
      value = new chre::fbs::LoadNanoappRequestT(*reinterpret_cast<chre::fbs::LoadNanoappRequestT *>(u.value));
      break;
    }
    case ChreMessage::LoadNanoappResponse: {
      value = new chre::fbs::LoadNanoappResponseT(*reinterpret_cast<chre::fbs::LoadNanoappResponseT *>(u.value));
      break;
    }
    case ChreMessage::UnloadNanoappRequest: {
      value = new chre::fbs::UnloadNanoappRequestT(*reinterpret_cast<chre::fbs::UnloadNanoappRequestT *>(u.value));
      break;
    }
    case ChreMessage::UnloadNanoappResponse: {
      value = new chre::fbs::UnloadNanoappResponseT(*reinterpret_cast<chre::fbs::UnloadNanoappResponseT *>(u.value));
      break;
    }
    case ChreMessage::LogMessage: {
      value = new chre::fbs::LogMessageT(*reinterpret_cast<chre::fbs::LogMessageT *>(u.value));
      break;
    }
    case ChreMessage::TimeSyncMessage: {
      value = new chre::fbs::TimeSyncMessageT(*reinterpret_cast<chre::fbs::TimeSyncMessageT *>(u.value));
      break;
    }
    case ChreMessage::DebugDumpRequest: {
      value = new chre::fbs::DebugDumpRequestT(*reinterpret_cast<chre::fbs::DebugDumpRequestT *>(u.value));
      break;
    }
    case ChreMessage::DebugDumpData: {
      value = new chre::fbs::DebugDumpDataT(*reinterpret_cast<chre::fbs::DebugDumpDataT *>(u.value));
      break;
    }
    case ChreMessage::DebugDumpResponse: {
      value = new chre::fbs::DebugDumpResponseT(*reinterpret_cast<chre::fbs::DebugDumpResponseT *>(u.value));
      break;
    }
    case ChreMessage::TimeSyncRequest: {
      value = new chre::fbs::TimeSyncRequestT(*reinterpret_cast<chre::fbs::TimeSyncRequestT *>(u.value));
      break;
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      value = new chre::fbs::LowPowerMicAccessRequestT(*reinterpret_cast<chre::fbs::LowPowerMicAccessRequestT *>(u.value));
      break;
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      value = new chre::fbs::LowPowerMicAccessReleaseT(*reinterpret_cast<chre::fbs::LowPowerMicAccessReleaseT *>(u.value));
      break;
    }
    case ChreMessage::SettingChangeMessage: {
      value = new chre::fbs::SettingChangeMessageT(*reinterpret_cast<chre::fbs::SettingChangeMessageT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ChreMessageUnion::Reset() {
  switch (type) {
    case ChreMessage::NanoappMessage: {
      auto ptr = reinterpret_cast<chre::fbs::NanoappMessageT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::HubInfoRequest: {
      auto ptr = reinterpret_cast<chre::fbs::HubInfoRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::HubInfoResponse: {
      auto ptr = reinterpret_cast<chre::fbs::HubInfoResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::NanoappListRequest: {
      auto ptr = reinterpret_cast<chre::fbs::NanoappListRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::NanoappListResponse: {
      auto ptr = reinterpret_cast<chre::fbs::NanoappListResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LoadNanoappRequest: {
      auto ptr = reinterpret_cast<chre::fbs::LoadNanoappRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LoadNanoappResponse: {
      auto ptr = reinterpret_cast<chre::fbs::LoadNanoappResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::UnloadNanoappRequest: {
      auto ptr = reinterpret_cast<chre::fbs::UnloadNanoappRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::UnloadNanoappResponse: {
      auto ptr = reinterpret_cast<chre::fbs::UnloadNanoappResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LogMessage: {
      auto ptr = reinterpret_cast<chre::fbs::LogMessageT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::TimeSyncMessage: {
      auto ptr = reinterpret_cast<chre::fbs::TimeSyncMessageT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::DebugDumpRequest: {
      auto ptr = reinterpret_cast<chre::fbs::DebugDumpRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::DebugDumpData: {
      auto ptr = reinterpret_cast<chre::fbs::DebugDumpDataT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::DebugDumpResponse: {
      auto ptr = reinterpret_cast<chre::fbs::DebugDumpResponseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::TimeSyncRequest: {
      auto ptr = reinterpret_cast<chre::fbs::TimeSyncRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LowPowerMicAccessRequest: {
      auto ptr = reinterpret_cast<chre::fbs::LowPowerMicAccessRequestT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::LowPowerMicAccessRelease: {
      auto ptr = reinterpret_cast<chre::fbs::LowPowerMicAccessReleaseT *>(value);
      delete ptr;
      break;
    }
    case ChreMessage::SettingChangeMessage: {
      auto ptr = reinterpret_cast<chre::fbs::SettingChangeMessageT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ChreMessage::NONE;
}

inline const chre::fbs::MessageContainer *GetMessageContainer(const void *buf) {
  return flatbuffers::GetRoot<chre::fbs::MessageContainer>(buf);
}

inline const chre::fbs::MessageContainer *GetSizePrefixedMessageContainer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<chre::fbs::MessageContainer>(buf);
}

inline MessageContainer *GetMutableMessageContainer(void *buf) {
  return flatbuffers::GetMutableRoot<MessageContainer>(buf);
}

inline bool VerifyMessageContainerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<chre::fbs::MessageContainer>(nullptr);
}

inline bool VerifySizePrefixedMessageContainerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<chre::fbs::MessageContainer>(nullptr);
}

inline void FinishMessageContainerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<chre::fbs::MessageContainer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageContainerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<chre::fbs::MessageContainer> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<chre::fbs::MessageContainerT> UnPackMessageContainer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<chre::fbs::MessageContainerT>(GetMessageContainer(buf)->UnPack(res));
}

inline std::unique_ptr<chre::fbs::MessageContainerT> UnPackSizePrefixedMessageContainer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<chre::fbs::MessageContainerT>(GetSizePrefixedMessageContainer(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace chre

#endif  // FLATBUFFERS_GENERATED_HOSTMESSAGES_CHRE_FBS_H_
