// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_
#define FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_

#include "flatbuffers/flatbuffers.h"

namespace chre {
namespace power_test {

struct TimerMessage;
struct TimerMessageBuilder;
struct TimerMessageT;

struct WifiScanMessage;
struct WifiScanMessageBuilder;
struct WifiScanMessageT;

struct GnssLocationMessage;
struct GnssLocationMessageBuilder;
struct GnssLocationMessageT;

struct CellQueryMessage;
struct CellQueryMessageBuilder;
struct CellQueryMessageT;

struct AudioRequestMessage;
struct AudioRequestMessageBuilder;
struct AudioRequestMessageT;

struct SensorRequestMessage;
struct SensorRequestMessageBuilder;
struct SensorRequestMessageT;

struct BreakItMessage;
struct BreakItMessageBuilder;
struct BreakItMessageT;

struct NanoappResponseMessage;
struct NanoappResponseMessageBuilder;
struct NanoappResponseMessageT;

/// Indicates which of the following messages is being sent to / from the
/// nanoapp. Use uint as the base type to match the message type in
/// chreMessageFromHostData.
enum class MessageType : uint32_t {
  UNSPECIFIED = 0,
  /// Should be used with TimerMessage
  TIMER_TEST = 1,
  /// Should be used with WifiScanMessage
  WIFI_SCAN_TEST = 2,
  /// Should be used with GnssLocationMessage
  GNSS_LOCATION_TEST = 3,
  /// Should be used with CellQueryMessage
  CELL_QUERY_TEST = 4,
  /// Should be used with AudioRequestMessage
  AUDIO_REQUEST_TEST = 5,
  /// Should be used with SensorRequestMessage
  SENSOR_REQUEST_TEST = 6,
  /// Should be used with BreakItMessage
  BREAK_IT_TEST = 7,
  /// Should be used with NanoappResponseMessage
  NANOAPP_RESPONSE = 8,
  MIN = UNSPECIFIED,
  MAX = NANOAPP_RESPONSE
};

inline const MessageType (&EnumValuesMessageType())[9] {
  static const MessageType values[] = {
    MessageType::UNSPECIFIED,
    MessageType::TIMER_TEST,
    MessageType::WIFI_SCAN_TEST,
    MessageType::GNSS_LOCATION_TEST,
    MessageType::CELL_QUERY_TEST,
    MessageType::AUDIO_REQUEST_TEST,
    MessageType::SENSOR_REQUEST_TEST,
    MessageType::BREAK_IT_TEST,
    MessageType::NANOAPP_RESPONSE
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[10] = {
    "UNSPECIFIED",
    "TIMER_TEST",
    "WIFI_SCAN_TEST",
    "GNSS_LOCATION_TEST",
    "CELL_QUERY_TEST",
    "AUDIO_REQUEST_TEST",
    "SENSOR_REQUEST_TEST",
    "BREAK_IT_TEST",
    "NANOAPP_RESPONSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (flatbuffers::IsOutRange(e, MessageType::UNSPECIFIED, MessageType::NANOAPP_RESPONSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

/// All the various sensors that can be interacted with inside the nanoapp.
/// The values used here map directly to values from the CHRE API
enum class SensorType : uint8_t {
  UNKNOWN = 0,
  ACCELEROMETER = 1,
  INSTANT_MOTION_DETECT = 2,
  STATIONARY_DETECT = 3,
  GYROSCOPE = 6,
  UNCALIBRATED_GYROSCOPE = 7,
  GEOMAGNETIC_FIELD = 8,
  UNCALIBRATED_GEOMAGNETIC_FIELD = 9,
  PRESSURE = 10,
  LIGHT = 12,
  PROXIMITY = 13,
  STEP_DETECT = 23,
  UNCALIBRATED_ACCELEROMETER = 55,
  ACCELEROMETER_TEMPERATURE = 56,
  GYROSCOPE_TEMPERATURE = 57,
  GEOMAGNETIC_FIELD_TEMPERATURE = 58,
  MIN = UNKNOWN,
  MAX = GEOMAGNETIC_FIELD_TEMPERATURE
};

inline const SensorType (&EnumValuesSensorType())[16] {
  static const SensorType values[] = {
    SensorType::UNKNOWN,
    SensorType::ACCELEROMETER,
    SensorType::INSTANT_MOTION_DETECT,
    SensorType::STATIONARY_DETECT,
    SensorType::GYROSCOPE,
    SensorType::UNCALIBRATED_GYROSCOPE,
    SensorType::GEOMAGNETIC_FIELD,
    SensorType::UNCALIBRATED_GEOMAGNETIC_FIELD,
    SensorType::PRESSURE,
    SensorType::LIGHT,
    SensorType::PROXIMITY,
    SensorType::STEP_DETECT,
    SensorType::UNCALIBRATED_ACCELEROMETER,
    SensorType::ACCELEROMETER_TEMPERATURE,
    SensorType::GYROSCOPE_TEMPERATURE,
    SensorType::GEOMAGNETIC_FIELD_TEMPERATURE
  };
  return values;
}

inline const char * const *EnumNamesSensorType() {
  static const char * const names[60] = {
    "UNKNOWN",
    "ACCELEROMETER",
    "INSTANT_MOTION_DETECT",
    "STATIONARY_DETECT",
    "",
    "",
    "GYROSCOPE",
    "UNCALIBRATED_GYROSCOPE",
    "GEOMAGNETIC_FIELD",
    "UNCALIBRATED_GEOMAGNETIC_FIELD",
    "PRESSURE",
    "",
    "LIGHT",
    "PROXIMITY",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "STEP_DETECT",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "UNCALIBRATED_ACCELEROMETER",
    "ACCELEROMETER_TEMPERATURE",
    "GYROSCOPE_TEMPERATURE",
    "GEOMAGNETIC_FIELD_TEMPERATURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorType(SensorType e) {
  if (flatbuffers::IsOutRange(e, SensorType::UNKNOWN, SensorType::GEOMAGNETIC_FIELD_TEMPERATURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorType()[index];
}

struct TimerMessageT : public flatbuffers::NativeTable {
  typedef TimerMessage TableType;
  bool enable;
  uint64_t wakeup_interval_ns;
  TimerMessageT()
      : enable(false),
        wakeup_interval_ns(0) {
  }
};

/// Represents a message to ask the nanoapp to create a timer that wakes up at
/// the given interval
struct TimerMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimerMessageT NativeTableType;
  typedef TimerMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_WAKEUP_INTERVAL_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool mutate_enable(bool _enable) {
    return SetField<uint8_t>(VT_ENABLE, static_cast<uint8_t>(_enable), 0);
  }
  uint64_t wakeup_interval_ns() const {
    return GetField<uint64_t>(VT_WAKEUP_INTERVAL_NS, 0);
  }
  bool mutate_wakeup_interval_ns(uint64_t _wakeup_interval_ns) {
    return SetField<uint64_t>(VT_WAKEUP_INTERVAL_NS, _wakeup_interval_ns, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_WAKEUP_INTERVAL_NS) &&
           verifier.EndTable();
  }
  TimerMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimerMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TimerMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimerMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimerMessageBuilder {
  typedef TimerMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(TimerMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_wakeup_interval_ns(uint64_t wakeup_interval_ns) {
    fbb_.AddElement<uint64_t>(TimerMessage::VT_WAKEUP_INTERVAL_NS, wakeup_interval_ns, 0);
  }
  explicit TimerMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimerMessageBuilder &operator=(const TimerMessageBuilder &);
  flatbuffers::Offset<TimerMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimerMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimerMessage> CreateTimerMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t wakeup_interval_ns = 0) {
  TimerMessageBuilder builder_(_fbb);
  builder_.add_wakeup_interval_ns(wakeup_interval_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

flatbuffers::Offset<TimerMessage> CreateTimerMessage(flatbuffers::FlatBufferBuilder &_fbb, const TimerMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WifiScanMessageT : public flatbuffers::NativeTable {
  typedef WifiScanMessage TableType;
  bool enable;
  uint64_t scan_interval_ns;
  WifiScanMessageT()
      : enable(false),
        scan_interval_ns(0) {
  }
};

/// Represents a message to ask the nanoapp to start or stop WiFi scanning and
/// the scan interval to use if scanning is being started
struct WifiScanMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WifiScanMessageT NativeTableType;
  typedef WifiScanMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_SCAN_INTERVAL_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool mutate_enable(bool _enable) {
    return SetField<uint8_t>(VT_ENABLE, static_cast<uint8_t>(_enable), 0);
  }
  uint64_t scan_interval_ns() const {
    return GetField<uint64_t>(VT_SCAN_INTERVAL_NS, 0);
  }
  bool mutate_scan_interval_ns(uint64_t _scan_interval_ns) {
    return SetField<uint64_t>(VT_SCAN_INTERVAL_NS, _scan_interval_ns, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_SCAN_INTERVAL_NS) &&
           verifier.EndTable();
  }
  WifiScanMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WifiScanMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WifiScanMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WifiScanMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WifiScanMessageBuilder {
  typedef WifiScanMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(WifiScanMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_scan_interval_ns(uint64_t scan_interval_ns) {
    fbb_.AddElement<uint64_t>(WifiScanMessage::VT_SCAN_INTERVAL_NS, scan_interval_ns, 0);
  }
  explicit WifiScanMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WifiScanMessageBuilder &operator=(const WifiScanMessageBuilder &);
  flatbuffers::Offset<WifiScanMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WifiScanMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<WifiScanMessage> CreateWifiScanMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t scan_interval_ns = 0) {
  WifiScanMessageBuilder builder_(_fbb);
  builder_.add_scan_interval_ns(scan_interval_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

flatbuffers::Offset<WifiScanMessage> CreateWifiScanMessage(flatbuffers::FlatBufferBuilder &_fbb, const WifiScanMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GnssLocationMessageT : public flatbuffers::NativeTable {
  typedef GnssLocationMessage TableType;
  bool enable;
  uint32_t scan_interval_millis;
  uint32_t min_time_to_next_fix_millis;
  GnssLocationMessageT()
      : enable(false),
        scan_interval_millis(0),
        min_time_to_next_fix_millis(0) {
  }
};

/// Represents a message to ask the nanoapp to start or stop Gnss location
/// sampling at the requested interval
struct GnssLocationMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GnssLocationMessageT NativeTableType;
  typedef GnssLocationMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_SCAN_INTERVAL_MILLIS = 6,
    VT_MIN_TIME_TO_NEXT_FIX_MILLIS = 8
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool mutate_enable(bool _enable) {
    return SetField<uint8_t>(VT_ENABLE, static_cast<uint8_t>(_enable), 0);
  }
  uint32_t scan_interval_millis() const {
    return GetField<uint32_t>(VT_SCAN_INTERVAL_MILLIS, 0);
  }
  bool mutate_scan_interval_millis(uint32_t _scan_interval_millis) {
    return SetField<uint32_t>(VT_SCAN_INTERVAL_MILLIS, _scan_interval_millis, 0);
  }
  uint32_t min_time_to_next_fix_millis() const {
    return GetField<uint32_t>(VT_MIN_TIME_TO_NEXT_FIX_MILLIS, 0);
  }
  bool mutate_min_time_to_next_fix_millis(uint32_t _min_time_to_next_fix_millis) {
    return SetField<uint32_t>(VT_MIN_TIME_TO_NEXT_FIX_MILLIS, _min_time_to_next_fix_millis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint32_t>(verifier, VT_SCAN_INTERVAL_MILLIS) &&
           VerifyField<uint32_t>(verifier, VT_MIN_TIME_TO_NEXT_FIX_MILLIS) &&
           verifier.EndTable();
  }
  GnssLocationMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GnssLocationMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GnssLocationMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GnssLocationMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GnssLocationMessageBuilder {
  typedef GnssLocationMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(GnssLocationMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_scan_interval_millis(uint32_t scan_interval_millis) {
    fbb_.AddElement<uint32_t>(GnssLocationMessage::VT_SCAN_INTERVAL_MILLIS, scan_interval_millis, 0);
  }
  void add_min_time_to_next_fix_millis(uint32_t min_time_to_next_fix_millis) {
    fbb_.AddElement<uint32_t>(GnssLocationMessage::VT_MIN_TIME_TO_NEXT_FIX_MILLIS, min_time_to_next_fix_millis, 0);
  }
  explicit GnssLocationMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GnssLocationMessageBuilder &operator=(const GnssLocationMessageBuilder &);
  flatbuffers::Offset<GnssLocationMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GnssLocationMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<GnssLocationMessage> CreateGnssLocationMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint32_t scan_interval_millis = 0,
    uint32_t min_time_to_next_fix_millis = 0) {
  GnssLocationMessageBuilder builder_(_fbb);
  builder_.add_min_time_to_next_fix_millis(min_time_to_next_fix_millis);
  builder_.add_scan_interval_millis(scan_interval_millis);
  builder_.add_enable(enable);
  return builder_.Finish();
}

flatbuffers::Offset<GnssLocationMessage> CreateGnssLocationMessage(flatbuffers::FlatBufferBuilder &_fbb, const GnssLocationMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CellQueryMessageT : public flatbuffers::NativeTable {
  typedef CellQueryMessage TableType;
  bool enable;
  uint64_t query_interval_ns;
  CellQueryMessageT()
      : enable(false),
        query_interval_ns(0) {
  }
};

/// Represents a message to ask the nanoapp to start or stop querying the cell
/// modem for the latest cell scan results on the given interval
struct CellQueryMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellQueryMessageT NativeTableType;
  typedef CellQueryMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_QUERY_INTERVAL_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool mutate_enable(bool _enable) {
    return SetField<uint8_t>(VT_ENABLE, static_cast<uint8_t>(_enable), 0);
  }
  uint64_t query_interval_ns() const {
    return GetField<uint64_t>(VT_QUERY_INTERVAL_NS, 0);
  }
  bool mutate_query_interval_ns(uint64_t _query_interval_ns) {
    return SetField<uint64_t>(VT_QUERY_INTERVAL_NS, _query_interval_ns, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_QUERY_INTERVAL_NS) &&
           verifier.EndTable();
  }
  CellQueryMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CellQueryMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CellQueryMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellQueryMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CellQueryMessageBuilder {
  typedef CellQueryMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(CellQueryMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_query_interval_ns(uint64_t query_interval_ns) {
    fbb_.AddElement<uint64_t>(CellQueryMessage::VT_QUERY_INTERVAL_NS, query_interval_ns, 0);
  }
  explicit CellQueryMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellQueryMessageBuilder &operator=(const CellQueryMessageBuilder &);
  flatbuffers::Offset<CellQueryMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellQueryMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellQueryMessage> CreateCellQueryMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t query_interval_ns = 0) {
  CellQueryMessageBuilder builder_(_fbb);
  builder_.add_query_interval_ns(query_interval_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

flatbuffers::Offset<CellQueryMessage> CreateCellQueryMessage(flatbuffers::FlatBufferBuilder &_fbb, const CellQueryMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AudioRequestMessageT : public flatbuffers::NativeTable {
  typedef AudioRequestMessage TableType;
  bool enable;
  uint64_t buffer_duration_ns;
  AudioRequestMessageT()
      : enable(false),
        buffer_duration_ns(0) {
  }
};

/// Represents a message to ask the nanoapp to start / stop requesting Audio
/// data buffered at given interval. Note: If there is more than one audio
/// source, the nanoapp will only request audio from the first source.
struct AudioRequestMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioRequestMessageT NativeTableType;
  typedef AudioRequestMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_BUFFER_DURATION_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool mutate_enable(bool _enable) {
    return SetField<uint8_t>(VT_ENABLE, static_cast<uint8_t>(_enable), 0);
  }
  /// The buffer duration is also used as the interval for how often
  /// the buffer should be delivered to the nanoapp.
  uint64_t buffer_duration_ns() const {
    return GetField<uint64_t>(VT_BUFFER_DURATION_NS, 0);
  }
  bool mutate_buffer_duration_ns(uint64_t _buffer_duration_ns) {
    return SetField<uint64_t>(VT_BUFFER_DURATION_NS, _buffer_duration_ns, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_BUFFER_DURATION_NS) &&
           verifier.EndTable();
  }
  AudioRequestMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AudioRequestMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AudioRequestMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioRequestMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AudioRequestMessageBuilder {
  typedef AudioRequestMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(AudioRequestMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_buffer_duration_ns(uint64_t buffer_duration_ns) {
    fbb_.AddElement<uint64_t>(AudioRequestMessage::VT_BUFFER_DURATION_NS, buffer_duration_ns, 0);
  }
  explicit AudioRequestMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AudioRequestMessageBuilder &operator=(const AudioRequestMessageBuilder &);
  flatbuffers::Offset<AudioRequestMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioRequestMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioRequestMessage> CreateAudioRequestMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t buffer_duration_ns = 0) {
  AudioRequestMessageBuilder builder_(_fbb);
  builder_.add_buffer_duration_ns(buffer_duration_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

flatbuffers::Offset<AudioRequestMessage> CreateAudioRequestMessage(flatbuffers::FlatBufferBuilder &_fbb, const AudioRequestMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SensorRequestMessageT : public flatbuffers::NativeTable {
  typedef SensorRequestMessage TableType;
  bool enable;
  chre::power_test::SensorType sensor;
  uint64_t sampling_interval_ns;
  uint64_t latency_ns;
  SensorRequestMessageT()
      : enable(false),
        sensor(chre::power_test::SensorType::UNKNOWN),
        sampling_interval_ns(0),
        latency_ns(0) {
  }
};

/// Represents a message to ask the nanoapp to start / stop sampling / batching
/// a given sensor
struct SensorRequestMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SensorRequestMessageT NativeTableType;
  typedef SensorRequestMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_SENSOR = 6,
    VT_SAMPLING_INTERVAL_NS = 8,
    VT_LATENCY_NS = 10
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool mutate_enable(bool _enable) {
    return SetField<uint8_t>(VT_ENABLE, static_cast<uint8_t>(_enable), 0);
  }
  chre::power_test::SensorType sensor() const {
    return static_cast<chre::power_test::SensorType>(GetField<uint8_t>(VT_SENSOR, 0));
  }
  bool mutate_sensor(chre::power_test::SensorType _sensor) {
    return SetField<uint8_t>(VT_SENSOR, static_cast<uint8_t>(_sensor), 0);
  }
  uint64_t sampling_interval_ns() const {
    return GetField<uint64_t>(VT_SAMPLING_INTERVAL_NS, 0);
  }
  bool mutate_sampling_interval_ns(uint64_t _sampling_interval_ns) {
    return SetField<uint64_t>(VT_SAMPLING_INTERVAL_NS, _sampling_interval_ns, 0);
  }
  uint64_t latency_ns() const {
    return GetField<uint64_t>(VT_LATENCY_NS, 0);
  }
  bool mutate_latency_ns(uint64_t _latency_ns) {
    return SetField<uint64_t>(VT_LATENCY_NS, _latency_ns, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint8_t>(verifier, VT_SENSOR) &&
           VerifyField<uint64_t>(verifier, VT_SAMPLING_INTERVAL_NS) &&
           VerifyField<uint64_t>(verifier, VT_LATENCY_NS) &&
           verifier.EndTable();
  }
  SensorRequestMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SensorRequestMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SensorRequestMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SensorRequestMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SensorRequestMessageBuilder {
  typedef SensorRequestMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(SensorRequestMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_sensor(chre::power_test::SensorType sensor) {
    fbb_.AddElement<uint8_t>(SensorRequestMessage::VT_SENSOR, static_cast<uint8_t>(sensor), 0);
  }
  void add_sampling_interval_ns(uint64_t sampling_interval_ns) {
    fbb_.AddElement<uint64_t>(SensorRequestMessage::VT_SAMPLING_INTERVAL_NS, sampling_interval_ns, 0);
  }
  void add_latency_ns(uint64_t latency_ns) {
    fbb_.AddElement<uint64_t>(SensorRequestMessage::VT_LATENCY_NS, latency_ns, 0);
  }
  explicit SensorRequestMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SensorRequestMessageBuilder &operator=(const SensorRequestMessageBuilder &);
  flatbuffers::Offset<SensorRequestMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SensorRequestMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SensorRequestMessage> CreateSensorRequestMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    chre::power_test::SensorType sensor = chre::power_test::SensorType::UNKNOWN,
    uint64_t sampling_interval_ns = 0,
    uint64_t latency_ns = 0) {
  SensorRequestMessageBuilder builder_(_fbb);
  builder_.add_latency_ns(latency_ns);
  builder_.add_sampling_interval_ns(sampling_interval_ns);
  builder_.add_sensor(sensor);
  builder_.add_enable(enable);
  return builder_.Finish();
}

flatbuffers::Offset<SensorRequestMessage> CreateSensorRequestMessage(flatbuffers::FlatBufferBuilder &_fbb, const SensorRequestMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BreakItMessageT : public flatbuffers::NativeTable {
  typedef BreakItMessage TableType;
  bool enable;
  BreakItMessageT()
      : enable(false) {
  }
};

/// Represents a message to enable / disable break-it mode inside the nanoapp.
/// Break-it mode enables WiFi / GNSS / Cell to be queried every second and
/// enables all sensors at their fastest sampling rate.
struct BreakItMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BreakItMessageT NativeTableType;
  typedef BreakItMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool mutate_enable(bool _enable) {
    return SetField<uint8_t>(VT_ENABLE, static_cast<uint8_t>(_enable), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           verifier.EndTable();
  }
  BreakItMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BreakItMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BreakItMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BreakItMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BreakItMessageBuilder {
  typedef BreakItMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(BreakItMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  explicit BreakItMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BreakItMessageBuilder &operator=(const BreakItMessageBuilder &);
  flatbuffers::Offset<BreakItMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BreakItMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<BreakItMessage> CreateBreakItMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false) {
  BreakItMessageBuilder builder_(_fbb);
  builder_.add_enable(enable);
  return builder_.Finish();
}

flatbuffers::Offset<BreakItMessage> CreateBreakItMessage(flatbuffers::FlatBufferBuilder &_fbb, const BreakItMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NanoappResponseMessageT : public flatbuffers::NativeTable {
  typedef NanoappResponseMessage TableType;
  bool success;
  NanoappResponseMessageT()
      : success(false) {
  }
};

/// Indicates whether the nanoapp successfully performed the requested action.
/// Any failures will be printed to the logs.
struct NanoappResponseMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappResponseMessageT NativeTableType;
  typedef NanoappResponseMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
  NanoappResponseMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NanoappResponseMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NanoappResponseMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappResponseMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NanoappResponseMessageBuilder {
  typedef NanoappResponseMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(NanoappResponseMessage::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit NanoappResponseMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappResponseMessageBuilder &operator=(const NanoappResponseMessageBuilder &);
  flatbuffers::Offset<NanoappResponseMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappResponseMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappResponseMessage> CreateNanoappResponseMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  NanoappResponseMessageBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

flatbuffers::Offset<NanoappResponseMessage> CreateNanoappResponseMessage(flatbuffers::FlatBufferBuilder &_fbb, const NanoappResponseMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TimerMessageT *TimerMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::power_test::TimerMessageT> _o = std::unique_ptr<chre::power_test::TimerMessageT>(new TimerMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TimerMessage::UnPackTo(TimerMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable(); _o->enable = _e; }
  { auto _e = wakeup_interval_ns(); _o->wakeup_interval_ns = _e; }
}

inline flatbuffers::Offset<TimerMessage> TimerMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimerMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimerMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TimerMessage> CreateTimerMessage(flatbuffers::FlatBufferBuilder &_fbb, const TimerMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TimerMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable = _o->enable;
  auto _wakeup_interval_ns = _o->wakeup_interval_ns;
  return chre::power_test::CreateTimerMessage(
      _fbb,
      _enable,
      _wakeup_interval_ns);
}

inline WifiScanMessageT *WifiScanMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::power_test::WifiScanMessageT> _o = std::unique_ptr<chre::power_test::WifiScanMessageT>(new WifiScanMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WifiScanMessage::UnPackTo(WifiScanMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable(); _o->enable = _e; }
  { auto _e = scan_interval_ns(); _o->scan_interval_ns = _e; }
}

inline flatbuffers::Offset<WifiScanMessage> WifiScanMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WifiScanMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWifiScanMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WifiScanMessage> CreateWifiScanMessage(flatbuffers::FlatBufferBuilder &_fbb, const WifiScanMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WifiScanMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable = _o->enable;
  auto _scan_interval_ns = _o->scan_interval_ns;
  return chre::power_test::CreateWifiScanMessage(
      _fbb,
      _enable,
      _scan_interval_ns);
}

inline GnssLocationMessageT *GnssLocationMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::power_test::GnssLocationMessageT> _o = std::unique_ptr<chre::power_test::GnssLocationMessageT>(new GnssLocationMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GnssLocationMessage::UnPackTo(GnssLocationMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable(); _o->enable = _e; }
  { auto _e = scan_interval_millis(); _o->scan_interval_millis = _e; }
  { auto _e = min_time_to_next_fix_millis(); _o->min_time_to_next_fix_millis = _e; }
}

inline flatbuffers::Offset<GnssLocationMessage> GnssLocationMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GnssLocationMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGnssLocationMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GnssLocationMessage> CreateGnssLocationMessage(flatbuffers::FlatBufferBuilder &_fbb, const GnssLocationMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GnssLocationMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable = _o->enable;
  auto _scan_interval_millis = _o->scan_interval_millis;
  auto _min_time_to_next_fix_millis = _o->min_time_to_next_fix_millis;
  return chre::power_test::CreateGnssLocationMessage(
      _fbb,
      _enable,
      _scan_interval_millis,
      _min_time_to_next_fix_millis);
}

inline CellQueryMessageT *CellQueryMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::power_test::CellQueryMessageT> _o = std::unique_ptr<chre::power_test::CellQueryMessageT>(new CellQueryMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CellQueryMessage::UnPackTo(CellQueryMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable(); _o->enable = _e; }
  { auto _e = query_interval_ns(); _o->query_interval_ns = _e; }
}

inline flatbuffers::Offset<CellQueryMessage> CellQueryMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellQueryMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCellQueryMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CellQueryMessage> CreateCellQueryMessage(flatbuffers::FlatBufferBuilder &_fbb, const CellQueryMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CellQueryMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable = _o->enable;
  auto _query_interval_ns = _o->query_interval_ns;
  return chre::power_test::CreateCellQueryMessage(
      _fbb,
      _enable,
      _query_interval_ns);
}

inline AudioRequestMessageT *AudioRequestMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::power_test::AudioRequestMessageT> _o = std::unique_ptr<chre::power_test::AudioRequestMessageT>(new AudioRequestMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AudioRequestMessage::UnPackTo(AudioRequestMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable(); _o->enable = _e; }
  { auto _e = buffer_duration_ns(); _o->buffer_duration_ns = _e; }
}

inline flatbuffers::Offset<AudioRequestMessage> AudioRequestMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioRequestMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAudioRequestMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AudioRequestMessage> CreateAudioRequestMessage(flatbuffers::FlatBufferBuilder &_fbb, const AudioRequestMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AudioRequestMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable = _o->enable;
  auto _buffer_duration_ns = _o->buffer_duration_ns;
  return chre::power_test::CreateAudioRequestMessage(
      _fbb,
      _enable,
      _buffer_duration_ns);
}

inline SensorRequestMessageT *SensorRequestMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::power_test::SensorRequestMessageT> _o = std::unique_ptr<chre::power_test::SensorRequestMessageT>(new SensorRequestMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SensorRequestMessage::UnPackTo(SensorRequestMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable(); _o->enable = _e; }
  { auto _e = sensor(); _o->sensor = _e; }
  { auto _e = sampling_interval_ns(); _o->sampling_interval_ns = _e; }
  { auto _e = latency_ns(); _o->latency_ns = _e; }
}

inline flatbuffers::Offset<SensorRequestMessage> SensorRequestMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SensorRequestMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSensorRequestMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SensorRequestMessage> CreateSensorRequestMessage(flatbuffers::FlatBufferBuilder &_fbb, const SensorRequestMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SensorRequestMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable = _o->enable;
  auto _sensor = _o->sensor;
  auto _sampling_interval_ns = _o->sampling_interval_ns;
  auto _latency_ns = _o->latency_ns;
  return chre::power_test::CreateSensorRequestMessage(
      _fbb,
      _enable,
      _sensor,
      _sampling_interval_ns,
      _latency_ns);
}

inline BreakItMessageT *BreakItMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::power_test::BreakItMessageT> _o = std::unique_ptr<chre::power_test::BreakItMessageT>(new BreakItMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BreakItMessage::UnPackTo(BreakItMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enable(); _o->enable = _e; }
}

inline flatbuffers::Offset<BreakItMessage> BreakItMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BreakItMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBreakItMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BreakItMessage> CreateBreakItMessage(flatbuffers::FlatBufferBuilder &_fbb, const BreakItMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BreakItMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enable = _o->enable;
  return chre::power_test::CreateBreakItMessage(
      _fbb,
      _enable);
}

inline NanoappResponseMessageT *NanoappResponseMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<chre::power_test::NanoappResponseMessageT> _o = std::unique_ptr<chre::power_test::NanoappResponseMessageT>(new NanoappResponseMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NanoappResponseMessage::UnPackTo(NanoappResponseMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = success(); _o->success = _e; }
}

inline flatbuffers::Offset<NanoappResponseMessage> NanoappResponseMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NanoappResponseMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNanoappResponseMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NanoappResponseMessage> CreateNanoappResponseMessage(flatbuffers::FlatBufferBuilder &_fbb, const NanoappResponseMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NanoappResponseMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _success = _o->success;
  return chre::power_test::CreateNanoappResponseMessage(
      _fbb,
      _success);
}

}  // namespace power_test
}  // namespace chre

#endif  // FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_
