/* Generated by ./gen_bpf_attr_check.sh from bpf_attr.h; do not edit. */
#include "defs.h"
#ifdef HAVE_LINUX_BPF_H
# include <linux/bpf.h>
# include "bpf_attr.h"
# include "static_assert.h"

# define SoM(type_, member_) (sizeof(((type_ *)0)->member_))

# ifdef HAVE_UNION_BPF_ATTR_MAP_TYPE
	static_assert(SoM(struct BPF_MAP_CREATE_struct, map_type) == SoM(union bpf_attr, map_type),
		      "BPF_MAP_CREATE_struct.map_type size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, map_type) == offsetof(union bpf_attr, map_type),
		      "BPF_MAP_CREATE_struct.map_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_TYPE */

# ifdef HAVE_UNION_BPF_ATTR_KEY_SIZE
	static_assert(SoM(struct BPF_MAP_CREATE_struct, key_size) == SoM(union bpf_attr, key_size),
		      "BPF_MAP_CREATE_struct.key_size size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, key_size) == offsetof(union bpf_attr, key_size),
		      "BPF_MAP_CREATE_struct.key_size offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY_SIZE */

# ifdef HAVE_UNION_BPF_ATTR_VALUE_SIZE
	static_assert(SoM(struct BPF_MAP_CREATE_struct, value_size) == SoM(union bpf_attr, value_size),
		      "BPF_MAP_CREATE_struct.value_size size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, value_size) == offsetof(union bpf_attr, value_size),
		      "BPF_MAP_CREATE_struct.value_size offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_VALUE_SIZE */

# ifdef HAVE_UNION_BPF_ATTR_MAX_ENTRIES
	static_assert(SoM(struct BPF_MAP_CREATE_struct, max_entries) == SoM(union bpf_attr, max_entries),
		      "BPF_MAP_CREATE_struct.max_entries size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, max_entries) == offsetof(union bpf_attr, max_entries),
		      "BPF_MAP_CREATE_struct.max_entries offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAX_ENTRIES */

# ifdef HAVE_UNION_BPF_ATTR_MAP_FLAGS
	static_assert(SoM(struct BPF_MAP_CREATE_struct, map_flags) == SoM(union bpf_attr, map_flags),
		      "BPF_MAP_CREATE_struct.map_flags size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, map_flags) == offsetof(union bpf_attr, map_flags),
		      "BPF_MAP_CREATE_struct.map_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FLAGS */

# ifdef HAVE_UNION_BPF_ATTR_INNER_MAP_FD
	static_assert(SoM(struct BPF_MAP_CREATE_struct, inner_map_fd) == SoM(union bpf_attr, inner_map_fd),
		      "BPF_MAP_CREATE_struct.inner_map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, inner_map_fd) == offsetof(union bpf_attr, inner_map_fd),
		      "BPF_MAP_CREATE_struct.inner_map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INNER_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_NUMA_NODE
	static_assert(SoM(struct BPF_MAP_CREATE_struct, numa_node) == SoM(union bpf_attr, numa_node),
		      "BPF_MAP_CREATE_struct.numa_node size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, numa_node) == offsetof(union bpf_attr, numa_node),
		      "BPF_MAP_CREATE_struct.numa_node offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NUMA_NODE */

# ifdef HAVE_UNION_BPF_ATTR_MAP_NAME
	static_assert(SoM(struct BPF_MAP_CREATE_struct, map_name) == SoM(union bpf_attr, map_name),
		      "BPF_MAP_CREATE_struct.map_name size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, map_name) == offsetof(union bpf_attr, map_name),
		      "BPF_MAP_CREATE_struct.map_name offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_NAME */

# ifdef HAVE_UNION_BPF_ATTR_MAP_IFINDEX
	static_assert(SoM(struct BPF_MAP_CREATE_struct, map_ifindex) == SoM(union bpf_attr, map_ifindex),
		      "BPF_MAP_CREATE_struct.map_ifindex size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, map_ifindex) == offsetof(union bpf_attr, map_ifindex),
		      "BPF_MAP_CREATE_struct.map_ifindex offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_IFINDEX */

static_assert(BPF_MAP_CREATE_struct_size == expected_BPF_MAP_CREATE_struct_size,
	      "BPF_MAP_CREATE_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_FD
	static_assert(SoM(struct BPF_MAP_LOOKUP_ELEM_struct, map_fd) == SoM(union bpf_attr, map_fd),
		      "BPF_MAP_LOOKUP_ELEM_struct.map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_LOOKUP_ELEM_struct, map_fd) == offsetof(union bpf_attr, map_fd),
		      "BPF_MAP_LOOKUP_ELEM_struct.map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_KEY
	static_assert(SoM(struct BPF_MAP_LOOKUP_ELEM_struct, key) == SoM(union bpf_attr, key),
		      "BPF_MAP_LOOKUP_ELEM_struct.key size mismatch");
	static_assert(offsetof(struct BPF_MAP_LOOKUP_ELEM_struct, key) == offsetof(union bpf_attr, key),
		      "BPF_MAP_LOOKUP_ELEM_struct.key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY */

# ifdef HAVE_UNION_BPF_ATTR_VALUE
	static_assert(SoM(struct BPF_MAP_LOOKUP_ELEM_struct, value) == SoM(union bpf_attr, value),
		      "BPF_MAP_LOOKUP_ELEM_struct.value size mismatch");
	static_assert(offsetof(struct BPF_MAP_LOOKUP_ELEM_struct, value) == offsetof(union bpf_attr, value),
		      "BPF_MAP_LOOKUP_ELEM_struct.value offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_VALUE */

static_assert(BPF_MAP_LOOKUP_ELEM_struct_size == expected_BPF_MAP_LOOKUP_ELEM_struct_size,
	      "BPF_MAP_LOOKUP_ELEM_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_FD
	static_assert(SoM(struct BPF_MAP_UPDATE_ELEM_struct, map_fd) == SoM(union bpf_attr, map_fd),
		      "BPF_MAP_UPDATE_ELEM_struct.map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_UPDATE_ELEM_struct, map_fd) == offsetof(union bpf_attr, map_fd),
		      "BPF_MAP_UPDATE_ELEM_struct.map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_KEY
	static_assert(SoM(struct BPF_MAP_UPDATE_ELEM_struct, key) == SoM(union bpf_attr, key),
		      "BPF_MAP_UPDATE_ELEM_struct.key size mismatch");
	static_assert(offsetof(struct BPF_MAP_UPDATE_ELEM_struct, key) == offsetof(union bpf_attr, key),
		      "BPF_MAP_UPDATE_ELEM_struct.key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY */

# ifdef HAVE_UNION_BPF_ATTR_VALUE
	static_assert(SoM(struct BPF_MAP_UPDATE_ELEM_struct, value) == SoM(union bpf_attr, value),
		      "BPF_MAP_UPDATE_ELEM_struct.value size mismatch");
	static_assert(offsetof(struct BPF_MAP_UPDATE_ELEM_struct, value) == offsetof(union bpf_attr, value),
		      "BPF_MAP_UPDATE_ELEM_struct.value offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_VALUE */

# ifdef HAVE_UNION_BPF_ATTR_FLAGS
	static_assert(SoM(struct BPF_MAP_UPDATE_ELEM_struct, flags) == SoM(union bpf_attr, flags),
		      "BPF_MAP_UPDATE_ELEM_struct.flags size mismatch");
	static_assert(offsetof(struct BPF_MAP_UPDATE_ELEM_struct, flags) == offsetof(union bpf_attr, flags),
		      "BPF_MAP_UPDATE_ELEM_struct.flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_FLAGS */

static_assert(BPF_MAP_UPDATE_ELEM_struct_size == expected_BPF_MAP_UPDATE_ELEM_struct_size,
	      "BPF_MAP_UPDATE_ELEM_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_FD
	static_assert(SoM(struct BPF_MAP_DELETE_ELEM_struct, map_fd) == SoM(union bpf_attr, map_fd),
		      "BPF_MAP_DELETE_ELEM_struct.map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_DELETE_ELEM_struct, map_fd) == offsetof(union bpf_attr, map_fd),
		      "BPF_MAP_DELETE_ELEM_struct.map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_KEY
	static_assert(SoM(struct BPF_MAP_DELETE_ELEM_struct, key) == SoM(union bpf_attr, key),
		      "BPF_MAP_DELETE_ELEM_struct.key size mismatch");
	static_assert(offsetof(struct BPF_MAP_DELETE_ELEM_struct, key) == offsetof(union bpf_attr, key),
		      "BPF_MAP_DELETE_ELEM_struct.key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY */

static_assert(BPF_MAP_DELETE_ELEM_struct_size == expected_BPF_MAP_DELETE_ELEM_struct_size,
	      "BPF_MAP_DELETE_ELEM_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_FD
	static_assert(SoM(struct BPF_MAP_GET_NEXT_KEY_struct, map_fd) == SoM(union bpf_attr, map_fd),
		      "BPF_MAP_GET_NEXT_KEY_struct.map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_NEXT_KEY_struct, map_fd) == offsetof(union bpf_attr, map_fd),
		      "BPF_MAP_GET_NEXT_KEY_struct.map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_KEY
	static_assert(SoM(struct BPF_MAP_GET_NEXT_KEY_struct, key) == SoM(union bpf_attr, key),
		      "BPF_MAP_GET_NEXT_KEY_struct.key size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_NEXT_KEY_struct, key) == offsetof(union bpf_attr, key),
		      "BPF_MAP_GET_NEXT_KEY_struct.key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY */

# ifdef HAVE_UNION_BPF_ATTR_NEXT_KEY
	static_assert(SoM(struct BPF_MAP_GET_NEXT_KEY_struct, next_key) == SoM(union bpf_attr, next_key),
		      "BPF_MAP_GET_NEXT_KEY_struct.next_key size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_NEXT_KEY_struct, next_key) == offsetof(union bpf_attr, next_key),
		      "BPF_MAP_GET_NEXT_KEY_struct.next_key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NEXT_KEY */

static_assert(BPF_MAP_GET_NEXT_KEY_struct_size == expected_BPF_MAP_GET_NEXT_KEY_struct_size,
	      "BPF_MAP_GET_NEXT_KEY_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_PROG_TYPE
	static_assert(SoM(struct BPF_PROG_LOAD_struct, prog_type) == SoM(union bpf_attr, prog_type),
		      "BPF_PROG_LOAD_struct.prog_type size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, prog_type) == offsetof(union bpf_attr, prog_type),
		      "BPF_PROG_LOAD_struct.prog_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PROG_TYPE */

# ifdef HAVE_UNION_BPF_ATTR_INSN_CNT
	static_assert(SoM(struct BPF_PROG_LOAD_struct, insn_cnt) == SoM(union bpf_attr, insn_cnt),
		      "BPF_PROG_LOAD_struct.insn_cnt size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, insn_cnt) == offsetof(union bpf_attr, insn_cnt),
		      "BPF_PROG_LOAD_struct.insn_cnt offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INSN_CNT */

# ifdef HAVE_UNION_BPF_ATTR_INSNS
	static_assert(SoM(struct BPF_PROG_LOAD_struct, insns) == SoM(union bpf_attr, insns),
		      "BPF_PROG_LOAD_struct.insns size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, insns) == offsetof(union bpf_attr, insns),
		      "BPF_PROG_LOAD_struct.insns offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INSNS */

# ifdef HAVE_UNION_BPF_ATTR_LICENSE
	static_assert(SoM(struct BPF_PROG_LOAD_struct, license) == SoM(union bpf_attr, license),
		      "BPF_PROG_LOAD_struct.license size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, license) == offsetof(union bpf_attr, license),
		      "BPF_PROG_LOAD_struct.license offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_LICENSE */

# ifdef HAVE_UNION_BPF_ATTR_LOG_LEVEL
	static_assert(SoM(struct BPF_PROG_LOAD_struct, log_level) == SoM(union bpf_attr, log_level),
		      "BPF_PROG_LOAD_struct.log_level size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, log_level) == offsetof(union bpf_attr, log_level),
		      "BPF_PROG_LOAD_struct.log_level offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_LOG_LEVEL */

# ifdef HAVE_UNION_BPF_ATTR_LOG_SIZE
	static_assert(SoM(struct BPF_PROG_LOAD_struct, log_size) == SoM(union bpf_attr, log_size),
		      "BPF_PROG_LOAD_struct.log_size size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, log_size) == offsetof(union bpf_attr, log_size),
		      "BPF_PROG_LOAD_struct.log_size offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_LOG_SIZE */

# ifdef HAVE_UNION_BPF_ATTR_LOG_BUF
	static_assert(SoM(struct BPF_PROG_LOAD_struct, log_buf) == SoM(union bpf_attr, log_buf),
		      "BPF_PROG_LOAD_struct.log_buf size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, log_buf) == offsetof(union bpf_attr, log_buf),
		      "BPF_PROG_LOAD_struct.log_buf offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_LOG_BUF */

# ifdef HAVE_UNION_BPF_ATTR_KERN_VERSION
	static_assert(SoM(struct BPF_PROG_LOAD_struct, kern_version) == SoM(union bpf_attr, kern_version),
		      "BPF_PROG_LOAD_struct.kern_version size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, kern_version) == offsetof(union bpf_attr, kern_version),
		      "BPF_PROG_LOAD_struct.kern_version offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KERN_VERSION */

# ifdef HAVE_UNION_BPF_ATTR_PROG_FLAGS
	static_assert(SoM(struct BPF_PROG_LOAD_struct, prog_flags) == SoM(union bpf_attr, prog_flags),
		      "BPF_PROG_LOAD_struct.prog_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, prog_flags) == offsetof(union bpf_attr, prog_flags),
		      "BPF_PROG_LOAD_struct.prog_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PROG_FLAGS */

# ifdef HAVE_UNION_BPF_ATTR_PROG_NAME
	static_assert(SoM(struct BPF_PROG_LOAD_struct, prog_name) == SoM(union bpf_attr, prog_name),
		      "BPF_PROG_LOAD_struct.prog_name size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, prog_name) == offsetof(union bpf_attr, prog_name),
		      "BPF_PROG_LOAD_struct.prog_name offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PROG_NAME */

# ifdef HAVE_UNION_BPF_ATTR_PROG_IFINDEX
	static_assert(SoM(struct BPF_PROG_LOAD_struct, prog_ifindex) == SoM(union bpf_attr, prog_ifindex),
		      "BPF_PROG_LOAD_struct.prog_ifindex size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, prog_ifindex) == offsetof(union bpf_attr, prog_ifindex),
		      "BPF_PROG_LOAD_struct.prog_ifindex offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PROG_IFINDEX */

# ifdef HAVE_UNION_BPF_ATTR_EXPECTED_ATTACH_TYPE
	static_assert(SoM(struct BPF_PROG_LOAD_struct, expected_attach_type) == SoM(union bpf_attr, expected_attach_type),
		      "BPF_PROG_LOAD_struct.expected_attach_type size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, expected_attach_type) == offsetof(union bpf_attr, expected_attach_type),
		      "BPF_PROG_LOAD_struct.expected_attach_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_EXPECTED_ATTACH_TYPE */

static_assert(BPF_PROG_LOAD_struct_size == expected_BPF_PROG_LOAD_struct_size,
	      "BPF_PROG_LOAD_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_PATHNAME
	static_assert(SoM(struct BPF_OBJ_PIN_struct, pathname) == SoM(union bpf_attr, pathname),
		      "BPF_OBJ_PIN_struct.pathname size mismatch");
	static_assert(offsetof(struct BPF_OBJ_PIN_struct, pathname) == offsetof(union bpf_attr, pathname),
		      "BPF_OBJ_PIN_struct.pathname offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PATHNAME */

# ifdef HAVE_UNION_BPF_ATTR_BPF_FD
	static_assert(SoM(struct BPF_OBJ_PIN_struct, bpf_fd) == SoM(union bpf_attr, bpf_fd),
		      "BPF_OBJ_PIN_struct.bpf_fd size mismatch");
	static_assert(offsetof(struct BPF_OBJ_PIN_struct, bpf_fd) == offsetof(union bpf_attr, bpf_fd),
		      "BPF_OBJ_PIN_struct.bpf_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_BPF_FD */

# ifdef HAVE_UNION_BPF_ATTR_FILE_FLAGS
	static_assert(SoM(struct BPF_OBJ_PIN_struct, file_flags) == SoM(union bpf_attr, file_flags),
		      "BPF_OBJ_PIN_struct.file_flags size mismatch");
	static_assert(offsetof(struct BPF_OBJ_PIN_struct, file_flags) == offsetof(union bpf_attr, file_flags),
		      "BPF_OBJ_PIN_struct.file_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_FILE_FLAGS */

static_assert(BPF_OBJ_PIN_struct_size == expected_BPF_OBJ_PIN_struct_size,
	      "BPF_OBJ_PIN_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_TARGET_FD
	static_assert(SoM(struct BPF_PROG_ATTACH_struct, target_fd) == SoM(union bpf_attr, target_fd),
		      "BPF_PROG_ATTACH_struct.target_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_ATTACH_struct, target_fd) == offsetof(union bpf_attr, target_fd),
		      "BPF_PROG_ATTACH_struct.target_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TARGET_FD */

# ifdef HAVE_UNION_BPF_ATTR_ATTACH_BPF_FD
	static_assert(SoM(struct BPF_PROG_ATTACH_struct, attach_bpf_fd) == SoM(union bpf_attr, attach_bpf_fd),
		      "BPF_PROG_ATTACH_struct.attach_bpf_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_ATTACH_struct, attach_bpf_fd) == offsetof(union bpf_attr, attach_bpf_fd),
		      "BPF_PROG_ATTACH_struct.attach_bpf_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_ATTACH_BPF_FD */

# ifdef HAVE_UNION_BPF_ATTR_ATTACH_TYPE
	static_assert(SoM(struct BPF_PROG_ATTACH_struct, attach_type) == SoM(union bpf_attr, attach_type),
		      "BPF_PROG_ATTACH_struct.attach_type size mismatch");
	static_assert(offsetof(struct BPF_PROG_ATTACH_struct, attach_type) == offsetof(union bpf_attr, attach_type),
		      "BPF_PROG_ATTACH_struct.attach_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_ATTACH_TYPE */

# ifdef HAVE_UNION_BPF_ATTR_ATTACH_FLAGS
	static_assert(SoM(struct BPF_PROG_ATTACH_struct, attach_flags) == SoM(union bpf_attr, attach_flags),
		      "BPF_PROG_ATTACH_struct.attach_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_ATTACH_struct, attach_flags) == offsetof(union bpf_attr, attach_flags),
		      "BPF_PROG_ATTACH_struct.attach_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_ATTACH_FLAGS */

static_assert(BPF_PROG_ATTACH_struct_size == expected_BPF_PROG_ATTACH_struct_size,
	      "BPF_PROG_ATTACH_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_TARGET_FD
	static_assert(SoM(struct BPF_PROG_DETACH_struct, target_fd) == SoM(union bpf_attr, target_fd),
		      "BPF_PROG_DETACH_struct.target_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_DETACH_struct, target_fd) == offsetof(union bpf_attr, target_fd),
		      "BPF_PROG_DETACH_struct.target_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TARGET_FD */

# ifdef HAVE_UNION_BPF_ATTR_DUMMY
	static_assert(SoM(struct BPF_PROG_DETACH_struct, dummy) == SoM(union bpf_attr, dummy),
		      "BPF_PROG_DETACH_struct.dummy size mismatch");
	static_assert(offsetof(struct BPF_PROG_DETACH_struct, dummy) == offsetof(union bpf_attr, dummy),
		      "BPF_PROG_DETACH_struct.dummy offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_DUMMY */

# ifdef HAVE_UNION_BPF_ATTR_ATTACH_TYPE
	static_assert(SoM(struct BPF_PROG_DETACH_struct, attach_type) == SoM(union bpf_attr, attach_type),
		      "BPF_PROG_DETACH_struct.attach_type size mismatch");
	static_assert(offsetof(struct BPF_PROG_DETACH_struct, attach_type) == offsetof(union bpf_attr, attach_type),
		      "BPF_PROG_DETACH_struct.attach_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_ATTACH_TYPE */

static_assert(BPF_PROG_DETACH_struct_size == expected_BPF_PROG_DETACH_struct_size,
	      "BPF_PROG_DETACH_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_TEST_PROG_FD
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, prog_fd) == SoM(union bpf_attr, test.prog_fd),
		      "BPF_PROG_TEST_RUN_struct.prog_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, prog_fd) == offsetof(union bpf_attr, test.prog_fd),
		      "BPF_PROG_TEST_RUN_struct.prog_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_PROG_FD */

# ifdef HAVE_UNION_BPF_ATTR_TEST_RETVAL
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, retval) == SoM(union bpf_attr, test.retval),
		      "BPF_PROG_TEST_RUN_struct.retval size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, retval) == offsetof(union bpf_attr, test.retval),
		      "BPF_PROG_TEST_RUN_struct.retval offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_RETVAL */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DATA_SIZE_IN
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, data_size_in) == SoM(union bpf_attr, test.data_size_in),
		      "BPF_PROG_TEST_RUN_struct.data_size_in size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, data_size_in) == offsetof(union bpf_attr, test.data_size_in),
		      "BPF_PROG_TEST_RUN_struct.data_size_in offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DATA_SIZE_IN */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DATA_SIZE_OUT
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, data_size_out) == SoM(union bpf_attr, test.data_size_out),
		      "BPF_PROG_TEST_RUN_struct.data_size_out size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, data_size_out) == offsetof(union bpf_attr, test.data_size_out),
		      "BPF_PROG_TEST_RUN_struct.data_size_out offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DATA_SIZE_OUT */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DATA_IN
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, data_in) == SoM(union bpf_attr, test.data_in),
		      "BPF_PROG_TEST_RUN_struct.data_in size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, data_in) == offsetof(union bpf_attr, test.data_in),
		      "BPF_PROG_TEST_RUN_struct.data_in offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DATA_IN */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DATA_OUT
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, data_out) == SoM(union bpf_attr, test.data_out),
		      "BPF_PROG_TEST_RUN_struct.data_out size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, data_out) == offsetof(union bpf_attr, test.data_out),
		      "BPF_PROG_TEST_RUN_struct.data_out offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DATA_OUT */

# ifdef HAVE_UNION_BPF_ATTR_TEST_REPEAT
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, repeat) == SoM(union bpf_attr, test.repeat),
		      "BPF_PROG_TEST_RUN_struct.repeat size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, repeat) == offsetof(union bpf_attr, test.repeat),
		      "BPF_PROG_TEST_RUN_struct.repeat offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_REPEAT */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DURATION
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, duration) == SoM(union bpf_attr, test.duration),
		      "BPF_PROG_TEST_RUN_struct.duration size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, duration) == offsetof(union bpf_attr, test.duration),
		      "BPF_PROG_TEST_RUN_struct.duration offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DURATION */

static_assert(BPF_PROG_TEST_RUN_struct_size == expected_BPF_PROG_TEST_RUN_struct_size,
	      "BPF_PROG_TEST_RUN_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_START_ID
	static_assert(SoM(struct BPF_PROG_GET_NEXT_ID_struct, start_id) == SoM(union bpf_attr, start_id),
		      "BPF_PROG_GET_NEXT_ID_struct.start_id size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_NEXT_ID_struct, start_id) == offsetof(union bpf_attr, start_id),
		      "BPF_PROG_GET_NEXT_ID_struct.start_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_START_ID */

# ifdef HAVE_UNION_BPF_ATTR_NEXT_ID
	static_assert(SoM(struct BPF_PROG_GET_NEXT_ID_struct, next_id) == SoM(union bpf_attr, next_id),
		      "BPF_PROG_GET_NEXT_ID_struct.next_id size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_NEXT_ID_struct, next_id) == offsetof(union bpf_attr, next_id),
		      "BPF_PROG_GET_NEXT_ID_struct.next_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NEXT_ID */

# ifdef HAVE_UNION_BPF_ATTR_OPEN_FLAGS
	static_assert(SoM(struct BPF_PROG_GET_NEXT_ID_struct, open_flags) == SoM(union bpf_attr, open_flags),
		      "BPF_PROG_GET_NEXT_ID_struct.open_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_NEXT_ID_struct, open_flags) == offsetof(union bpf_attr, open_flags),
		      "BPF_PROG_GET_NEXT_ID_struct.open_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_OPEN_FLAGS */

static_assert(BPF_PROG_GET_NEXT_ID_struct_size == expected_BPF_PROG_GET_NEXT_ID_struct_size,
	      "BPF_PROG_GET_NEXT_ID_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_PROG_ID
	static_assert(SoM(struct BPF_PROG_GET_FD_BY_ID_struct, prog_id) == SoM(union bpf_attr, prog_id),
		      "BPF_PROG_GET_FD_BY_ID_struct.prog_id size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_FD_BY_ID_struct, prog_id) == offsetof(union bpf_attr, prog_id),
		      "BPF_PROG_GET_FD_BY_ID_struct.prog_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PROG_ID */

# ifdef HAVE_UNION_BPF_ATTR_NEXT_ID
	static_assert(SoM(struct BPF_PROG_GET_FD_BY_ID_struct, next_id) == SoM(union bpf_attr, next_id),
		      "BPF_PROG_GET_FD_BY_ID_struct.next_id size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_FD_BY_ID_struct, next_id) == offsetof(union bpf_attr, next_id),
		      "BPF_PROG_GET_FD_BY_ID_struct.next_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NEXT_ID */

# ifdef HAVE_UNION_BPF_ATTR_OPEN_FLAGS
	static_assert(SoM(struct BPF_PROG_GET_FD_BY_ID_struct, open_flags) == SoM(union bpf_attr, open_flags),
		      "BPF_PROG_GET_FD_BY_ID_struct.open_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_FD_BY_ID_struct, open_flags) == offsetof(union bpf_attr, open_flags),
		      "BPF_PROG_GET_FD_BY_ID_struct.open_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_OPEN_FLAGS */

static_assert(BPF_PROG_GET_FD_BY_ID_struct_size == expected_BPF_PROG_GET_FD_BY_ID_struct_size,
	      "BPF_PROG_GET_FD_BY_ID_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_ID
	static_assert(SoM(struct BPF_MAP_GET_FD_BY_ID_struct, map_id) == SoM(union bpf_attr, map_id),
		      "BPF_MAP_GET_FD_BY_ID_struct.map_id size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_FD_BY_ID_struct, map_id) == offsetof(union bpf_attr, map_id),
		      "BPF_MAP_GET_FD_BY_ID_struct.map_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_ID */

# ifdef HAVE_UNION_BPF_ATTR_NEXT_ID
	static_assert(SoM(struct BPF_MAP_GET_FD_BY_ID_struct, next_id) == SoM(union bpf_attr, next_id),
		      "BPF_MAP_GET_FD_BY_ID_struct.next_id size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_FD_BY_ID_struct, next_id) == offsetof(union bpf_attr, next_id),
		      "BPF_MAP_GET_FD_BY_ID_struct.next_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NEXT_ID */

# ifdef HAVE_UNION_BPF_ATTR_OPEN_FLAGS
	static_assert(SoM(struct BPF_MAP_GET_FD_BY_ID_struct, open_flags) == SoM(union bpf_attr, open_flags),
		      "BPF_MAP_GET_FD_BY_ID_struct.open_flags size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_FD_BY_ID_struct, open_flags) == offsetof(union bpf_attr, open_flags),
		      "BPF_MAP_GET_FD_BY_ID_struct.open_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_OPEN_FLAGS */

static_assert(BPF_MAP_GET_FD_BY_ID_struct_size == expected_BPF_MAP_GET_FD_BY_ID_struct_size,
	      "BPF_MAP_GET_FD_BY_ID_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_INFO_BPF_FD
	static_assert(SoM(struct BPF_OBJ_GET_INFO_BY_FD_struct, bpf_fd) == SoM(union bpf_attr, info.bpf_fd),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.bpf_fd size mismatch");
	static_assert(offsetof(struct BPF_OBJ_GET_INFO_BY_FD_struct, bpf_fd) == offsetof(union bpf_attr, info.bpf_fd),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.bpf_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INFO_BPF_FD */

# ifdef HAVE_UNION_BPF_ATTR_INFO_INFO_LEN
	static_assert(SoM(struct BPF_OBJ_GET_INFO_BY_FD_struct, info_len) == SoM(union bpf_attr, info.info_len),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.info_len size mismatch");
	static_assert(offsetof(struct BPF_OBJ_GET_INFO_BY_FD_struct, info_len) == offsetof(union bpf_attr, info.info_len),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.info_len offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INFO_INFO_LEN */

# ifdef HAVE_UNION_BPF_ATTR_INFO_INFO
	static_assert(SoM(struct BPF_OBJ_GET_INFO_BY_FD_struct, info) == SoM(union bpf_attr, info.info),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.info size mismatch");
	static_assert(offsetof(struct BPF_OBJ_GET_INFO_BY_FD_struct, info) == offsetof(union bpf_attr, info.info),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.info offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INFO_INFO */

static_assert(BPF_OBJ_GET_INFO_BY_FD_struct_size == expected_BPF_OBJ_GET_INFO_BY_FD_struct_size,
	      "BPF_OBJ_GET_INFO_BY_FD_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_QUERY_TARGET_FD
	static_assert(SoM(struct BPF_PROG_QUERY_struct, target_fd) == SoM(union bpf_attr, query.target_fd),
		      "BPF_PROG_QUERY_struct.target_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_QUERY_struct, target_fd) == offsetof(union bpf_attr, query.target_fd),
		      "BPF_PROG_QUERY_struct.target_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_QUERY_TARGET_FD */

# ifdef HAVE_UNION_BPF_ATTR_QUERY_ATTACH_TYPE
	static_assert(SoM(struct BPF_PROG_QUERY_struct, attach_type) == SoM(union bpf_attr, query.attach_type),
		      "BPF_PROG_QUERY_struct.attach_type size mismatch");
	static_assert(offsetof(struct BPF_PROG_QUERY_struct, attach_type) == offsetof(union bpf_attr, query.attach_type),
		      "BPF_PROG_QUERY_struct.attach_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_QUERY_ATTACH_TYPE */

# ifdef HAVE_UNION_BPF_ATTR_QUERY_QUERY_FLAGS
	static_assert(SoM(struct BPF_PROG_QUERY_struct, query_flags) == SoM(union bpf_attr, query.query_flags),
		      "BPF_PROG_QUERY_struct.query_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_QUERY_struct, query_flags) == offsetof(union bpf_attr, query.query_flags),
		      "BPF_PROG_QUERY_struct.query_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_QUERY_QUERY_FLAGS */

# ifdef HAVE_UNION_BPF_ATTR_QUERY_ATTACH_FLAGS
	static_assert(SoM(struct BPF_PROG_QUERY_struct, attach_flags) == SoM(union bpf_attr, query.attach_flags),
		      "BPF_PROG_QUERY_struct.attach_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_QUERY_struct, attach_flags) == offsetof(union bpf_attr, query.attach_flags),
		      "BPF_PROG_QUERY_struct.attach_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_QUERY_ATTACH_FLAGS */

# ifdef HAVE_UNION_BPF_ATTR_QUERY_PROG_IDS
	static_assert(SoM(struct BPF_PROG_QUERY_struct, prog_ids) == SoM(union bpf_attr, query.prog_ids),
		      "BPF_PROG_QUERY_struct.prog_ids size mismatch");
	static_assert(offsetof(struct BPF_PROG_QUERY_struct, prog_ids) == offsetof(union bpf_attr, query.prog_ids),
		      "BPF_PROG_QUERY_struct.prog_ids offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_QUERY_PROG_IDS */

# ifdef HAVE_UNION_BPF_ATTR_QUERY_PROG_CNT
	static_assert(SoM(struct BPF_PROG_QUERY_struct, prog_cnt) == SoM(union bpf_attr, query.prog_cnt),
		      "BPF_PROG_QUERY_struct.prog_cnt size mismatch");
	static_assert(offsetof(struct BPF_PROG_QUERY_struct, prog_cnt) == offsetof(union bpf_attr, query.prog_cnt),
		      "BPF_PROG_QUERY_struct.prog_cnt offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_QUERY_PROG_CNT */

static_assert(BPF_PROG_QUERY_struct_size == expected_BPF_PROG_QUERY_struct_size,
	      "BPF_PROG_QUERY_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_RAW_TRACEPOINT_NAME
	static_assert(SoM(struct BPF_RAW_TRACEPOINT_OPEN_struct, name) == SoM(union bpf_attr, raw_tracepoint.name),
		      "BPF_RAW_TRACEPOINT_OPEN_struct.name size mismatch");
	static_assert(offsetof(struct BPF_RAW_TRACEPOINT_OPEN_struct, name) == offsetof(union bpf_attr, raw_tracepoint.name),
		      "BPF_RAW_TRACEPOINT_OPEN_struct.name offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_RAW_TRACEPOINT_NAME */

# ifdef HAVE_UNION_BPF_ATTR_RAW_TRACEPOINT_PROG_FD
	static_assert(SoM(struct BPF_RAW_TRACEPOINT_OPEN_struct, prog_fd) == SoM(union bpf_attr, raw_tracepoint.prog_fd),
		      "BPF_RAW_TRACEPOINT_OPEN_struct.prog_fd size mismatch");
	static_assert(offsetof(struct BPF_RAW_TRACEPOINT_OPEN_struct, prog_fd) == offsetof(union bpf_attr, raw_tracepoint.prog_fd),
		      "BPF_RAW_TRACEPOINT_OPEN_struct.prog_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_RAW_TRACEPOINT_PROG_FD */

static_assert(BPF_RAW_TRACEPOINT_OPEN_struct_size == expected_BPF_RAW_TRACEPOINT_OPEN_struct_size,
	      "BPF_RAW_TRACEPOINT_OPEN_struct_size mismatch");

# ifdef HAVE_STRUCT_BPF_MAP_INFO_TYPE
	static_assert(SoM(struct bpf_map_info_struct, type) == SoM(struct bpf_map_info, type),
		      "bpf_map_info_struct.type size mismatch");
	static_assert(offsetof(struct bpf_map_info_struct, type) == offsetof(struct bpf_map_info, type),
		      "bpf_map_info_struct.type offset mismatch");
# endif /* HAVE_STRUCT_BPF_MAP_INFO_TYPE */

# ifdef HAVE_STRUCT_BPF_MAP_INFO_ID
	static_assert(SoM(struct bpf_map_info_struct, id) == SoM(struct bpf_map_info, id),
		      "bpf_map_info_struct.id size mismatch");
	static_assert(offsetof(struct bpf_map_info_struct, id) == offsetof(struct bpf_map_info, id),
		      "bpf_map_info_struct.id offset mismatch");
# endif /* HAVE_STRUCT_BPF_MAP_INFO_ID */

# ifdef HAVE_STRUCT_BPF_MAP_INFO_KEY_SIZE
	static_assert(SoM(struct bpf_map_info_struct, key_size) == SoM(struct bpf_map_info, key_size),
		      "bpf_map_info_struct.key_size size mismatch");
	static_assert(offsetof(struct bpf_map_info_struct, key_size) == offsetof(struct bpf_map_info, key_size),
		      "bpf_map_info_struct.key_size offset mismatch");
# endif /* HAVE_STRUCT_BPF_MAP_INFO_KEY_SIZE */

# ifdef HAVE_STRUCT_BPF_MAP_INFO_VALUE_SIZE
	static_assert(SoM(struct bpf_map_info_struct, value_size) == SoM(struct bpf_map_info, value_size),
		      "bpf_map_info_struct.value_size size mismatch");
	static_assert(offsetof(struct bpf_map_info_struct, value_size) == offsetof(struct bpf_map_info, value_size),
		      "bpf_map_info_struct.value_size offset mismatch");
# endif /* HAVE_STRUCT_BPF_MAP_INFO_VALUE_SIZE */

# ifdef HAVE_STRUCT_BPF_MAP_INFO_MAX_ENTRIES
	static_assert(SoM(struct bpf_map_info_struct, max_entries) == SoM(struct bpf_map_info, max_entries),
		      "bpf_map_info_struct.max_entries size mismatch");
	static_assert(offsetof(struct bpf_map_info_struct, max_entries) == offsetof(struct bpf_map_info, max_entries),
		      "bpf_map_info_struct.max_entries offset mismatch");
# endif /* HAVE_STRUCT_BPF_MAP_INFO_MAX_ENTRIES */

# ifdef HAVE_STRUCT_BPF_MAP_INFO_MAP_FLAGS
	static_assert(SoM(struct bpf_map_info_struct, map_flags) == SoM(struct bpf_map_info, map_flags),
		      "bpf_map_info_struct.map_flags size mismatch");
	static_assert(offsetof(struct bpf_map_info_struct, map_flags) == offsetof(struct bpf_map_info, map_flags),
		      "bpf_map_info_struct.map_flags offset mismatch");
# endif /* HAVE_STRUCT_BPF_MAP_INFO_MAP_FLAGS */

# ifdef HAVE_STRUCT_BPF_MAP_INFO_NAME
	static_assert(SoM(struct bpf_map_info_struct, name) == SoM(struct bpf_map_info, name),
		      "bpf_map_info_struct.name size mismatch");
	static_assert(offsetof(struct bpf_map_info_struct, name) == offsetof(struct bpf_map_info, name),
		      "bpf_map_info_struct.name offset mismatch");
# endif /* HAVE_STRUCT_BPF_MAP_INFO_NAME */

# ifdef HAVE_STRUCT_BPF_MAP_INFO_IFINDEX
	static_assert(SoM(struct bpf_map_info_struct, ifindex) == SoM(struct bpf_map_info, ifindex),
		      "bpf_map_info_struct.ifindex size mismatch");
	static_assert(offsetof(struct bpf_map_info_struct, ifindex) == offsetof(struct bpf_map_info, ifindex),
		      "bpf_map_info_struct.ifindex offset mismatch");
# endif /* HAVE_STRUCT_BPF_MAP_INFO_IFINDEX */

static_assert(bpf_map_info_struct_size == expected_bpf_map_info_struct_size,
	      "bpf_map_info_struct_size mismatch");

# ifdef HAVE_STRUCT_BPF_PROG_INFO_TYPE
	static_assert(SoM(struct bpf_prog_info_struct, type) == SoM(struct bpf_prog_info, type),
		      "bpf_prog_info_struct.type size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, type) == offsetof(struct bpf_prog_info, type),
		      "bpf_prog_info_struct.type offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_TYPE */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_ID
	static_assert(SoM(struct bpf_prog_info_struct, id) == SoM(struct bpf_prog_info, id),
		      "bpf_prog_info_struct.id size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, id) == offsetof(struct bpf_prog_info, id),
		      "bpf_prog_info_struct.id offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_ID */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_TAG
	static_assert(SoM(struct bpf_prog_info_struct, tag) == SoM(struct bpf_prog_info, tag),
		      "bpf_prog_info_struct.tag size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, tag) == offsetof(struct bpf_prog_info, tag),
		      "bpf_prog_info_struct.tag offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_TAG */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_JITED_PROG_LEN
	static_assert(SoM(struct bpf_prog_info_struct, jited_prog_len) == SoM(struct bpf_prog_info, jited_prog_len),
		      "bpf_prog_info_struct.jited_prog_len size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, jited_prog_len) == offsetof(struct bpf_prog_info, jited_prog_len),
		      "bpf_prog_info_struct.jited_prog_len offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_JITED_PROG_LEN */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_XLATED_PROG_LEN
	static_assert(SoM(struct bpf_prog_info_struct, xlated_prog_len) == SoM(struct bpf_prog_info, xlated_prog_len),
		      "bpf_prog_info_struct.xlated_prog_len size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, xlated_prog_len) == offsetof(struct bpf_prog_info, xlated_prog_len),
		      "bpf_prog_info_struct.xlated_prog_len offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_XLATED_PROG_LEN */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_JITED_PROG_INSNS
	static_assert(SoM(struct bpf_prog_info_struct, jited_prog_insns) == SoM(struct bpf_prog_info, jited_prog_insns),
		      "bpf_prog_info_struct.jited_prog_insns size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, jited_prog_insns) == offsetof(struct bpf_prog_info, jited_prog_insns),
		      "bpf_prog_info_struct.jited_prog_insns offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_JITED_PROG_INSNS */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_XLATED_PROG_INSNS
	static_assert(SoM(struct bpf_prog_info_struct, xlated_prog_insns) == SoM(struct bpf_prog_info, xlated_prog_insns),
		      "bpf_prog_info_struct.xlated_prog_insns size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, xlated_prog_insns) == offsetof(struct bpf_prog_info, xlated_prog_insns),
		      "bpf_prog_info_struct.xlated_prog_insns offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_XLATED_PROG_INSNS */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_LOAD_TIME
	static_assert(SoM(struct bpf_prog_info_struct, load_time) == SoM(struct bpf_prog_info, load_time),
		      "bpf_prog_info_struct.load_time size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, load_time) == offsetof(struct bpf_prog_info, load_time),
		      "bpf_prog_info_struct.load_time offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_LOAD_TIME */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_CREATED_BY_UID
	static_assert(SoM(struct bpf_prog_info_struct, created_by_uid) == SoM(struct bpf_prog_info, created_by_uid),
		      "bpf_prog_info_struct.created_by_uid size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, created_by_uid) == offsetof(struct bpf_prog_info, created_by_uid),
		      "bpf_prog_info_struct.created_by_uid offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_CREATED_BY_UID */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_NR_MAP_IDS
	static_assert(SoM(struct bpf_prog_info_struct, nr_map_ids) == SoM(struct bpf_prog_info, nr_map_ids),
		      "bpf_prog_info_struct.nr_map_ids size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, nr_map_ids) == offsetof(struct bpf_prog_info, nr_map_ids),
		      "bpf_prog_info_struct.nr_map_ids offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_NR_MAP_IDS */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_MAP_IDS
	static_assert(SoM(struct bpf_prog_info_struct, map_ids) == SoM(struct bpf_prog_info, map_ids),
		      "bpf_prog_info_struct.map_ids size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, map_ids) == offsetof(struct bpf_prog_info, map_ids),
		      "bpf_prog_info_struct.map_ids offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_MAP_IDS */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_NAME
	static_assert(SoM(struct bpf_prog_info_struct, name) == SoM(struct bpf_prog_info, name),
		      "bpf_prog_info_struct.name size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, name) == offsetof(struct bpf_prog_info, name),
		      "bpf_prog_info_struct.name offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_NAME */

# ifdef HAVE_STRUCT_BPF_PROG_INFO_IFINDEX
	static_assert(SoM(struct bpf_prog_info_struct, ifindex) == SoM(struct bpf_prog_info, ifindex),
		      "bpf_prog_info_struct.ifindex size mismatch");
	static_assert(offsetof(struct bpf_prog_info_struct, ifindex) == offsetof(struct bpf_prog_info, ifindex),
		      "bpf_prog_info_struct.ifindex offset mismatch");
# endif /* HAVE_STRUCT_BPF_PROG_INFO_IFINDEX */

static_assert(bpf_prog_info_struct_size == expected_bpf_prog_info_struct_size,
	      "bpf_prog_info_struct_size mismatch");

#endif /* HAVE_LINUX_BPF_H */
