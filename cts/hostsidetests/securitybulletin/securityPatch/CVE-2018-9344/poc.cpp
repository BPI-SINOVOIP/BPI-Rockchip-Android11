/**
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <android/hardware/cas/1.0/IMediaCasService.h>
#include <android/hardware/cas/native/1.0/IDescrambler.h>
#include <binder/ProcessState.h>

using namespace android;
using hardware::hidl_vec;
using hardware::Return;
using namespace hardware::cas::V1_0;
using android::hardware::Void;
using android::hardware::cas::native::V1_0::IDescrambler;

class MyMediaCasListener : public ICasListener {
 public:
  virtual Return<void> onEvent(int32_t, int32_t, const hidl_vec<uint8_t>&) override {
    return Void();
  }
};

static const int32_t sClearKeySystemId = 0xF6D8;
static sp<IDescramblerBase> descramblerBase;

static void* thread1(void*) {
  Return<Status> returnStatus(Status::OK);
  std::vector<uint8_t> sessionId;
  sessionId.push_back(1);

  returnStatus = descramblerBase->setMediaCasSession(sessionId);

  return NULL;
}

int main() {
  sp<ICas> cas;
  Status status;
  sp<IDescrambler> descrambler;
  Return<Status> returnStatus(Status::OK);
  Return<sp<IDescramblerBase>> returnDescrambler(NULL);
  std::vector<uint8_t> sessionId;

  android::ProcessState::self()->startThreadPool();

  sp<IMediaCasService> casService = IMediaCasService::getService("default");
  if (casService == NULL) {
    return EXIT_FAILURE;
  }

  sp<ICasListener> listener;
  cas = casService->createPlugin(sClearKeySystemId, listener);
  if (cas == NULL) {
    return EXIT_FAILURE;
  }

  auto returnVoid = cas->openSession(
      [&status, &sessionId](Status _status,
                            const hidl_vec<uint8_t>& _sessionId) {
        status = _status;
        sessionId = _sessionId;
      });
  if (!returnVoid.isOk() || status != Status::OK) {
    return EXIT_FAILURE;
  }

  returnDescrambler = casService->createDescrambler(sClearKeySystemId);
  if (!returnDescrambler.isOk()) {
    return EXIT_FAILURE;
  }

  descramblerBase = (sp<IDescramblerBase>)returnDescrambler;

  if (descramblerBase == NULL) {
    return EXIT_FAILURE;
  }

  returnStatus = descramblerBase->setMediaCasSession(sessionId);

  if (!returnStatus.isOk() || (Status)returnStatus != Status::OK) {
    return EXIT_FAILURE;
  }

  descrambler = IDescrambler::castFrom(descramblerBase);

  if (descrambler == NULL) {
    return EXIT_FAILURE;
  }

  pthread_t pt;
  pthread_create(&pt, NULL, thread1, NULL);

  descramblerBase->release();

  return EXIT_FAILURE;
}
