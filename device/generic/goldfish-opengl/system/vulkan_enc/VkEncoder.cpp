// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkEncoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkEncoder.h"


#include "IOStream.h"
#include "Resources.h"
#include "ResourceTracker.h"
#include "Validation.h"
#include "VulkanStreamGuest.h"

#include "android/base/AlignedBuf.h"
#include "android/base/Pool.h"
#include "android/base/synchronization/AndroidLock.h"

#include <cutils/properties.h>

#include "goldfish_vk_marshaling_guest.h"
#include "goldfish_vk_deepcopy_guest.h"
#include "goldfish_vk_handlemap_guest.h"
#include "goldfish_vk_private_defs.h"
#include "goldfish_vk_transform_guest.h"

#include <unordered_map>



namespace goldfish_vk {



using namespace goldfish_vk;

using android::aligned_buf_alloc;
using android::aligned_buf_free;
using android::base::guest::AutoLock;
using android::base::guest::Lock;
using android::base::Pool;

class VkEncoder::Impl {
public:
    Impl(IOStream* stream) : m_stream(stream), m_logEncodes(false) {
        const char* emuVkLogEncodesPropName = "qemu.vk.log";
        char encodeProp[PROPERTY_VALUE_MAX];
        if (property_get(emuVkLogEncodesPropName, encodeProp, nullptr) > 0) {
            m_logEncodes = atoi(encodeProp) > 0;
        }
    }

    ~Impl() {
        for (auto it : mCleanupCallbacks) {
            fprintf(stderr, "%s: run cleanup callback for %p\n", __func__, it.first);
            it.second();
        }
    }

    VulkanCountingStream* countingStream() { return &m_countingStream; }
    VulkanStreamGuest* stream() { return &m_stream; }
    Pool* pool() { return &m_pool; }
    ResourceTracker* resources() { return ResourceTracker::get(); }
    Validation* validation() { return &m_validation; }

    void log(const char* text) {
        if (!m_logEncodes) return;
        ALOGD("encoder log: %s", text);
    }

    void flush() {
        AutoLock encoderLock(lock);
        m_stream.flush();
    }

    // Assume the lock for the current encoder is held.
    void registerCleanupCallback(void* handle, VkEncoder::CleanupCallback cb) {
        if (mCleanupCallbacks.end() == mCleanupCallbacks.find(handle)) {
            mCleanupCallbacks[handle] = cb;
        } else {
            return;
        }
    }

    void unregisterCleanupCallback(void* handle) {
        mCleanupCallbacks.erase(handle);
    }

    Lock lock;

private:
    VulkanCountingStream m_countingStream;
    VulkanStreamGuest m_stream;
    Pool m_pool { 8, 4096, 64 };

    Validation m_validation;
    bool m_logEncodes;

    std::unordered_map<void*, VkEncoder::CleanupCallback> mCleanupCallbacks;
};

VkEncoder::VkEncoder(IOStream *stream) :
    mImpl(new VkEncoder::Impl(stream)) { }

void VkEncoder::flush() {
    mImpl->flush();
}

void VkEncoder::registerCleanupCallback(void* handle, VkEncoder::CleanupCallback cb) {
    mImpl->registerCleanupCallback(handle, cb);
}

void VkEncoder::unregisterCleanupCallback(void* handle) {
    mImpl->unregisterCleanupCallback(handle);
}

#define VALIDATE_RET(retType, success, validate) \
    retType goldfish_vk_validateResult = validate; \
    if (goldfish_vk_validateResult != success) return goldfish_vk_validateResult; \

#define VALIDATE_VOID(validate) \
    VkResult goldfish_vk_validateResult = validate; \
    if (goldfish_vk_validateResult != VK_SUCCESS) return; \

#ifdef VK_VERSION_1_0
VkResult VkEncoder::vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* pInstance)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateInstance encode");
    mImpl->log("start vkCreateInstance");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstanceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkInstanceCreateInfo*)pool->alloc(sizeof(const VkInstanceCreateInfo));
        deepcopy_VkInstanceCreateInfo(pool, pCreateInfo, (VkInstanceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkInstanceCreateInfo(mImpl->resources(), (VkInstanceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        marshal_VkInstanceCreateInfo(countingStream, (VkInstanceCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_0);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(pInstance, &cgen_var_1, 1);
        countingStream->write((uint64_t*)&cgen_var_1, 8);
    }
    uint32_t packetSize_vkCreateInstance = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateInstance = OP_vkCreateInstance;
    stream->write(&opcode_vkCreateInstance, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateInstance, sizeof(uint32_t));
    marshal_VkInstanceCreateInfo(stream, (VkInstanceCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_2);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->handleMapping()->mapHandles_VkInstance_u64(pInstance, &cgen_var_3, 1);
    stream->write((uint64_t*)&cgen_var_3, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateInstance readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_4;
    stream->read((uint64_t*)&cgen_var_4, 8);
    stream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_4, (VkInstance*)pInstance, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateInstance returnUnmarshal");
    VkResult vkCreateInstance_VkResult_return = (VkResult)0;
    stream->read(&vkCreateInstance_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    encoderLock.unlock();
    mImpl->resources()->on_vkCreateInstance(this, vkCreateInstance_VkResult_return, pCreateInfo, pAllocator, pInstance);
    encoderLock.lock();
    mImpl->log("finish vkCreateInstance");;
    return vkCreateInstance_VkResult_return;
}

void VkEncoder::vkDestroyInstance(
    VkInstance instance,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyInstance encode");
    mImpl->log("start vkDestroyInstance");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_5;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_5, 1);
        countingStream->write((uint64_t*)&cgen_var_5, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_6 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_6);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyInstance = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyInstance = OP_vkDestroyInstance;
    stream->write(&opcode_vkDestroyInstance, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyInstance, sizeof(uint32_t));
    uint64_t cgen_var_7;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_7, 1);
    stream->write((uint64_t*)&cgen_var_7, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_8 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_8);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyInstance readParams");
    AEMU_SCOPED_TRACE("vkDestroyInstance returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkInstance((VkInstance*)&instance);
    mImpl->log("finish vkDestroyInstance");;
}

VkResult VkEncoder::vkEnumeratePhysicalDevices(
    VkInstance instance,
    uint32_t* pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDevices encode");
    mImpl->log("start vkEnumeratePhysicalDevices");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    local_instance = instance;
    countingStream->rewind();
    {
        uint64_t cgen_var_9;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_9, 1);
        countingStream->write((uint64_t*)&cgen_var_9, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_10 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
        countingStream->putBe64(cgen_var_10);
        if (pPhysicalDeviceCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_11 = (uint64_t)(uintptr_t)pPhysicalDevices;
        countingStream->putBe64(cgen_var_11);
        if (pPhysicalDevices)
        {
            if ((*(pPhysicalDeviceCount)))
            {
                uint64_t* cgen_var_12;
                countingStream->alloc((void**)&cgen_var_12, (*(pPhysicalDeviceCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(pPhysicalDevices, cgen_var_12, (*(pPhysicalDeviceCount)));
                countingStream->write((uint64_t*)cgen_var_12, (*(pPhysicalDeviceCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDevices = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDevices = OP_vkEnumeratePhysicalDevices;
    stream->write(&opcode_vkEnumeratePhysicalDevices, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDevices, sizeof(uint32_t));
    uint64_t cgen_var_13;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_13, 1);
    stream->write((uint64_t*)&cgen_var_13, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_14 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
    stream->putBe64(cgen_var_14);
    if (pPhysicalDeviceCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_15 = (uint64_t)(uintptr_t)pPhysicalDevices;
    stream->putBe64(cgen_var_15);
    if (pPhysicalDevices)
    {
        if ((*(pPhysicalDeviceCount)))
        {
            uint64_t* cgen_var_16;
            stream->alloc((void**)&cgen_var_16, (*(pPhysicalDeviceCount)) * 8);
            stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(pPhysicalDevices, cgen_var_16, (*(pPhysicalDeviceCount)));
            stream->write((uint64_t*)cgen_var_16, (*(pPhysicalDeviceCount)) * 8);
        }
    }
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDevices readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceCount;
    check_pPhysicalDeviceCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceCount)
    {
        if (!(check_pPhysicalDeviceCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    }
    stream->setHandleMapping(resources->createMapping());
    // WARNING PTR CHECK
    VkPhysicalDevice* check_pPhysicalDevices;
    check_pPhysicalDevices = (VkPhysicalDevice*)(uintptr_t)stream->getBe64();
    if (pPhysicalDevices)
    {
        if (!(check_pPhysicalDevices))
        {
            fprintf(stderr, "fatal: pPhysicalDevices inconsistent between guest and host\n");
        }
        if ((*(pPhysicalDeviceCount)))
        {
            uint64_t* cgen_var_19;
            stream->alloc((void**)&cgen_var_19, (*(pPhysicalDeviceCount)) * 8);
            stream->read((uint64_t*)cgen_var_19, (*(pPhysicalDeviceCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_19, (VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
        }
    }
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDevices returnUnmarshal");
    VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEnumeratePhysicalDevices");;
    return vkEnumeratePhysicalDevices_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures encode");
    mImpl->log("start vkGetPhysicalDeviceFeatures");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_20;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_20, 1);
        countingStream->write((uint64_t*)&cgen_var_20, 1 * 8);
        marshal_VkPhysicalDeviceFeatures(countingStream, (VkPhysicalDeviceFeatures*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures = OP_vkGetPhysicalDeviceFeatures;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures, sizeof(uint32_t));
    uint64_t cgen_var_21;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_21, 1);
    stream->write((uint64_t*)&cgen_var_21, 1 * 8);
    marshal_VkPhysicalDeviceFeatures(stream, (VkPhysicalDeviceFeatures*)(pFeatures));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures readParams");
    unmarshal_VkPhysicalDeviceFeatures(stream, (VkPhysicalDeviceFeatures*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures(mImpl->resources(), (VkPhysicalDeviceFeatures*)(pFeatures));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceFeatures");;
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties* pFormatProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties encode");
    mImpl->log("start vkGetPhysicalDeviceFormatProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    countingStream->rewind();
    {
        uint64_t cgen_var_22;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_22, 1);
        countingStream->write((uint64_t*)&cgen_var_22, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        marshal_VkFormatProperties(countingStream, (VkFormatProperties*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties = OP_vkGetPhysicalDeviceFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t));
    uint64_t cgen_var_23;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_23, 1);
    stream->write((uint64_t*)&cgen_var_23, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    marshal_VkFormatProperties(stream, (VkFormatProperties*)(pFormatProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties readParams");
    unmarshal_VkFormatProperties(stream, (VkFormatProperties*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties(mImpl->resources(), (VkFormatProperties*)(pFormatProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceFormatProperties");;
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties encode");
    mImpl->log("start vkGetPhysicalDeviceImageFormatProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkImageTiling local_tiling;
    VkImageUsageFlags local_usage;
    VkImageCreateFlags local_flags;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_tiling = tiling;
    local_usage = usage;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_24;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_24, 1);
        countingStream->write((uint64_t*)&cgen_var_24, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&local_type, sizeof(VkImageType));
        countingStream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
        countingStream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
        marshal_VkImageFormatProperties(countingStream, (VkImageFormatProperties*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties = OP_vkGetPhysicalDeviceImageFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t));
    uint64_t cgen_var_25;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_25, 1);
    stream->write((uint64_t*)&cgen_var_25, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    stream->write((VkImageType*)&local_type, sizeof(VkImageType));
    stream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    stream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
    marshal_VkImageFormatProperties(stream, (VkImageFormatProperties*)(pImageFormatProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties readParams");
    unmarshal_VkImageFormatProperties(stream, (VkImageFormatProperties*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties(mImpl->resources(), (VkImageFormatProperties*)(pImageFormatProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties returnUnmarshal");
    VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceImageFormatProperties");;
    return vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties encode");
    mImpl->log("start vkGetPhysicalDeviceProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_26;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_26, 1);
        countingStream->write((uint64_t*)&cgen_var_26, 1 * 8);
        marshal_VkPhysicalDeviceProperties(countingStream, (VkPhysicalDeviceProperties*)(pProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceProperties = OP_vkGetPhysicalDeviceProperties;
    stream->write(&opcode_vkGetPhysicalDeviceProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceProperties, sizeof(uint32_t));
    uint64_t cgen_var_27;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_27, 1);
    stream->write((uint64_t*)&cgen_var_27, 1 * 8);
    marshal_VkPhysicalDeviceProperties(stream, (VkPhysicalDeviceProperties*)(pProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties readParams");
    unmarshal_VkPhysicalDeviceProperties(stream, (VkPhysicalDeviceProperties*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties(mImpl->resources(), (VkPhysicalDeviceProperties*)(pProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceProperties");;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties encode");
    mImpl->log("start vkGetPhysicalDeviceQueueFamilyProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_28;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_28, 1);
        countingStream->write((uint64_t*)&cgen_var_28, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_29 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
        countingStream->putBe64(cgen_var_29);
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_30 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
        countingStream->putBe64(cgen_var_30);
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties(countingStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties = OP_vkGetPhysicalDeviceQueueFamilyProperties;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t));
    uint64_t cgen_var_31;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_31, 1);
    stream->write((uint64_t*)&cgen_var_31, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_32 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    stream->putBe64(cgen_var_32);
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_33 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    stream->putBe64(cgen_var_33);
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties(stream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties readParams");
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties(stream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties(mImpl->resources(), (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceQueueFamilyProperties");;
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties encode");
    mImpl->log("start vkGetPhysicalDeviceMemoryProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_36;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_36, 1);
        countingStream->write((uint64_t*)&cgen_var_36, 1 * 8);
        marshal_VkPhysicalDeviceMemoryProperties(countingStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties = OP_vkGetPhysicalDeviceMemoryProperties;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t));
    uint64_t cgen_var_37;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_37, 1);
    stream->write((uint64_t*)&cgen_var_37, 1 * 8);
    marshal_VkPhysicalDeviceMemoryProperties(stream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties readParams");
    unmarshal_VkPhysicalDeviceMemoryProperties(stream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties(mImpl->resources(), (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties returnUnmarshal");
    encoderLock.unlock();
    mImpl->resources()->on_vkGetPhysicalDeviceMemoryProperties(this, physicalDevice, pMemoryProperties);
    encoderLock.lock();
    mImpl->log("finish vkGetPhysicalDeviceMemoryProperties");;
}

PFN_vkVoidFunction VkEncoder::vkGetInstanceProcAddr(
    VkInstance instance,
    const char* pName)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetInstanceProcAddr encode");
    mImpl->log("start vkGetInstanceProcAddr");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    char* local_pName;
    local_instance = instance;
    local_pName = nullptr;
    if (pName)
    {
        local_pName = pool->strDup(pName);
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_38;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_38, 1);
        countingStream->write((uint64_t*)&cgen_var_38, 1 * 8);
        countingStream->putString(local_pName);
    }
    uint32_t packetSize_vkGetInstanceProcAddr = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetInstanceProcAddr = OP_vkGetInstanceProcAddr;
    stream->write(&opcode_vkGetInstanceProcAddr, sizeof(uint32_t));
    stream->write(&packetSize_vkGetInstanceProcAddr, sizeof(uint32_t));
    uint64_t cgen_var_39;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_39, 1);
    stream->write((uint64_t*)&cgen_var_39, 1 * 8);
    stream->putString(local_pName);
    AEMU_SCOPED_TRACE("vkGetInstanceProcAddr readParams");
    AEMU_SCOPED_TRACE("vkGetInstanceProcAddr returnUnmarshal");
    PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetInstanceProcAddr");;
    return vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}

PFN_vkVoidFunction VkEncoder::vkGetDeviceProcAddr(
    VkDevice device,
    const char* pName)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDeviceProcAddr encode");
    mImpl->log("start vkGetDeviceProcAddr");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    char* local_pName;
    local_device = device;
    local_pName = nullptr;
    if (pName)
    {
        local_pName = pool->strDup(pName);
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_40;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_40, 1);
        countingStream->write((uint64_t*)&cgen_var_40, 1 * 8);
        countingStream->putString(local_pName);
    }
    uint32_t packetSize_vkGetDeviceProcAddr = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceProcAddr = OP_vkGetDeviceProcAddr;
    stream->write(&opcode_vkGetDeviceProcAddr, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceProcAddr, sizeof(uint32_t));
    uint64_t cgen_var_41;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_41, 1);
    stream->write((uint64_t*)&cgen_var_41, 1 * 8);
    stream->putString(local_pName);
    AEMU_SCOPED_TRACE("vkGetDeviceProcAddr readParams");
    AEMU_SCOPED_TRACE("vkGetDeviceProcAddr returnUnmarshal");
    PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetDeviceProcAddr");;
    return vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}

VkResult VkEncoder::vkCreateDevice(
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice* pDevice)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDevice encode");
    mImpl->log("start vkCreateDevice");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDeviceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_physicalDevice = physicalDevice;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDeviceCreateInfo*)pool->alloc(sizeof(const VkDeviceCreateInfo));
        deepcopy_VkDeviceCreateInfo(pool, pCreateInfo, (VkDeviceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDeviceCreateInfo(mImpl->resources(), (VkDeviceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_42;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_42, 1);
        countingStream->write((uint64_t*)&cgen_var_42, 1 * 8);
        marshal_VkDeviceCreateInfo(countingStream, (VkDeviceCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_43 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_43);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_44;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(pDevice, &cgen_var_44, 1);
        countingStream->write((uint64_t*)&cgen_var_44, 8);
    }
    uint32_t packetSize_vkCreateDevice = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDevice = OP_vkCreateDevice;
    stream->write(&opcode_vkCreateDevice, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDevice, sizeof(uint32_t));
    uint64_t cgen_var_45;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_45, 1);
    stream->write((uint64_t*)&cgen_var_45, 1 * 8);
    marshal_VkDeviceCreateInfo(stream, (VkDeviceCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_46 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_46);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_47;
    stream->handleMapping()->mapHandles_VkDevice_u64(pDevice, &cgen_var_47, 1);
    stream->write((uint64_t*)&cgen_var_47, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDevice readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_48;
    stream->read((uint64_t*)&cgen_var_48, 8);
    stream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_48, (VkDevice*)pDevice, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateDevice returnUnmarshal");
    VkResult vkCreateDevice_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDevice_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    encoderLock.unlock();
    mImpl->resources()->on_vkCreateDevice(this, vkCreateDevice_VkResult_return, physicalDevice, pCreateInfo, pAllocator, pDevice);
    encoderLock.lock();
    mImpl->log("finish vkCreateDevice");;
    return vkCreateDevice_VkResult_return;
}

void VkEncoder::vkDestroyDevice(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyDevice encode");
    mImpl->log("start vkDestroyDevice");
    encoderLock.unlock();
    mImpl->resources()->on_vkDestroyDevice_pre(this, device, pAllocator);
    encoderLock.lock();
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_49;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_49, 1);
        countingStream->write((uint64_t*)&cgen_var_49, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_50 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_50);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDevice = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDevice = OP_vkDestroyDevice;
    stream->write(&opcode_vkDestroyDevice, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDevice, sizeof(uint32_t));
    uint64_t cgen_var_51;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_51, 1);
    stream->write((uint64_t*)&cgen_var_51, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_52 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_52);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyDevice readParams");
    AEMU_SCOPED_TRACE("vkDestroyDevice returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkDevice((VkDevice*)&device);
    stream->flush();
    mImpl->log("finish vkDestroyDevice");;
}

VkResult VkEncoder::vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEnumerateInstanceExtensionProperties encode");
    mImpl->log("start vkEnumerateInstanceExtensionProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    char* local_pLayerName;
    local_pLayerName = nullptr;
    if (pLayerName)
    {
        local_pLayerName = pool->strDup(pLayerName);
    }
    countingStream->rewind();
    {
        if (countingStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
        {
            // WARNING PTR CHECK
            uint64_t cgen_var_53 = (uint64_t)(uintptr_t)local_pLayerName;
            countingStream->putBe64(cgen_var_53);
            if (local_pLayerName)
            {
                countingStream->putString(local_pLayerName);
            }
        }
        else
        {
            countingStream->putString(local_pLayerName);
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_54 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_54);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_55 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_55);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkExtensionProperties(countingStream, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceExtensionProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateInstanceExtensionProperties = OP_vkEnumerateInstanceExtensionProperties;
    stream->write(&opcode_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t));
    if (stream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_56 = (uint64_t)(uintptr_t)local_pLayerName;
        stream->putBe64(cgen_var_56);
        if (local_pLayerName)
        {
            stream->putString(local_pLayerName);
        }
    }
    else
    {
        stream->putString(local_pLayerName);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_57 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_57);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_58 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_58);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumerateInstanceExtensionProperties readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkExtensionProperties* check_pProperties;
    check_pProperties = (VkExtensionProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkExtensionProperties(mImpl->resources(), (VkExtensionProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumerateInstanceExtensionProperties returnUnmarshal");
    VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEnumerateInstanceExtensionProperties");;
    return vkEnumerateInstanceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice physicalDevice,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEnumerateDeviceExtensionProperties encode");
    mImpl->log("start vkEnumerateDeviceExtensionProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    char* local_pLayerName;
    local_physicalDevice = physicalDevice;
    local_pLayerName = nullptr;
    if (pLayerName)
    {
        local_pLayerName = pool->strDup(pLayerName);
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_61;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_61, 1);
        countingStream->write((uint64_t*)&cgen_var_61, 1 * 8);
        if (countingStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
        {
            // WARNING PTR CHECK
            uint64_t cgen_var_62 = (uint64_t)(uintptr_t)local_pLayerName;
            countingStream->putBe64(cgen_var_62);
            if (local_pLayerName)
            {
                countingStream->putString(local_pLayerName);
            }
        }
        else
        {
            countingStream->putString(local_pLayerName);
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_63 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_63);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_64 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_64);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkExtensionProperties(countingStream, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceExtensionProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateDeviceExtensionProperties = OP_vkEnumerateDeviceExtensionProperties;
    stream->write(&opcode_vkEnumerateDeviceExtensionProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateDeviceExtensionProperties, sizeof(uint32_t));
    uint64_t cgen_var_65;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_65, 1);
    stream->write((uint64_t*)&cgen_var_65, 1 * 8);
    if (stream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_66 = (uint64_t)(uintptr_t)local_pLayerName;
        stream->putBe64(cgen_var_66);
        if (local_pLayerName)
        {
            stream->putString(local_pLayerName);
        }
    }
    else
    {
        stream->putString(local_pLayerName);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_67 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_67);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_68 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_68);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumerateDeviceExtensionProperties readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkExtensionProperties* check_pProperties;
    check_pProperties = (VkExtensionProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkExtensionProperties(mImpl->resources(), (VkExtensionProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumerateDeviceExtensionProperties returnUnmarshal");
    VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEnumerateDeviceExtensionProperties");;
    return vkEnumerateDeviceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateInstanceLayerProperties(
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEnumerateInstanceLayerProperties encode");
    mImpl->log("start vkEnumerateInstanceLayerProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    countingStream->rewind();
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_71 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_71);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_72 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_72);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkLayerProperties(countingStream, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceLayerProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateInstanceLayerProperties = OP_vkEnumerateInstanceLayerProperties;
    stream->write(&opcode_vkEnumerateInstanceLayerProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateInstanceLayerProperties, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_73 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_73);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_74 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_74);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumerateInstanceLayerProperties readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkLayerProperties* check_pProperties;
    check_pProperties = (VkLayerProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkLayerProperties(mImpl->resources(), (VkLayerProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumerateInstanceLayerProperties returnUnmarshal");
    VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEnumerateInstanceLayerProperties");;
    return vkEnumerateInstanceLayerProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEnumerateDeviceLayerProperties encode");
    mImpl->log("start vkEnumerateDeviceLayerProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_77;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_77, 1);
        countingStream->write((uint64_t*)&cgen_var_77, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_78 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_78);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_79 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_79);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkLayerProperties(countingStream, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceLayerProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateDeviceLayerProperties = OP_vkEnumerateDeviceLayerProperties;
    stream->write(&opcode_vkEnumerateDeviceLayerProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateDeviceLayerProperties, sizeof(uint32_t));
    uint64_t cgen_var_80;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_80, 1);
    stream->write((uint64_t*)&cgen_var_80, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_81 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_81);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_82 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_82);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumerateDeviceLayerProperties readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkLayerProperties* check_pProperties;
    check_pProperties = (VkLayerProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkLayerProperties(mImpl->resources(), (VkLayerProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumerateDeviceLayerProperties returnUnmarshal");
    VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEnumerateDeviceLayerProperties");;
    return vkEnumerateDeviceLayerProperties_VkResult_return;
}

void VkEncoder::vkGetDeviceQueue(
    VkDevice device,
    uint32_t queueFamilyIndex,
    uint32_t queueIndex,
    VkQueue* pQueue)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDeviceQueue encode");
    mImpl->log("start vkGetDeviceQueue");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_queueFamilyIndex;
    uint32_t local_queueIndex;
    local_device = device;
    local_queueFamilyIndex = queueFamilyIndex;
    local_queueIndex = queueIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_85;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_85, 1);
        countingStream->write((uint64_t*)&cgen_var_85, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_queueIndex, sizeof(uint32_t));
        uint64_t cgen_var_86;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_86, 1);
        countingStream->write((uint64_t*)&cgen_var_86, 8);
    }
    uint32_t packetSize_vkGetDeviceQueue = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceQueue = OP_vkGetDeviceQueue;
    stream->write(&opcode_vkGetDeviceQueue, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceQueue, sizeof(uint32_t));
    uint64_t cgen_var_87;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_87, 1);
    stream->write((uint64_t*)&cgen_var_87, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_queueIndex, sizeof(uint32_t));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_88;
    stream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_88, 1);
    stream->write((uint64_t*)&cgen_var_88, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkGetDeviceQueue readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_89;
    stream->read((uint64_t*)&cgen_var_89, 8);
    stream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_89, (VkQueue*)pQueue, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkGetDeviceQueue returnUnmarshal");
    mImpl->log("finish vkGetDeviceQueue");;
}

VkResult VkEncoder::vkQueueSubmit(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkQueueSubmit encode");
    mImpl->log("start vkQueueSubmit");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    uint32_t local_submitCount;
    VkSubmitInfo* local_pSubmits;
    VkFence local_fence;
    local_queue = queue;
    local_submitCount = submitCount;
    local_pSubmits = nullptr;
    if (pSubmits)
    {
        local_pSubmits = (VkSubmitInfo*)pool->alloc(((submitCount)) * sizeof(const VkSubmitInfo));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            deepcopy_VkSubmitInfo(pool, pSubmits + i, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    local_fence = fence;
    if (local_pSubmits)
    {
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            transform_tohost_VkSubmitInfo(mImpl->resources(), (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_90;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_90, 1);
        countingStream->write((uint64_t*)&cgen_var_90, 1 * 8);
        countingStream->write((uint32_t*)&local_submitCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            marshal_VkSubmitInfo(countingStream, (VkSubmitInfo*)(local_pSubmits + i));
        }
        uint64_t cgen_var_91;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_91, 1);
        countingStream->write((uint64_t*)&cgen_var_91, 1 * 8);
    }
    uint32_t packetSize_vkQueueSubmit = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueSubmit = OP_vkQueueSubmit;
    stream->write(&opcode_vkQueueSubmit, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueSubmit, sizeof(uint32_t));
    uint64_t cgen_var_92;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_92, 1);
    stream->write((uint64_t*)&cgen_var_92, 1 * 8);
    stream->write((uint32_t*)&local_submitCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        marshal_VkSubmitInfo(stream, (VkSubmitInfo*)(local_pSubmits + i));
    }
    uint64_t cgen_var_93;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_93, 1);
    stream->write((uint64_t*)&cgen_var_93, 1 * 8);
    AEMU_SCOPED_TRACE("vkQueueSubmit readParams");
    AEMU_SCOPED_TRACE("vkQueueSubmit returnUnmarshal");
    VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkQueueSubmit");;
    return vkQueueSubmit_VkResult_return;
}

VkResult VkEncoder::vkQueueWaitIdle(
    VkQueue queue)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkQueueWaitIdle encode");
    mImpl->log("start vkQueueWaitIdle");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    local_queue = queue;
    countingStream->rewind();
    {
        uint64_t cgen_var_94;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_94, 1);
        countingStream->write((uint64_t*)&cgen_var_94, 1 * 8);
    }
    uint32_t packetSize_vkQueueWaitIdle = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueWaitIdle = OP_vkQueueWaitIdle;
    stream->write(&opcode_vkQueueWaitIdle, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueWaitIdle, sizeof(uint32_t));
    uint64_t cgen_var_95;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_95, 1);
    stream->write((uint64_t*)&cgen_var_95, 1 * 8);
    AEMU_SCOPED_TRACE("vkQueueWaitIdle readParams");
    AEMU_SCOPED_TRACE("vkQueueWaitIdle returnUnmarshal");
    VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkQueueWaitIdle");;
    return vkQueueWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkDeviceWaitIdle(
    VkDevice device)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDeviceWaitIdle encode");
    mImpl->log("start vkDeviceWaitIdle");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    local_device = device;
    countingStream->rewind();
    {
        uint64_t cgen_var_96;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_96, 1);
        countingStream->write((uint64_t*)&cgen_var_96, 1 * 8);
    }
    uint32_t packetSize_vkDeviceWaitIdle = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDeviceWaitIdle = OP_vkDeviceWaitIdle;
    stream->write(&opcode_vkDeviceWaitIdle, sizeof(uint32_t));
    stream->write(&packetSize_vkDeviceWaitIdle, sizeof(uint32_t));
    uint64_t cgen_var_97;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_97, 1);
    stream->write((uint64_t*)&cgen_var_97, 1 * 8);
    AEMU_SCOPED_TRACE("vkDeviceWaitIdle readParams");
    AEMU_SCOPED_TRACE("vkDeviceWaitIdle returnUnmarshal");
    VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkDeviceWaitIdle");;
    return vkDeviceWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkAllocateMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkAllocateMemory encode");
    mImpl->log("start vkAllocateMemory");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkMemoryAllocateInfo* local_pAllocateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkMemoryAllocateInfo*)pool->alloc(sizeof(const VkMemoryAllocateInfo));
        deepcopy_VkMemoryAllocateInfo(pool, pAllocateInfo, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocateInfo)
    {
        transform_tohost_VkMemoryAllocateInfo(mImpl->resources(), (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_98;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_98, 1);
        countingStream->write((uint64_t*)&cgen_var_98, 1 * 8);
        marshal_VkMemoryAllocateInfo(countingStream, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_99 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_99);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_100;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(pMemory, &cgen_var_100, 1);
        countingStream->write((uint64_t*)&cgen_var_100, 8);
    }
    uint32_t packetSize_vkAllocateMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateMemory = OP_vkAllocateMemory;
    stream->write(&opcode_vkAllocateMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateMemory, sizeof(uint32_t));
    uint64_t cgen_var_101;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_101, 1);
    stream->write((uint64_t*)&cgen_var_101, 1 * 8);
    marshal_VkMemoryAllocateInfo(stream, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_102 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_102);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_103;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(pMemory, &cgen_var_103, 1);
    stream->write((uint64_t*)&cgen_var_103, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkAllocateMemory readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_104;
    stream->read((uint64_t*)&cgen_var_104, 8);
    stream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_104, (VkDeviceMemory*)pMemory, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkAllocateMemory returnUnmarshal");
    VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkAllocateMemory");;
    return vkAllocateMemory_VkResult_return;
}

void VkEncoder::vkFreeMemory(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkFreeMemory encode");
    mImpl->log("start vkFreeMemory");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_memory = memory;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    mImpl->resources()->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_105;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_105, 1);
        countingStream->write((uint64_t*)&cgen_var_105, 1 * 8);
        uint64_t cgen_var_106;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_106, 1);
        countingStream->write((uint64_t*)&cgen_var_106, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_107 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_107);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkFreeMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeMemory = OP_vkFreeMemory;
    stream->write(&opcode_vkFreeMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeMemory, sizeof(uint32_t));
    uint64_t cgen_var_108;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_108, 1);
    stream->write((uint64_t*)&cgen_var_108, 1 * 8);
    uint64_t cgen_var_109;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_109, 1);
    stream->write((uint64_t*)&cgen_var_109, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_110 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_110);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkFreeMemory readParams");
    AEMU_SCOPED_TRACE("vkFreeMemory returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)&memory);
    mImpl->log("finish vkFreeMemory");;
}

VkResult VkEncoder::vkMapMemory(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData)
{
    AEMU_SCOPED_TRACE("vkMapMemory resourceEvent");
    VkResult vkMapMemory_VkResult_return = (VkResult)0;
    vkMapMemory_VkResult_return = mImpl->resources()->on_vkMapMemory(this, VK_SUCCESS, device, memory, offset, size, flags, ppData);
    mImpl->log("finish vkMapMemory");;
    return vkMapMemory_VkResult_return;
}

void VkEncoder::vkUnmapMemory(
    VkDevice device,
    VkDeviceMemory memory)
{
    AEMU_SCOPED_TRACE("vkUnmapMemory resourceEvent");
    mImpl->resources()->on_vkUnmapMemory(this, device, memory);
}

VkResult VkEncoder::vkFlushMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkFlushMappedMemoryRanges encode");
    mImpl->log("start vkFlushMappedMemoryRanges");
    VALIDATE_RET(VkResult, VK_SUCCESS, mImpl->validation()->on_vkFlushMappedMemoryRanges(this, VK_SUCCESS, device, memoryRangeCount, pMemoryRanges));
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_memoryRangeCount;
    VkMappedMemoryRange* local_pMemoryRanges;
    local_device = device;
    local_memoryRangeCount = memoryRangeCount;
    local_pMemoryRanges = nullptr;
    if (pMemoryRanges)
    {
        local_pMemoryRanges = (VkMappedMemoryRange*)pool->alloc(((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            deepcopy_VkMappedMemoryRange(pool, pMemoryRanges + i, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (local_pMemoryRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            transform_tohost_VkMappedMemoryRange(mImpl->resources(), (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_111;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_111, 1);
        countingStream->write((uint64_t*)&cgen_var_111, 1 * 8);
        countingStream->write((uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            marshal_VkMappedMemoryRange(countingStream, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (!resources->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { countingStream->write(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = resources->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? resources->getMappedSize(memory) : size;
            if (!hostPtr) { countingStream->write(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            countingStream->write(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            countingStream->write(targetRange, actualSize);
        }
    }
    uint32_t packetSize_vkFlushMappedMemoryRanges = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFlushMappedMemoryRanges = OP_vkFlushMappedMemoryRanges;
    stream->write(&opcode_vkFlushMappedMemoryRanges, sizeof(uint32_t));
    stream->write(&packetSize_vkFlushMappedMemoryRanges, sizeof(uint32_t));
    uint64_t cgen_var_112;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_112, 1);
    stream->write((uint64_t*)&cgen_var_112, 1 * 8);
    stream->write((uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        marshal_VkMappedMemoryRange(stream, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
    }
    if (!resources->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { stream->write(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = resources->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? resources->getMappedSize(memory) : size;
            if (!hostPtr) { stream->write(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            stream->write(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            stream->write(targetRange, actualSize);
        }
    }
    AEMU_SCOPED_TRACE("vkFlushMappedMemoryRanges readParams");
    AEMU_SCOPED_TRACE("vkFlushMappedMemoryRanges returnUnmarshal");
    VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkFlushMappedMemoryRanges");;
    return vkFlushMappedMemoryRanges_VkResult_return;
}

VkResult VkEncoder::vkInvalidateMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkInvalidateMappedMemoryRanges encode");
    mImpl->log("start vkInvalidateMappedMemoryRanges");
    VALIDATE_RET(VkResult, VK_SUCCESS, mImpl->validation()->on_vkInvalidateMappedMemoryRanges(this, VK_SUCCESS, device, memoryRangeCount, pMemoryRanges));
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_memoryRangeCount;
    VkMappedMemoryRange* local_pMemoryRanges;
    local_device = device;
    local_memoryRangeCount = memoryRangeCount;
    local_pMemoryRanges = nullptr;
    if (pMemoryRanges)
    {
        local_pMemoryRanges = (VkMappedMemoryRange*)pool->alloc(((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            deepcopy_VkMappedMemoryRange(pool, pMemoryRanges + i, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (local_pMemoryRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            transform_tohost_VkMappedMemoryRange(mImpl->resources(), (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_113;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_113, 1);
        countingStream->write((uint64_t*)&cgen_var_113, 1 * 8);
        countingStream->write((uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            marshal_VkMappedMemoryRange(countingStream, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    uint32_t packetSize_vkInvalidateMappedMemoryRanges = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkInvalidateMappedMemoryRanges = OP_vkInvalidateMappedMemoryRanges;
    stream->write(&opcode_vkInvalidateMappedMemoryRanges, sizeof(uint32_t));
    stream->write(&packetSize_vkInvalidateMappedMemoryRanges, sizeof(uint32_t));
    uint64_t cgen_var_114;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_114, 1);
    stream->write((uint64_t*)&cgen_var_114, 1 * 8);
    stream->write((uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        marshal_VkMappedMemoryRange(stream, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
    }
    AEMU_SCOPED_TRACE("vkInvalidateMappedMemoryRanges readParams");
    AEMU_SCOPED_TRACE("vkInvalidateMappedMemoryRanges returnUnmarshal");
    VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    if (!resources->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { stream->read(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = resources->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? resources->getMappedSize(memory) : size;
            if (!hostPtr) { stream->read(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            stream->read(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            stream->read(targetRange, actualSize);
        }
    }
    mImpl->log("finish vkInvalidateMappedMemoryRanges");;
    return vkInvalidateMappedMemoryRanges_VkResult_return;
}

void VkEncoder::vkGetDeviceMemoryCommitment(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryCommitment encode");
    mImpl->log("start vkGetDeviceMemoryCommitment");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    mImpl->resources()->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_115;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_115, 1);
        countingStream->write((uint64_t*)&cgen_var_115, 1 * 8);
        uint64_t cgen_var_116;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_116, 1);
        countingStream->write((uint64_t*)&cgen_var_116, 1 * 8);
        countingStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkGetDeviceMemoryCommitment = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceMemoryCommitment = OP_vkGetDeviceMemoryCommitment;
    stream->write(&opcode_vkGetDeviceMemoryCommitment, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceMemoryCommitment, sizeof(uint32_t));
    uint64_t cgen_var_117;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_117, 1);
    stream->write((uint64_t*)&cgen_var_117, 1 * 8);
    uint64_t cgen_var_118;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_118, 1);
    stream->write((uint64_t*)&cgen_var_118, 1 * 8);
    stream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryCommitment readParams");
    stream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryCommitment returnUnmarshal");
    mImpl->log("finish vkGetDeviceMemoryCommitment");;
}

VkResult VkEncoder::vkBindBufferMemory(
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkBindBufferMemory encode");
    mImpl->log("start vkBindBufferMemory");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBuffer local_buffer;
    VkDeviceMemory local_memory;
    VkDeviceSize local_memoryOffset;
    local_device = device;
    local_buffer = buffer;
    local_memory = memory;
    local_memoryOffset = memoryOffset;
    mImpl->resources()->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)&local_memoryOffset, 1, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_119;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_119, 1);
        countingStream->write((uint64_t*)&cgen_var_119, 1 * 8);
        uint64_t cgen_var_120;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_120, 1);
        countingStream->write((uint64_t*)&cgen_var_120, 1 * 8);
        uint64_t cgen_var_121;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_121, 1);
        countingStream->write((uint64_t*)&cgen_var_121, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkBindBufferMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory = OP_vkBindBufferMemory;
    stream->write(&opcode_vkBindBufferMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory, sizeof(uint32_t));
    uint64_t cgen_var_122;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_122, 1);
    stream->write((uint64_t*)&cgen_var_122, 1 * 8);
    uint64_t cgen_var_123;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_123, 1);
    stream->write((uint64_t*)&cgen_var_123, 1 * 8);
    uint64_t cgen_var_124;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_124, 1);
    stream->write((uint64_t*)&cgen_var_124, 1 * 8);
    stream->write((VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    AEMU_SCOPED_TRACE("vkBindBufferMemory readParams");
    AEMU_SCOPED_TRACE("vkBindBufferMemory returnUnmarshal");
    VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkBindBufferMemory");;
    return vkBindBufferMemory_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkBindImageMemory encode");
    mImpl->log("start vkBindImageMemory");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    VkDeviceMemory local_memory;
    VkDeviceSize local_memoryOffset;
    local_device = device;
    local_image = image;
    local_memory = memory;
    local_memoryOffset = memoryOffset;
    mImpl->resources()->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)&local_memoryOffset, 1, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_125;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_125, 1);
        countingStream->write((uint64_t*)&cgen_var_125, 1 * 8);
        uint64_t cgen_var_126;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_126, 1);
        countingStream->write((uint64_t*)&cgen_var_126, 1 * 8);
        uint64_t cgen_var_127;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_127, 1);
        countingStream->write((uint64_t*)&cgen_var_127, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkBindImageMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory = OP_vkBindImageMemory;
    stream->write(&opcode_vkBindImageMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory, sizeof(uint32_t));
    uint64_t cgen_var_128;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_128, 1);
    stream->write((uint64_t*)&cgen_var_128, 1 * 8);
    uint64_t cgen_var_129;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_129, 1);
    stream->write((uint64_t*)&cgen_var_129, 1 * 8);
    uint64_t cgen_var_130;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_130, 1);
    stream->write((uint64_t*)&cgen_var_130, 1 * 8);
    stream->write((VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    AEMU_SCOPED_TRACE("vkBindImageMemory readParams");
    AEMU_SCOPED_TRACE("vkBindImageMemory returnUnmarshal");
    VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkBindImageMemory");;
    return vkBindImageMemory_VkResult_return;
}

void VkEncoder::vkGetBufferMemoryRequirements(
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements encode");
    mImpl->log("start vkGetBufferMemoryRequirements");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBuffer local_buffer;
    local_device = device;
    local_buffer = buffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_131;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_131, 1);
        countingStream->write((uint64_t*)&cgen_var_131, 1 * 8);
        uint64_t cgen_var_132;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_132, 1);
        countingStream->write((uint64_t*)&cgen_var_132, 1 * 8);
        marshal_VkMemoryRequirements(countingStream, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements = OP_vkGetBufferMemoryRequirements;
    stream->write(&opcode_vkGetBufferMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements, sizeof(uint32_t));
    uint64_t cgen_var_133;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_133, 1);
    stream->write((uint64_t*)&cgen_var_133, 1 * 8);
    uint64_t cgen_var_134;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_134, 1);
    stream->write((uint64_t*)&cgen_var_134, 1 * 8);
    marshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements readParams");
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(mImpl->resources(), (VkMemoryRequirements*)(pMemoryRequirements));
    }
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements returnUnmarshal");
    mImpl->log("finish vkGetBufferMemoryRequirements");;
}

void VkEncoder::vkGetImageMemoryRequirements(
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements encode");
    mImpl->log("start vkGetImageMemoryRequirements");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    countingStream->rewind();
    {
        uint64_t cgen_var_135;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_135, 1);
        countingStream->write((uint64_t*)&cgen_var_135, 1 * 8);
        uint64_t cgen_var_136;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_136, 1);
        countingStream->write((uint64_t*)&cgen_var_136, 1 * 8);
        marshal_VkMemoryRequirements(countingStream, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements = OP_vkGetImageMemoryRequirements;
    stream->write(&opcode_vkGetImageMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements, sizeof(uint32_t));
    uint64_t cgen_var_137;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_137, 1);
    stream->write((uint64_t*)&cgen_var_137, 1 * 8);
    uint64_t cgen_var_138;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_138, 1);
    stream->write((uint64_t*)&cgen_var_138, 1 * 8);
    marshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements readParams");
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(mImpl->resources(), (VkMemoryRequirements*)(pMemoryRequirements));
    }
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements returnUnmarshal");
    mImpl->log("finish vkGetImageMemoryRequirements");;
}

void VkEncoder::vkGetImageSparseMemoryRequirements(
    VkDevice device,
    VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements encode");
    mImpl->log("start vkGetImageSparseMemoryRequirements");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    countingStream->rewind();
    {
        uint64_t cgen_var_139;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_139, 1);
        countingStream->write((uint64_t*)&cgen_var_139, 1 * 8);
        uint64_t cgen_var_140;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_140, 1);
        countingStream->write((uint64_t*)&cgen_var_140, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_141 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
        countingStream->putBe64(cgen_var_141);
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_142 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
        countingStream->putBe64(cgen_var_142);
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements(countingStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements = OP_vkGetImageSparseMemoryRequirements;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements, sizeof(uint32_t));
    uint64_t cgen_var_143;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_143, 1);
    stream->write((uint64_t*)&cgen_var_143, 1 * 8);
    uint64_t cgen_var_144;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_144, 1);
    stream->write((uint64_t*)&cgen_var_144, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_145 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    stream->putBe64(cgen_var_145);
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_146 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    stream->putBe64(cgen_var_146);
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements(stream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements readParams");
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements(stream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements(mImpl->resources(), (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements returnUnmarshal");
    mImpl->log("finish vkGetImageSparseMemoryRequirements");;
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkSampleCountFlagBits samples,
    VkImageUsageFlags usage,
    VkImageTiling tiling,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties encode");
    mImpl->log("start vkGetPhysicalDeviceSparseImageFormatProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkSampleCountFlagBits local_samples;
    VkImageUsageFlags local_usage;
    VkImageTiling local_tiling;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_samples = samples;
    local_usage = usage;
    local_tiling = tiling;
    countingStream->rewind();
    {
        uint64_t cgen_var_149;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_149, 1);
        countingStream->write((uint64_t*)&cgen_var_149, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&local_type, sizeof(VkImageType));
        countingStream->write((VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
        countingStream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
        // WARNING PTR CHECK
        uint64_t cgen_var_150 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_150);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_151 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_151);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties(countingStream, (VkSparseImageFormatProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties = OP_vkGetPhysicalDeviceSparseImageFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t));
    uint64_t cgen_var_152;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_152, 1);
    stream->write((uint64_t*)&cgen_var_152, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    stream->write((VkImageType*)&local_type, sizeof(VkImageType));
    stream->write((VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
    stream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    // WARNING PTR CHECK
    uint64_t cgen_var_153 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_153);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_154 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_154);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties(stream, (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties(stream, (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties(mImpl->resources(), (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceSparseImageFormatProperties");;
}

VkResult VkEncoder::vkQueueBindSparse(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkQueueBindSparse encode");
    mImpl->log("start vkQueueBindSparse");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    uint32_t local_bindInfoCount;
    VkBindSparseInfo* local_pBindInfo;
    VkFence local_fence;
    local_queue = queue;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfo = nullptr;
    if (pBindInfo)
    {
        local_pBindInfo = (VkBindSparseInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindSparseInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindSparseInfo(pool, pBindInfo + i, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    local_fence = fence;
    if (local_pBindInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindSparseInfo(mImpl->resources(), (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_157;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_157, 1);
        countingStream->write((uint64_t*)&cgen_var_157, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindSparseInfo(countingStream, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
        uint64_t cgen_var_158;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_158, 1);
        countingStream->write((uint64_t*)&cgen_var_158, 1 * 8);
    }
    uint32_t packetSize_vkQueueBindSparse = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueBindSparse = OP_vkQueueBindSparse;
    stream->write(&opcode_vkQueueBindSparse, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueBindSparse, sizeof(uint32_t));
    uint64_t cgen_var_159;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_159, 1);
    stream->write((uint64_t*)&cgen_var_159, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindSparseInfo(stream, (VkBindSparseInfo*)(local_pBindInfo + i));
    }
    uint64_t cgen_var_160;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_160, 1);
    stream->write((uint64_t*)&cgen_var_160, 1 * 8);
    AEMU_SCOPED_TRACE("vkQueueBindSparse readParams");
    AEMU_SCOPED_TRACE("vkQueueBindSparse returnUnmarshal");
    VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
    stream->read(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkQueueBindSparse");;
    return vkQueueBindSparse_VkResult_return;
}

VkResult VkEncoder::vkCreateFence(
    VkDevice device,
    const VkFenceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateFence encode");
    mImpl->log("start vkCreateFence");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFenceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkFenceCreateInfo*)pool->alloc(sizeof(const VkFenceCreateInfo));
        deepcopy_VkFenceCreateInfo(pool, pCreateInfo, (VkFenceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkFenceCreateInfo(mImpl->resources(), (VkFenceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_161;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_161, 1);
        countingStream->write((uint64_t*)&cgen_var_161, 1 * 8);
        marshal_VkFenceCreateInfo(countingStream, (VkFenceCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_162 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_162);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_163;
        countingStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_163, 1);
        countingStream->write((uint64_t*)&cgen_var_163, 8);
    }
    uint32_t packetSize_vkCreateFence = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateFence = OP_vkCreateFence;
    stream->write(&opcode_vkCreateFence, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateFence, sizeof(uint32_t));
    uint64_t cgen_var_164;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_164, 1);
    stream->write((uint64_t*)&cgen_var_164, 1 * 8);
    marshal_VkFenceCreateInfo(stream, (VkFenceCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_165 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_165);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_166;
    stream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_166, 1);
    stream->write((uint64_t*)&cgen_var_166, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateFence readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_167;
    stream->read((uint64_t*)&cgen_var_167, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_167, (VkFence*)pFence, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateFence returnUnmarshal");
    VkResult vkCreateFence_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFence_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateFence");;
    return vkCreateFence_VkResult_return;
}

void VkEncoder::vkDestroyFence(
    VkDevice device,
    VkFence fence,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyFence encode");
    mImpl->log("start vkDestroyFence");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFence local_fence;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_fence = fence;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_168;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_168, 1);
        countingStream->write((uint64_t*)&cgen_var_168, 1 * 8);
        uint64_t cgen_var_169;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_169, 1);
        countingStream->write((uint64_t*)&cgen_var_169, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_170 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_170);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyFence = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyFence = OP_vkDestroyFence;
    stream->write(&opcode_vkDestroyFence, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyFence, sizeof(uint32_t));
    uint64_t cgen_var_171;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_171, 1);
    stream->write((uint64_t*)&cgen_var_171, 1 * 8);
    uint64_t cgen_var_172;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_172, 1);
    stream->write((uint64_t*)&cgen_var_172, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_173 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_173);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyFence readParams");
    AEMU_SCOPED_TRACE("vkDestroyFence returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkFence((VkFence*)&fence);
    mImpl->log("finish vkDestroyFence");;
}

VkResult VkEncoder::vkResetFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkResetFences encode");
    mImpl->log("start vkResetFences");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_fenceCount;
    VkFence* local_pFences;
    local_device = device;
    local_fenceCount = fenceCount;
    local_pFences = nullptr;
    if (pFences)
    {
        local_pFences = (VkFence*)pool->dupArray(pFences, ((fenceCount)) * sizeof(const VkFence));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_174;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_174, 1);
        countingStream->write((uint64_t*)&cgen_var_174, 1 * 8);
        countingStream->write((uint32_t*)&local_fenceCount, sizeof(uint32_t));
        if (((fenceCount)))
        {
            uint64_t* cgen_var_175;
            countingStream->alloc((void**)&cgen_var_175, ((fenceCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkFence_u64(local_pFences, cgen_var_175, ((fenceCount)));
            countingStream->write((uint64_t*)cgen_var_175, ((fenceCount)) * 8);
        }
    }
    uint32_t packetSize_vkResetFences = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetFences = OP_vkResetFences;
    stream->write(&opcode_vkResetFences, sizeof(uint32_t));
    stream->write(&packetSize_vkResetFences, sizeof(uint32_t));
    uint64_t cgen_var_176;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_176, 1);
    stream->write((uint64_t*)&cgen_var_176, 1 * 8);
    stream->write((uint32_t*)&local_fenceCount, sizeof(uint32_t));
    if (((fenceCount)))
    {
        uint64_t* cgen_var_177;
        stream->alloc((void**)&cgen_var_177, ((fenceCount)) * 8);
        stream->handleMapping()->mapHandles_VkFence_u64(local_pFences, cgen_var_177, ((fenceCount)));
        stream->write((uint64_t*)cgen_var_177, ((fenceCount)) * 8);
    }
    AEMU_SCOPED_TRACE("vkResetFences readParams");
    AEMU_SCOPED_TRACE("vkResetFences returnUnmarshal");
    VkResult vkResetFences_VkResult_return = (VkResult)0;
    stream->read(&vkResetFences_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkResetFences");;
    return vkResetFences_VkResult_return;
}

VkResult VkEncoder::vkGetFenceStatus(
    VkDevice device,
    VkFence fence)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetFenceStatus encode");
    mImpl->log("start vkGetFenceStatus");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFence local_fence;
    local_device = device;
    local_fence = fence;
    countingStream->rewind();
    {
        uint64_t cgen_var_178;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_178, 1);
        countingStream->write((uint64_t*)&cgen_var_178, 1 * 8);
        uint64_t cgen_var_179;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_179, 1);
        countingStream->write((uint64_t*)&cgen_var_179, 1 * 8);
    }
    uint32_t packetSize_vkGetFenceStatus = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceStatus = OP_vkGetFenceStatus;
    stream->write(&opcode_vkGetFenceStatus, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceStatus, sizeof(uint32_t));
    uint64_t cgen_var_180;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_180, 1);
    stream->write((uint64_t*)&cgen_var_180, 1 * 8);
    uint64_t cgen_var_181;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_181, 1);
    stream->write((uint64_t*)&cgen_var_181, 1 * 8);
    AEMU_SCOPED_TRACE("vkGetFenceStatus readParams");
    AEMU_SCOPED_TRACE("vkGetFenceStatus returnUnmarshal");
    VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetFenceStatus");;
    return vkGetFenceStatus_VkResult_return;
}

VkResult VkEncoder::vkWaitForFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    VkBool32 waitAll,
    uint64_t timeout)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkWaitForFences encode");
    mImpl->log("start vkWaitForFences");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_fenceCount;
    VkFence* local_pFences;
    VkBool32 local_waitAll;
    uint64_t local_timeout;
    local_device = device;
    local_fenceCount = fenceCount;
    local_pFences = nullptr;
    if (pFences)
    {
        local_pFences = (VkFence*)pool->dupArray(pFences, ((fenceCount)) * sizeof(const VkFence));
    }
    local_waitAll = waitAll;
    local_timeout = timeout;
    countingStream->rewind();
    {
        uint64_t cgen_var_182;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_182, 1);
        countingStream->write((uint64_t*)&cgen_var_182, 1 * 8);
        countingStream->write((uint32_t*)&local_fenceCount, sizeof(uint32_t));
        if (((fenceCount)))
        {
            uint64_t* cgen_var_183;
            countingStream->alloc((void**)&cgen_var_183, ((fenceCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkFence_u64(local_pFences, cgen_var_183, ((fenceCount)));
            countingStream->write((uint64_t*)cgen_var_183, ((fenceCount)) * 8);
        }
        countingStream->write((VkBool32*)&local_waitAll, sizeof(VkBool32));
        countingStream->write((uint64_t*)&local_timeout, sizeof(uint64_t));
    }
    uint32_t packetSize_vkWaitForFences = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkWaitForFences = OP_vkWaitForFences;
    stream->write(&opcode_vkWaitForFences, sizeof(uint32_t));
    stream->write(&packetSize_vkWaitForFences, sizeof(uint32_t));
    uint64_t cgen_var_184;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_184, 1);
    stream->write((uint64_t*)&cgen_var_184, 1 * 8);
    stream->write((uint32_t*)&local_fenceCount, sizeof(uint32_t));
    if (((fenceCount)))
    {
        uint64_t* cgen_var_185;
        stream->alloc((void**)&cgen_var_185, ((fenceCount)) * 8);
        stream->handleMapping()->mapHandles_VkFence_u64(local_pFences, cgen_var_185, ((fenceCount)));
        stream->write((uint64_t*)cgen_var_185, ((fenceCount)) * 8);
    }
    stream->write((VkBool32*)&local_waitAll, sizeof(VkBool32));
    stream->write((uint64_t*)&local_timeout, sizeof(uint64_t));
    AEMU_SCOPED_TRACE("vkWaitForFences readParams");
    AEMU_SCOPED_TRACE("vkWaitForFences returnUnmarshal");
    VkResult vkWaitForFences_VkResult_return = (VkResult)0;
    stream->read(&vkWaitForFences_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkWaitForFences");;
    return vkWaitForFences_VkResult_return;
}

VkResult VkEncoder::vkCreateSemaphore(
    VkDevice device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore* pSemaphore)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateSemaphore encode");
    mImpl->log("start vkCreateSemaphore");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSemaphoreCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSemaphoreCreateInfo*)pool->alloc(sizeof(const VkSemaphoreCreateInfo));
        deepcopy_VkSemaphoreCreateInfo(pool, pCreateInfo, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSemaphoreCreateInfo(mImpl->resources(), (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_186;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_186, 1);
        countingStream->write((uint64_t*)&cgen_var_186, 1 * 8);
        marshal_VkSemaphoreCreateInfo(countingStream, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_187 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_187);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_188;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(pSemaphore, &cgen_var_188, 1);
        countingStream->write((uint64_t*)&cgen_var_188, 8);
    }
    uint32_t packetSize_vkCreateSemaphore = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSemaphore = OP_vkCreateSemaphore;
    stream->write(&opcode_vkCreateSemaphore, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSemaphore, sizeof(uint32_t));
    uint64_t cgen_var_189;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_189, 1);
    stream->write((uint64_t*)&cgen_var_189, 1 * 8);
    marshal_VkSemaphoreCreateInfo(stream, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_190 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_190);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_191;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(pSemaphore, &cgen_var_191, 1);
    stream->write((uint64_t*)&cgen_var_191, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateSemaphore readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_192;
    stream->read((uint64_t*)&cgen_var_192, 8);
    stream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_192, (VkSemaphore*)pSemaphore, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateSemaphore returnUnmarshal");
    VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateSemaphore");;
    return vkCreateSemaphore_VkResult_return;
}

void VkEncoder::vkDestroySemaphore(
    VkDevice device,
    VkSemaphore semaphore,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroySemaphore encode");
    mImpl->log("start vkDestroySemaphore");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSemaphore local_semaphore;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_semaphore = semaphore;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_193;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_193, 1);
        countingStream->write((uint64_t*)&cgen_var_193, 1 * 8);
        uint64_t cgen_var_194;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_194, 1);
        countingStream->write((uint64_t*)&cgen_var_194, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_195 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_195);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySemaphore = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySemaphore = OP_vkDestroySemaphore;
    stream->write(&opcode_vkDestroySemaphore, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySemaphore, sizeof(uint32_t));
    uint64_t cgen_var_196;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_196, 1);
    stream->write((uint64_t*)&cgen_var_196, 1 * 8);
    uint64_t cgen_var_197;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_197, 1);
    stream->write((uint64_t*)&cgen_var_197, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_198 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_198);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroySemaphore readParams");
    AEMU_SCOPED_TRACE("vkDestroySemaphore returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkSemaphore((VkSemaphore*)&semaphore);
    mImpl->log("finish vkDestroySemaphore");;
}

VkResult VkEncoder::vkCreateEvent(
    VkDevice device,
    const VkEventCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent* pEvent)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateEvent encode");
    mImpl->log("start vkCreateEvent");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEventCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkEventCreateInfo*)pool->alloc(sizeof(const VkEventCreateInfo));
        deepcopy_VkEventCreateInfo(pool, pCreateInfo, (VkEventCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkEventCreateInfo(mImpl->resources(), (VkEventCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_199;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_199, 1);
        countingStream->write((uint64_t*)&cgen_var_199, 1 * 8);
        marshal_VkEventCreateInfo(countingStream, (VkEventCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_200 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_200);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_201;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(pEvent, &cgen_var_201, 1);
        countingStream->write((uint64_t*)&cgen_var_201, 8);
    }
    uint32_t packetSize_vkCreateEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateEvent = OP_vkCreateEvent;
    stream->write(&opcode_vkCreateEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateEvent, sizeof(uint32_t));
    uint64_t cgen_var_202;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_202, 1);
    stream->write((uint64_t*)&cgen_var_202, 1 * 8);
    marshal_VkEventCreateInfo(stream, (VkEventCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_203 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_203);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_204;
    stream->handleMapping()->mapHandles_VkEvent_u64(pEvent, &cgen_var_204, 1);
    stream->write((uint64_t*)&cgen_var_204, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateEvent readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_205;
    stream->read((uint64_t*)&cgen_var_205, 8);
    stream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_205, (VkEvent*)pEvent, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateEvent returnUnmarshal");
    VkResult vkCreateEvent_VkResult_return = (VkResult)0;
    stream->read(&vkCreateEvent_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateEvent");;
    return vkCreateEvent_VkResult_return;
}

void VkEncoder::vkDestroyEvent(
    VkDevice device,
    VkEvent event,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyEvent encode");
    mImpl->log("start vkDestroyEvent");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEvent local_event;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_event = event;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_206;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_206, 1);
        countingStream->write((uint64_t*)&cgen_var_206, 1 * 8);
        uint64_t cgen_var_207;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_207, 1);
        countingStream->write((uint64_t*)&cgen_var_207, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_208 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_208);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyEvent = OP_vkDestroyEvent;
    stream->write(&opcode_vkDestroyEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyEvent, sizeof(uint32_t));
    uint64_t cgen_var_209;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_209, 1);
    stream->write((uint64_t*)&cgen_var_209, 1 * 8);
    uint64_t cgen_var_210;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_210, 1);
    stream->write((uint64_t*)&cgen_var_210, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_211 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_211);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyEvent readParams");
    AEMU_SCOPED_TRACE("vkDestroyEvent returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkEvent((VkEvent*)&event);
    mImpl->log("finish vkDestroyEvent");;
}

VkResult VkEncoder::vkGetEventStatus(
    VkDevice device,
    VkEvent event)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetEventStatus encode");
    mImpl->log("start vkGetEventStatus");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    countingStream->rewind();
    {
        uint64_t cgen_var_212;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_212, 1);
        countingStream->write((uint64_t*)&cgen_var_212, 1 * 8);
        uint64_t cgen_var_213;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_213, 1);
        countingStream->write((uint64_t*)&cgen_var_213, 1 * 8);
    }
    uint32_t packetSize_vkGetEventStatus = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetEventStatus = OP_vkGetEventStatus;
    stream->write(&opcode_vkGetEventStatus, sizeof(uint32_t));
    stream->write(&packetSize_vkGetEventStatus, sizeof(uint32_t));
    uint64_t cgen_var_214;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_214, 1);
    stream->write((uint64_t*)&cgen_var_214, 1 * 8);
    uint64_t cgen_var_215;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_215, 1);
    stream->write((uint64_t*)&cgen_var_215, 1 * 8);
    AEMU_SCOPED_TRACE("vkGetEventStatus readParams");
    AEMU_SCOPED_TRACE("vkGetEventStatus returnUnmarshal");
    VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetEventStatus");;
    return vkGetEventStatus_VkResult_return;
}

VkResult VkEncoder::vkSetEvent(
    VkDevice device,
    VkEvent event)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkSetEvent encode");
    mImpl->log("start vkSetEvent");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    countingStream->rewind();
    {
        uint64_t cgen_var_216;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_216, 1);
        countingStream->write((uint64_t*)&cgen_var_216, 1 * 8);
        uint64_t cgen_var_217;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_217, 1);
        countingStream->write((uint64_t*)&cgen_var_217, 1 * 8);
    }
    uint32_t packetSize_vkSetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetEvent = OP_vkSetEvent;
    stream->write(&opcode_vkSetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkSetEvent, sizeof(uint32_t));
    uint64_t cgen_var_218;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_218, 1);
    stream->write((uint64_t*)&cgen_var_218, 1 * 8);
    uint64_t cgen_var_219;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_219, 1);
    stream->write((uint64_t*)&cgen_var_219, 1 * 8);
    AEMU_SCOPED_TRACE("vkSetEvent readParams");
    AEMU_SCOPED_TRACE("vkSetEvent returnUnmarshal");
    VkResult vkSetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkSetEvent_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkSetEvent");;
    return vkSetEvent_VkResult_return;
}

VkResult VkEncoder::vkResetEvent(
    VkDevice device,
    VkEvent event)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkResetEvent encode");
    mImpl->log("start vkResetEvent");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    countingStream->rewind();
    {
        uint64_t cgen_var_220;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_220, 1);
        countingStream->write((uint64_t*)&cgen_var_220, 1 * 8);
        uint64_t cgen_var_221;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_221, 1);
        countingStream->write((uint64_t*)&cgen_var_221, 1 * 8);
    }
    uint32_t packetSize_vkResetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetEvent = OP_vkResetEvent;
    stream->write(&opcode_vkResetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkResetEvent, sizeof(uint32_t));
    uint64_t cgen_var_222;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_222, 1);
    stream->write((uint64_t*)&cgen_var_222, 1 * 8);
    uint64_t cgen_var_223;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_223, 1);
    stream->write((uint64_t*)&cgen_var_223, 1 * 8);
    AEMU_SCOPED_TRACE("vkResetEvent readParams");
    AEMU_SCOPED_TRACE("vkResetEvent returnUnmarshal");
    VkResult vkResetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkResetEvent_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkResetEvent");;
    return vkResetEvent_VkResult_return;
}

VkResult VkEncoder::vkCreateQueryPool(
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool* pQueryPool)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateQueryPool encode");
    mImpl->log("start vkCreateQueryPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkQueryPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkQueryPoolCreateInfo*)pool->alloc(sizeof(const VkQueryPoolCreateInfo));
        deepcopy_VkQueryPoolCreateInfo(pool, pCreateInfo, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkQueryPoolCreateInfo(mImpl->resources(), (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_224;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_224, 1);
        countingStream->write((uint64_t*)&cgen_var_224, 1 * 8);
        marshal_VkQueryPoolCreateInfo(countingStream, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_225 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_225);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_226;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(pQueryPool, &cgen_var_226, 1);
        countingStream->write((uint64_t*)&cgen_var_226, 8);
    }
    uint32_t packetSize_vkCreateQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateQueryPool = OP_vkCreateQueryPool;
    stream->write(&opcode_vkCreateQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateQueryPool, sizeof(uint32_t));
    uint64_t cgen_var_227;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_227, 1);
    stream->write((uint64_t*)&cgen_var_227, 1 * 8);
    marshal_VkQueryPoolCreateInfo(stream, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_228 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_228);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_229;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(pQueryPool, &cgen_var_229, 1);
    stream->write((uint64_t*)&cgen_var_229, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateQueryPool readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_230;
    stream->read((uint64_t*)&cgen_var_230, 8);
    stream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_230, (VkQueryPool*)pQueryPool, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateQueryPool returnUnmarshal");
    VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateQueryPool");;
    return vkCreateQueryPool_VkResult_return;
}

void VkEncoder::vkDestroyQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyQueryPool encode");
    mImpl->log("start vkDestroyQueryPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkQueryPool local_queryPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_queryPool = queryPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_231;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_231, 1);
        countingStream->write((uint64_t*)&cgen_var_231, 1 * 8);
        uint64_t cgen_var_232;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_232, 1);
        countingStream->write((uint64_t*)&cgen_var_232, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_233 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_233);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyQueryPool = OP_vkDestroyQueryPool;
    stream->write(&opcode_vkDestroyQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyQueryPool, sizeof(uint32_t));
    uint64_t cgen_var_234;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_234, 1);
    stream->write((uint64_t*)&cgen_var_234, 1 * 8);
    uint64_t cgen_var_235;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_235, 1);
    stream->write((uint64_t*)&cgen_var_235, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_236 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_236);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyQueryPool readParams");
    AEMU_SCOPED_TRACE("vkDestroyQueryPool returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkQueryPool((VkQueryPool*)&queryPool);
    mImpl->log("finish vkDestroyQueryPool");;
}

VkResult VkEncoder::vkGetQueryPoolResults(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    size_t dataSize,
    void* pData,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetQueryPoolResults encode");
    mImpl->log("start vkGetQueryPoolResults");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    size_t local_dataSize;
    VkDeviceSize local_stride;
    VkQueryResultFlags local_flags;
    local_device = device;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    local_dataSize = dataSize;
    local_stride = stride;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_237;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_237, 1);
        countingStream->write((uint64_t*)&cgen_var_237, 1 * 8);
        uint64_t cgen_var_238;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_238, 1);
        countingStream->write((uint64_t*)&cgen_var_238, 1 * 8);
        countingStream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
        uint64_t cgen_var_239 = (uint64_t)local_dataSize;
        countingStream->putBe64(cgen_var_239);
        countingStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
        countingStream->write((VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
        countingStream->write((VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    }
    uint32_t packetSize_vkGetQueryPoolResults = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetQueryPoolResults = OP_vkGetQueryPoolResults;
    stream->write(&opcode_vkGetQueryPoolResults, sizeof(uint32_t));
    stream->write(&packetSize_vkGetQueryPoolResults, sizeof(uint32_t));
    uint64_t cgen_var_240;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_240, 1);
    stream->write((uint64_t*)&cgen_var_240, 1 * 8);
    uint64_t cgen_var_241;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_241, 1);
    stream->write((uint64_t*)&cgen_var_241, 1 * 8);
    stream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
    uint64_t cgen_var_242 = (uint64_t)local_dataSize;
    stream->putBe64(cgen_var_242);
    stream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
    stream->write((VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
    stream->write((VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    AEMU_SCOPED_TRACE("vkGetQueryPoolResults readParams");
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    AEMU_SCOPED_TRACE("vkGetQueryPoolResults returnUnmarshal");
    VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
    stream->read(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetQueryPoolResults");;
    return vkGetQueryPoolResults_VkResult_return;
}

VkResult VkEncoder::vkCreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateBuffer encode");
    mImpl->log("start vkCreateBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferCreateInfo*)pool->alloc(sizeof(const VkBufferCreateInfo));
        deepcopy_VkBufferCreateInfo(pool, pCreateInfo, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferCreateInfo(mImpl->resources(), (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_243;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_243, 1);
        countingStream->write((uint64_t*)&cgen_var_243, 1 * 8);
        marshal_VkBufferCreateInfo(countingStream, (VkBufferCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_244 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_244);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_245;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(pBuffer, &cgen_var_245, 1);
        countingStream->write((uint64_t*)&cgen_var_245, 8);
    }
    uint32_t packetSize_vkCreateBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateBuffer = OP_vkCreateBuffer;
    stream->write(&opcode_vkCreateBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateBuffer, sizeof(uint32_t));
    uint64_t cgen_var_246;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_246, 1);
    stream->write((uint64_t*)&cgen_var_246, 1 * 8);
    marshal_VkBufferCreateInfo(stream, (VkBufferCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_247 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_247);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_248;
    stream->handleMapping()->mapHandles_VkBuffer_u64(pBuffer, &cgen_var_248, 1);
    stream->write((uint64_t*)&cgen_var_248, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateBuffer readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_249;
    stream->read((uint64_t*)&cgen_var_249, 8);
    stream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_249, (VkBuffer*)pBuffer, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateBuffer returnUnmarshal");
    VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateBuffer");;
    return vkCreateBuffer_VkResult_return;
}

void VkEncoder::vkDestroyBuffer(
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyBuffer encode");
    mImpl->log("start vkDestroyBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBuffer local_buffer;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_buffer = buffer;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_250;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_250, 1);
        countingStream->write((uint64_t*)&cgen_var_250, 1 * 8);
        uint64_t cgen_var_251;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_251, 1);
        countingStream->write((uint64_t*)&cgen_var_251, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_252 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_252);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyBuffer = OP_vkDestroyBuffer;
    stream->write(&opcode_vkDestroyBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyBuffer, sizeof(uint32_t));
    uint64_t cgen_var_253;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_253, 1);
    stream->write((uint64_t*)&cgen_var_253, 1 * 8);
    uint64_t cgen_var_254;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_254, 1);
    stream->write((uint64_t*)&cgen_var_254, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_255 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_255);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyBuffer readParams");
    AEMU_SCOPED_TRACE("vkDestroyBuffer returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkBuffer((VkBuffer*)&buffer);
    mImpl->log("finish vkDestroyBuffer");;
}

VkResult VkEncoder::vkCreateBufferView(
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateBufferView encode");
    mImpl->log("start vkCreateBufferView");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferViewCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferViewCreateInfo*)pool->alloc(sizeof(const VkBufferViewCreateInfo));
        deepcopy_VkBufferViewCreateInfo(pool, pCreateInfo, (VkBufferViewCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferViewCreateInfo(mImpl->resources(), (VkBufferViewCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_256;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_256, 1);
        countingStream->write((uint64_t*)&cgen_var_256, 1 * 8);
        marshal_VkBufferViewCreateInfo(countingStream, (VkBufferViewCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_257 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_257);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_258;
        countingStream->handleMapping()->mapHandles_VkBufferView_u64(pView, &cgen_var_258, 1);
        countingStream->write((uint64_t*)&cgen_var_258, 8);
    }
    uint32_t packetSize_vkCreateBufferView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateBufferView = OP_vkCreateBufferView;
    stream->write(&opcode_vkCreateBufferView, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateBufferView, sizeof(uint32_t));
    uint64_t cgen_var_259;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_259, 1);
    stream->write((uint64_t*)&cgen_var_259, 1 * 8);
    marshal_VkBufferViewCreateInfo(stream, (VkBufferViewCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_260 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_260);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_261;
    stream->handleMapping()->mapHandles_VkBufferView_u64(pView, &cgen_var_261, 1);
    stream->write((uint64_t*)&cgen_var_261, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateBufferView readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_262;
    stream->read((uint64_t*)&cgen_var_262, 8);
    stream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_262, (VkBufferView*)pView, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateBufferView returnUnmarshal");
    VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateBufferView");;
    return vkCreateBufferView_VkResult_return;
}

void VkEncoder::vkDestroyBufferView(
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyBufferView encode");
    mImpl->log("start vkDestroyBufferView");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferView local_bufferView;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_bufferView = bufferView;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_263;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_263, 1);
        countingStream->write((uint64_t*)&cgen_var_263, 1 * 8);
        uint64_t cgen_var_264;
        countingStream->handleMapping()->mapHandles_VkBufferView_u64(&local_bufferView, &cgen_var_264, 1);
        countingStream->write((uint64_t*)&cgen_var_264, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_265 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_265);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyBufferView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyBufferView = OP_vkDestroyBufferView;
    stream->write(&opcode_vkDestroyBufferView, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyBufferView, sizeof(uint32_t));
    uint64_t cgen_var_266;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_266, 1);
    stream->write((uint64_t*)&cgen_var_266, 1 * 8);
    uint64_t cgen_var_267;
    stream->handleMapping()->mapHandles_VkBufferView_u64(&local_bufferView, &cgen_var_267, 1);
    stream->write((uint64_t*)&cgen_var_267, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_268 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_268);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyBufferView readParams");
    AEMU_SCOPED_TRACE("vkDestroyBufferView returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkBufferView((VkBufferView*)&bufferView);
    mImpl->log("finish vkDestroyBufferView");;
}

VkResult VkEncoder::vkCreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateImage encode");
    mImpl->log("start vkCreateImage");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageCreateInfo*)pool->alloc(sizeof(const VkImageCreateInfo));
        deepcopy_VkImageCreateInfo(pool, pCreateInfo, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    mImpl->resources()->unwrap_VkNativeBufferANDROID(pCreateInfo, local_pCreateInfo);
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageCreateInfo(mImpl->resources(), (VkImageCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_269;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_269, 1);
        countingStream->write((uint64_t*)&cgen_var_269, 1 * 8);
        marshal_VkImageCreateInfo(countingStream, (VkImageCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_270 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_270);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_271;
        countingStream->handleMapping()->mapHandles_VkImage_u64(pImage, &cgen_var_271, 1);
        countingStream->write((uint64_t*)&cgen_var_271, 8);
    }
    uint32_t packetSize_vkCreateImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateImage = OP_vkCreateImage;
    stream->write(&opcode_vkCreateImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateImage, sizeof(uint32_t));
    uint64_t cgen_var_272;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_272, 1);
    stream->write((uint64_t*)&cgen_var_272, 1 * 8);
    marshal_VkImageCreateInfo(stream, (VkImageCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_273 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_273);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_274;
    stream->handleMapping()->mapHandles_VkImage_u64(pImage, &cgen_var_274, 1);
    stream->write((uint64_t*)&cgen_var_274, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateImage readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_275;
    stream->read((uint64_t*)&cgen_var_275, 8);
    stream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_275, (VkImage*)pImage, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateImage returnUnmarshal");
    VkResult vkCreateImage_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImage_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateImage");;
    return vkCreateImage_VkResult_return;
}

void VkEncoder::vkDestroyImage(
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyImage encode");
    mImpl->log("start vkDestroyImage");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_image = image;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_276;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_276, 1);
        countingStream->write((uint64_t*)&cgen_var_276, 1 * 8);
        uint64_t cgen_var_277;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_277, 1);
        countingStream->write((uint64_t*)&cgen_var_277, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_278 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_278);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyImage = OP_vkDestroyImage;
    stream->write(&opcode_vkDestroyImage, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyImage, sizeof(uint32_t));
    uint64_t cgen_var_279;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_279, 1);
    stream->write((uint64_t*)&cgen_var_279, 1 * 8);
    uint64_t cgen_var_280;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_280, 1);
    stream->write((uint64_t*)&cgen_var_280, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_281 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_281);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyImage readParams");
    AEMU_SCOPED_TRACE("vkDestroyImage returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkImage((VkImage*)&image);
    mImpl->log("finish vkDestroyImage");;
}

void VkEncoder::vkGetImageSubresourceLayout(
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetImageSubresourceLayout encode");
    mImpl->log("start vkGetImageSubresourceLayout");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    VkImageSubresource* local_pSubresource;
    local_device = device;
    local_image = image;
    local_pSubresource = nullptr;
    if (pSubresource)
    {
        local_pSubresource = (VkImageSubresource*)pool->alloc(sizeof(const VkImageSubresource));
        deepcopy_VkImageSubresource(pool, pSubresource, (VkImageSubresource*)(local_pSubresource));
    }
    if (local_pSubresource)
    {
        transform_tohost_VkImageSubresource(mImpl->resources(), (VkImageSubresource*)(local_pSubresource));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_282;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_282, 1);
        countingStream->write((uint64_t*)&cgen_var_282, 1 * 8);
        uint64_t cgen_var_283;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_283, 1);
        countingStream->write((uint64_t*)&cgen_var_283, 1 * 8);
        marshal_VkImageSubresource(countingStream, (VkImageSubresource*)(local_pSubresource));
        marshal_VkSubresourceLayout(countingStream, (VkSubresourceLayout*)(pLayout));
    }
    uint32_t packetSize_vkGetImageSubresourceLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSubresourceLayout = OP_vkGetImageSubresourceLayout;
    stream->write(&opcode_vkGetImageSubresourceLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSubresourceLayout, sizeof(uint32_t));
    uint64_t cgen_var_284;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_284, 1);
    stream->write((uint64_t*)&cgen_var_284, 1 * 8);
    uint64_t cgen_var_285;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_285, 1);
    stream->write((uint64_t*)&cgen_var_285, 1 * 8);
    marshal_VkImageSubresource(stream, (VkImageSubresource*)(local_pSubresource));
    marshal_VkSubresourceLayout(stream, (VkSubresourceLayout*)(pLayout));
    AEMU_SCOPED_TRACE("vkGetImageSubresourceLayout readParams");
    unmarshal_VkSubresourceLayout(stream, (VkSubresourceLayout*)(pLayout));
    if (pLayout)
    {
        transform_fromhost_VkSubresourceLayout(mImpl->resources(), (VkSubresourceLayout*)(pLayout));
    }
    AEMU_SCOPED_TRACE("vkGetImageSubresourceLayout returnUnmarshal");
    mImpl->log("finish vkGetImageSubresourceLayout");;
}

VkResult VkEncoder::vkCreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateImageView encode");
    mImpl->log("start vkCreateImageView");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageViewCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageViewCreateInfo*)pool->alloc(sizeof(const VkImageViewCreateInfo));
        deepcopy_VkImageViewCreateInfo(pool, pCreateInfo, (VkImageViewCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageViewCreateInfo(mImpl->resources(), (VkImageViewCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_286;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_286, 1);
        countingStream->write((uint64_t*)&cgen_var_286, 1 * 8);
        marshal_VkImageViewCreateInfo(countingStream, (VkImageViewCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_287 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_287);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_288;
        countingStream->handleMapping()->mapHandles_VkImageView_u64(pView, &cgen_var_288, 1);
        countingStream->write((uint64_t*)&cgen_var_288, 8);
    }
    uint32_t packetSize_vkCreateImageView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateImageView = OP_vkCreateImageView;
    stream->write(&opcode_vkCreateImageView, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateImageView, sizeof(uint32_t));
    uint64_t cgen_var_289;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_289, 1);
    stream->write((uint64_t*)&cgen_var_289, 1 * 8);
    marshal_VkImageViewCreateInfo(stream, (VkImageViewCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_290 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_290);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_291;
    stream->handleMapping()->mapHandles_VkImageView_u64(pView, &cgen_var_291, 1);
    stream->write((uint64_t*)&cgen_var_291, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateImageView readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_292;
    stream->read((uint64_t*)&cgen_var_292, 8);
    stream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_292, (VkImageView*)pView, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateImageView returnUnmarshal");
    VkResult vkCreateImageView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImageView_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateImageView");;
    return vkCreateImageView_VkResult_return;
}

void VkEncoder::vkDestroyImageView(
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyImageView encode");
    mImpl->log("start vkDestroyImageView");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageView local_imageView;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_imageView = imageView;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_293;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_293, 1);
        countingStream->write((uint64_t*)&cgen_var_293, 1 * 8);
        uint64_t cgen_var_294;
        countingStream->handleMapping()->mapHandles_VkImageView_u64(&local_imageView, &cgen_var_294, 1);
        countingStream->write((uint64_t*)&cgen_var_294, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_295 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_295);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyImageView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyImageView = OP_vkDestroyImageView;
    stream->write(&opcode_vkDestroyImageView, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyImageView, sizeof(uint32_t));
    uint64_t cgen_var_296;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_296, 1);
    stream->write((uint64_t*)&cgen_var_296, 1 * 8);
    uint64_t cgen_var_297;
    stream->handleMapping()->mapHandles_VkImageView_u64(&local_imageView, &cgen_var_297, 1);
    stream->write((uint64_t*)&cgen_var_297, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_298 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_298);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyImageView readParams");
    AEMU_SCOPED_TRACE("vkDestroyImageView returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkImageView((VkImageView*)&imageView);
    mImpl->log("finish vkDestroyImageView");;
}

VkResult VkEncoder::vkCreateShaderModule(
    VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkShaderModule* pShaderModule)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateShaderModule encode");
    mImpl->log("start vkCreateShaderModule");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkShaderModuleCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkShaderModuleCreateInfo*)pool->alloc(sizeof(const VkShaderModuleCreateInfo));
        deepcopy_VkShaderModuleCreateInfo(pool, pCreateInfo, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkShaderModuleCreateInfo(mImpl->resources(), (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_299;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_299, 1);
        countingStream->write((uint64_t*)&cgen_var_299, 1 * 8);
        marshal_VkShaderModuleCreateInfo(countingStream, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_300 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_300);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_301;
        countingStream->handleMapping()->mapHandles_VkShaderModule_u64(pShaderModule, &cgen_var_301, 1);
        countingStream->write((uint64_t*)&cgen_var_301, 8);
    }
    uint32_t packetSize_vkCreateShaderModule = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateShaderModule = OP_vkCreateShaderModule;
    stream->write(&opcode_vkCreateShaderModule, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateShaderModule, sizeof(uint32_t));
    uint64_t cgen_var_302;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_302, 1);
    stream->write((uint64_t*)&cgen_var_302, 1 * 8);
    marshal_VkShaderModuleCreateInfo(stream, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_303 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_303);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_304;
    stream->handleMapping()->mapHandles_VkShaderModule_u64(pShaderModule, &cgen_var_304, 1);
    stream->write((uint64_t*)&cgen_var_304, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateShaderModule readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_305;
    stream->read((uint64_t*)&cgen_var_305, 8);
    stream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_305, (VkShaderModule*)pShaderModule, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateShaderModule returnUnmarshal");
    VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
    stream->read(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateShaderModule");;
    return vkCreateShaderModule_VkResult_return;
}

void VkEncoder::vkDestroyShaderModule(
    VkDevice device,
    VkShaderModule shaderModule,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyShaderModule encode");
    mImpl->log("start vkDestroyShaderModule");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkShaderModule local_shaderModule;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_shaderModule = shaderModule;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_306;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_306, 1);
        countingStream->write((uint64_t*)&cgen_var_306, 1 * 8);
        uint64_t cgen_var_307;
        countingStream->handleMapping()->mapHandles_VkShaderModule_u64(&local_shaderModule, &cgen_var_307, 1);
        countingStream->write((uint64_t*)&cgen_var_307, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_308 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_308);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyShaderModule = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyShaderModule = OP_vkDestroyShaderModule;
    stream->write(&opcode_vkDestroyShaderModule, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyShaderModule, sizeof(uint32_t));
    uint64_t cgen_var_309;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_309, 1);
    stream->write((uint64_t*)&cgen_var_309, 1 * 8);
    uint64_t cgen_var_310;
    stream->handleMapping()->mapHandles_VkShaderModule_u64(&local_shaderModule, &cgen_var_310, 1);
    stream->write((uint64_t*)&cgen_var_310, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_311 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_311);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyShaderModule readParams");
    AEMU_SCOPED_TRACE("vkDestroyShaderModule returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkShaderModule((VkShaderModule*)&shaderModule);
    mImpl->log("finish vkDestroyShaderModule");;
}

VkResult VkEncoder::vkCreatePipelineCache(
    VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreatePipelineCache encode");
    mImpl->log("start vkCreatePipelineCache");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCacheCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPipelineCacheCreateInfo*)pool->alloc(sizeof(const VkPipelineCacheCreateInfo));
        deepcopy_VkPipelineCacheCreateInfo(pool, pCreateInfo, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPipelineCacheCreateInfo(mImpl->resources(), (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_312;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_312, 1);
        countingStream->write((uint64_t*)&cgen_var_312, 1 * 8);
        marshal_VkPipelineCacheCreateInfo(countingStream, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_313 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_313);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_314;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(pPipelineCache, &cgen_var_314, 1);
        countingStream->write((uint64_t*)&cgen_var_314, 8);
    }
    uint32_t packetSize_vkCreatePipelineCache = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreatePipelineCache = OP_vkCreatePipelineCache;
    stream->write(&opcode_vkCreatePipelineCache, sizeof(uint32_t));
    stream->write(&packetSize_vkCreatePipelineCache, sizeof(uint32_t));
    uint64_t cgen_var_315;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_315, 1);
    stream->write((uint64_t*)&cgen_var_315, 1 * 8);
    marshal_VkPipelineCacheCreateInfo(stream, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_316 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_316);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_317;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(pPipelineCache, &cgen_var_317, 1);
    stream->write((uint64_t*)&cgen_var_317, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreatePipelineCache readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_318;
    stream->read((uint64_t*)&cgen_var_318, 8);
    stream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_318, (VkPipelineCache*)pPipelineCache, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreatePipelineCache returnUnmarshal");
    VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreatePipelineCache");;
    return vkCreatePipelineCache_VkResult_return;
}

void VkEncoder::vkDestroyPipelineCache(
    VkDevice device,
    VkPipelineCache pipelineCache,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyPipelineCache encode");
    mImpl->log("start vkDestroyPipelineCache");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_319;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_319, 1);
        countingStream->write((uint64_t*)&cgen_var_319, 1 * 8);
        uint64_t cgen_var_320;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_320, 1);
        countingStream->write((uint64_t*)&cgen_var_320, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_321 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_321);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipelineCache = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipelineCache = OP_vkDestroyPipelineCache;
    stream->write(&opcode_vkDestroyPipelineCache, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipelineCache, sizeof(uint32_t));
    uint64_t cgen_var_322;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_322, 1);
    stream->write((uint64_t*)&cgen_var_322, 1 * 8);
    uint64_t cgen_var_323;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_323, 1);
    stream->write((uint64_t*)&cgen_var_323, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_324 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_324);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyPipelineCache readParams");
    AEMU_SCOPED_TRACE("vkDestroyPipelineCache returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkPipelineCache((VkPipelineCache*)&pipelineCache);
    mImpl->log("finish vkDestroyPipelineCache");;
}

VkResult VkEncoder::vkGetPipelineCacheData(
    VkDevice device,
    VkPipelineCache pipelineCache,
    size_t* pDataSize,
    void* pData)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPipelineCacheData encode");
    mImpl->log("start vkGetPipelineCacheData");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    local_device = device;
    local_pipelineCache = pipelineCache;
    countingStream->rewind();
    {
        uint64_t cgen_var_325;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_325, 1);
        countingStream->write((uint64_t*)&cgen_var_325, 1 * 8);
        uint64_t cgen_var_326;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_326, 1);
        countingStream->write((uint64_t*)&cgen_var_326, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_327 = (uint64_t)(uintptr_t)pDataSize;
        countingStream->putBe64(cgen_var_327);
        if (pDataSize)
        {
            uint64_t cgen_var_328 = (uint64_t)(*pDataSize);
            countingStream->putBe64(cgen_var_328);
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_329 = (uint64_t)(uintptr_t)pData;
        countingStream->putBe64(cgen_var_329);
        if (pData)
        {
            countingStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetPipelineCacheData = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPipelineCacheData = OP_vkGetPipelineCacheData;
    stream->write(&opcode_vkGetPipelineCacheData, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPipelineCacheData, sizeof(uint32_t));
    uint64_t cgen_var_330;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_330, 1);
    stream->write((uint64_t*)&cgen_var_330, 1 * 8);
    uint64_t cgen_var_331;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_331, 1);
    stream->write((uint64_t*)&cgen_var_331, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_332 = (uint64_t)(uintptr_t)pDataSize;
    stream->putBe64(cgen_var_332);
    if (pDataSize)
    {
        uint64_t cgen_var_333 = (uint64_t)(*pDataSize);
        stream->putBe64(cgen_var_333);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_334 = (uint64_t)(uintptr_t)pData;
    stream->putBe64(cgen_var_334);
    if (pData)
    {
        stream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkGetPipelineCacheData readParams");
    // WARNING PTR CHECK
    size_t* check_pDataSize;
    check_pDataSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        (*pDataSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pData;
    check_pData = (void*)(uintptr_t)stream->getBe64();
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkGetPipelineCacheData returnUnmarshal");
    VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
    stream->read(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPipelineCacheData");;
    return vkGetPipelineCacheData_VkResult_return;
}

VkResult VkEncoder::vkMergePipelineCaches(
    VkDevice device,
    VkPipelineCache dstCache,
    uint32_t srcCacheCount,
    const VkPipelineCache* pSrcCaches)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkMergePipelineCaches encode");
    mImpl->log("start vkMergePipelineCaches");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_dstCache;
    uint32_t local_srcCacheCount;
    VkPipelineCache* local_pSrcCaches;
    local_device = device;
    local_dstCache = dstCache;
    local_srcCacheCount = srcCacheCount;
    local_pSrcCaches = nullptr;
    if (pSrcCaches)
    {
        local_pSrcCaches = (VkPipelineCache*)pool->dupArray(pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_338;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_338, 1);
        countingStream->write((uint64_t*)&cgen_var_338, 1 * 8);
        uint64_t cgen_var_339;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_dstCache, &cgen_var_339, 1);
        countingStream->write((uint64_t*)&cgen_var_339, 1 * 8);
        countingStream->write((uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
        if (((srcCacheCount)))
        {
            uint64_t* cgen_var_340;
            countingStream->alloc((void**)&cgen_var_340, ((srcCacheCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(local_pSrcCaches, cgen_var_340, ((srcCacheCount)));
            countingStream->write((uint64_t*)cgen_var_340, ((srcCacheCount)) * 8);
        }
    }
    uint32_t packetSize_vkMergePipelineCaches = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMergePipelineCaches = OP_vkMergePipelineCaches;
    stream->write(&opcode_vkMergePipelineCaches, sizeof(uint32_t));
    stream->write(&packetSize_vkMergePipelineCaches, sizeof(uint32_t));
    uint64_t cgen_var_341;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_341, 1);
    stream->write((uint64_t*)&cgen_var_341, 1 * 8);
    uint64_t cgen_var_342;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_dstCache, &cgen_var_342, 1);
    stream->write((uint64_t*)&cgen_var_342, 1 * 8);
    stream->write((uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
    if (((srcCacheCount)))
    {
        uint64_t* cgen_var_343;
        stream->alloc((void**)&cgen_var_343, ((srcCacheCount)) * 8);
        stream->handleMapping()->mapHandles_VkPipelineCache_u64(local_pSrcCaches, cgen_var_343, ((srcCacheCount)));
        stream->write((uint64_t*)cgen_var_343, ((srcCacheCount)) * 8);
    }
    AEMU_SCOPED_TRACE("vkMergePipelineCaches readParams");
    AEMU_SCOPED_TRACE("vkMergePipelineCaches returnUnmarshal");
    VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
    stream->read(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkMergePipelineCaches");;
    return vkMergePipelineCaches_VkResult_return;
}

VkResult VkEncoder::vkCreateGraphicsPipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateGraphicsPipelines encode");
    mImpl->log("start vkCreateGraphicsPipelines");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkGraphicsPipelineCreateInfo* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkGraphicsPipelineCreateInfo*)pool->alloc(((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkGraphicsPipelineCreateInfo(pool, pCreateInfos + i, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkGraphicsPipelineCreateInfo(mImpl->resources(), (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_344;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_344, 1);
        countingStream->write((uint64_t*)&cgen_var_344, 1 * 8);
        uint64_t cgen_var_345;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_345, 1);
        countingStream->write((uint64_t*)&cgen_var_345, 1 * 8);
        countingStream->write((uint32_t*)&local_createInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            marshal_VkGraphicsPipelineCreateInfo(countingStream, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_346 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_346);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        if (((createInfoCount)))
        {
            uint64_t* cgen_var_347;
            countingStream->alloc((void**)&cgen_var_347, ((createInfoCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_347, ((createInfoCount)));
            countingStream->write((uint64_t*)cgen_var_347, ((createInfoCount)) * 8);
        }
    }
    uint32_t packetSize_vkCreateGraphicsPipelines = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateGraphicsPipelines = OP_vkCreateGraphicsPipelines;
    stream->write(&opcode_vkCreateGraphicsPipelines, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateGraphicsPipelines, sizeof(uint32_t));
    uint64_t cgen_var_348;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_348, 1);
    stream->write((uint64_t*)&cgen_var_348, 1 * 8);
    uint64_t cgen_var_349;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_349, 1);
    stream->write((uint64_t*)&cgen_var_349, 1 * 8);
    stream->write((uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        marshal_VkGraphicsPipelineCreateInfo(stream, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_350 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_350);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_351;
        stream->alloc((void**)&cgen_var_351, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_351, ((createInfoCount)));
        stream->write((uint64_t*)cgen_var_351, ((createInfoCount)) * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateGraphicsPipelines readParams");
    stream->setHandleMapping(resources->createMapping());
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_352;
        stream->alloc((void**)&cgen_var_352, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_352, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_352, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateGraphicsPipelines returnUnmarshal");
    VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateGraphicsPipelines");;
    return vkCreateGraphicsPipelines_VkResult_return;
}

VkResult VkEncoder::vkCreateComputePipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateComputePipelines encode");
    mImpl->log("start vkCreateComputePipelines");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkComputePipelineCreateInfo* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkComputePipelineCreateInfo*)pool->alloc(((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkComputePipelineCreateInfo(pool, pCreateInfos + i, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkComputePipelineCreateInfo(mImpl->resources(), (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_353;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_353, 1);
        countingStream->write((uint64_t*)&cgen_var_353, 1 * 8);
        uint64_t cgen_var_354;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_354, 1);
        countingStream->write((uint64_t*)&cgen_var_354, 1 * 8);
        countingStream->write((uint32_t*)&local_createInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            marshal_VkComputePipelineCreateInfo(countingStream, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_355 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_355);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        if (((createInfoCount)))
        {
            uint64_t* cgen_var_356;
            countingStream->alloc((void**)&cgen_var_356, ((createInfoCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_356, ((createInfoCount)));
            countingStream->write((uint64_t*)cgen_var_356, ((createInfoCount)) * 8);
        }
    }
    uint32_t packetSize_vkCreateComputePipelines = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateComputePipelines = OP_vkCreateComputePipelines;
    stream->write(&opcode_vkCreateComputePipelines, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateComputePipelines, sizeof(uint32_t));
    uint64_t cgen_var_357;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_357, 1);
    stream->write((uint64_t*)&cgen_var_357, 1 * 8);
    uint64_t cgen_var_358;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_358, 1);
    stream->write((uint64_t*)&cgen_var_358, 1 * 8);
    stream->write((uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        marshal_VkComputePipelineCreateInfo(stream, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_359 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_359);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_360;
        stream->alloc((void**)&cgen_var_360, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_360, ((createInfoCount)));
        stream->write((uint64_t*)cgen_var_360, ((createInfoCount)) * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateComputePipelines readParams");
    stream->setHandleMapping(resources->createMapping());
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_361;
        stream->alloc((void**)&cgen_var_361, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_361, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_361, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateComputePipelines returnUnmarshal");
    VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateComputePipelines");;
    return vkCreateComputePipelines_VkResult_return;
}

void VkEncoder::vkDestroyPipeline(
    VkDevice device,
    VkPipeline pipeline,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyPipeline encode");
    mImpl->log("start vkDestroyPipeline");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipeline local_pipeline;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipeline = pipeline;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_362;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_362, 1);
        countingStream->write((uint64_t*)&cgen_var_362, 1 * 8);
        uint64_t cgen_var_363;
        countingStream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_363, 1);
        countingStream->write((uint64_t*)&cgen_var_363, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_364 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_364);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipeline = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipeline = OP_vkDestroyPipeline;
    stream->write(&opcode_vkDestroyPipeline, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipeline, sizeof(uint32_t));
    uint64_t cgen_var_365;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_365, 1);
    stream->write((uint64_t*)&cgen_var_365, 1 * 8);
    uint64_t cgen_var_366;
    stream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_366, 1);
    stream->write((uint64_t*)&cgen_var_366, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_367 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_367);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyPipeline readParams");
    AEMU_SCOPED_TRACE("vkDestroyPipeline returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkPipeline((VkPipeline*)&pipeline);
    mImpl->log("finish vkDestroyPipeline");;
}

VkResult VkEncoder::vkCreatePipelineLayout(
    VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreatePipelineLayout encode");
    mImpl->log("start vkCreatePipelineLayout");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineLayoutCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPipelineLayoutCreateInfo*)pool->alloc(sizeof(const VkPipelineLayoutCreateInfo));
        deepcopy_VkPipelineLayoutCreateInfo(pool, pCreateInfo, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPipelineLayoutCreateInfo(mImpl->resources(), (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_368;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_368, 1);
        countingStream->write((uint64_t*)&cgen_var_368, 1 * 8);
        marshal_VkPipelineLayoutCreateInfo(countingStream, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_369 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_369);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_370;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(pPipelineLayout, &cgen_var_370, 1);
        countingStream->write((uint64_t*)&cgen_var_370, 8);
    }
    uint32_t packetSize_vkCreatePipelineLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreatePipelineLayout = OP_vkCreatePipelineLayout;
    stream->write(&opcode_vkCreatePipelineLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkCreatePipelineLayout, sizeof(uint32_t));
    uint64_t cgen_var_371;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_371, 1);
    stream->write((uint64_t*)&cgen_var_371, 1 * 8);
    marshal_VkPipelineLayoutCreateInfo(stream, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_372 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_372);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_373;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(pPipelineLayout, &cgen_var_373, 1);
    stream->write((uint64_t*)&cgen_var_373, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreatePipelineLayout readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_374;
    stream->read((uint64_t*)&cgen_var_374, 8);
    stream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_374, (VkPipelineLayout*)pPipelineLayout, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreatePipelineLayout returnUnmarshal");
    VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreatePipelineLayout");;
    return vkCreatePipelineLayout_VkResult_return;
}

void VkEncoder::vkDestroyPipelineLayout(
    VkDevice device,
    VkPipelineLayout pipelineLayout,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyPipelineLayout encode");
    mImpl->log("start vkDestroyPipelineLayout");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineLayout local_pipelineLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineLayout = pipelineLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_375;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_375, 1);
        countingStream->write((uint64_t*)&cgen_var_375, 1 * 8);
        uint64_t cgen_var_376;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_pipelineLayout, &cgen_var_376, 1);
        countingStream->write((uint64_t*)&cgen_var_376, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_377 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_377);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipelineLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipelineLayout = OP_vkDestroyPipelineLayout;
    stream->write(&opcode_vkDestroyPipelineLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipelineLayout, sizeof(uint32_t));
    uint64_t cgen_var_378;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_378, 1);
    stream->write((uint64_t*)&cgen_var_378, 1 * 8);
    uint64_t cgen_var_379;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_pipelineLayout, &cgen_var_379, 1);
    stream->write((uint64_t*)&cgen_var_379, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_380 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_380);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyPipelineLayout readParams");
    AEMU_SCOPED_TRACE("vkDestroyPipelineLayout returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkPipelineLayout((VkPipelineLayout*)&pipelineLayout);
    mImpl->log("finish vkDestroyPipelineLayout");;
}

VkResult VkEncoder::vkCreateSampler(
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateSampler encode");
    mImpl->log("start vkCreateSampler");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerCreateInfo*)pool->alloc(sizeof(const VkSamplerCreateInfo));
        deepcopy_VkSamplerCreateInfo(pool, pCreateInfo, (VkSamplerCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerCreateInfo(mImpl->resources(), (VkSamplerCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_381;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_381, 1);
        countingStream->write((uint64_t*)&cgen_var_381, 1 * 8);
        marshal_VkSamplerCreateInfo(countingStream, (VkSamplerCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_382 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_382);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_383;
        countingStream->handleMapping()->mapHandles_VkSampler_u64(pSampler, &cgen_var_383, 1);
        countingStream->write((uint64_t*)&cgen_var_383, 8);
    }
    uint32_t packetSize_vkCreateSampler = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSampler = OP_vkCreateSampler;
    stream->write(&opcode_vkCreateSampler, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSampler, sizeof(uint32_t));
    uint64_t cgen_var_384;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_384, 1);
    stream->write((uint64_t*)&cgen_var_384, 1 * 8);
    marshal_VkSamplerCreateInfo(stream, (VkSamplerCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_385 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_385);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_386;
    stream->handleMapping()->mapHandles_VkSampler_u64(pSampler, &cgen_var_386, 1);
    stream->write((uint64_t*)&cgen_var_386, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateSampler readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_387;
    stream->read((uint64_t*)&cgen_var_387, 8);
    stream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_387, (VkSampler*)pSampler, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateSampler returnUnmarshal");
    VkResult vkCreateSampler_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSampler_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateSampler");;
    return vkCreateSampler_VkResult_return;
}

void VkEncoder::vkDestroySampler(
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroySampler encode");
    mImpl->log("start vkDestroySampler");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSampler local_sampler;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_sampler = sampler;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_388;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_388, 1);
        countingStream->write((uint64_t*)&cgen_var_388, 1 * 8);
        uint64_t cgen_var_389;
        countingStream->handleMapping()->mapHandles_VkSampler_u64(&local_sampler, &cgen_var_389, 1);
        countingStream->write((uint64_t*)&cgen_var_389, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_390 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_390);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySampler = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySampler = OP_vkDestroySampler;
    stream->write(&opcode_vkDestroySampler, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySampler, sizeof(uint32_t));
    uint64_t cgen_var_391;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_391, 1);
    stream->write((uint64_t*)&cgen_var_391, 1 * 8);
    uint64_t cgen_var_392;
    stream->handleMapping()->mapHandles_VkSampler_u64(&local_sampler, &cgen_var_392, 1);
    stream->write((uint64_t*)&cgen_var_392, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_393 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_393);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroySampler readParams");
    AEMU_SCOPED_TRACE("vkDestroySampler returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkSampler((VkSampler*)&sampler);
    mImpl->log("finish vkDestroySampler");;
}

VkResult VkEncoder::vkCreateDescriptorSetLayout(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDescriptorSetLayout encode");
    mImpl->log("start vkCreateDescriptorSetLayout");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(mImpl->resources(), (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_394;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_394, 1);
        countingStream->write((uint64_t*)&cgen_var_394, 1 * 8);
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_395 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_395);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_396;
        countingStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(pSetLayout, &cgen_var_396, 1);
        countingStream->write((uint64_t*)&cgen_var_396, 8);
    }
    uint32_t packetSize_vkCreateDescriptorSetLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorSetLayout = OP_vkCreateDescriptorSetLayout;
    stream->write(&opcode_vkCreateDescriptorSetLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorSetLayout, sizeof(uint32_t));
    uint64_t cgen_var_397;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_397, 1);
    stream->write((uint64_t*)&cgen_var_397, 1 * 8);
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_398 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_398);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_399;
    stream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(pSetLayout, &cgen_var_399, 1);
    stream->write((uint64_t*)&cgen_var_399, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDescriptorSetLayout readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_400;
    stream->read((uint64_t*)&cgen_var_400, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_400, (VkDescriptorSetLayout*)pSetLayout, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateDescriptorSetLayout returnUnmarshal");
    VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateDescriptorSetLayout");;
    return vkCreateDescriptorSetLayout_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorSetLayout(
    VkDevice device,
    VkDescriptorSetLayout descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyDescriptorSetLayout encode");
    mImpl->log("start vkDestroyDescriptorSetLayout");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetLayout local_descriptorSetLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorSetLayout = descriptorSetLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_401;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_401, 1);
        countingStream->write((uint64_t*)&cgen_var_401, 1 * 8);
        uint64_t cgen_var_402;
        countingStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(&local_descriptorSetLayout, &cgen_var_402, 1);
        countingStream->write((uint64_t*)&cgen_var_402, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_403 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_403);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorSetLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorSetLayout = OP_vkDestroyDescriptorSetLayout;
    stream->write(&opcode_vkDestroyDescriptorSetLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorSetLayout, sizeof(uint32_t));
    uint64_t cgen_var_404;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_404, 1);
    stream->write((uint64_t*)&cgen_var_404, 1 * 8);
    uint64_t cgen_var_405;
    stream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(&local_descriptorSetLayout, &cgen_var_405, 1);
    stream->write((uint64_t*)&cgen_var_405, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_406 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_406);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyDescriptorSetLayout readParams");
    AEMU_SCOPED_TRACE("vkDestroyDescriptorSetLayout returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)&descriptorSetLayout);
    mImpl->log("finish vkDestroyDescriptorSetLayout");;
}

VkResult VkEncoder::vkCreateDescriptorPool(
    VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDescriptorPool encode");
    mImpl->log("start vkCreateDescriptorPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorPoolCreateInfo*)pool->alloc(sizeof(const VkDescriptorPoolCreateInfo));
        deepcopy_VkDescriptorPoolCreateInfo(pool, pCreateInfo, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorPoolCreateInfo(mImpl->resources(), (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_407;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_407, 1);
        countingStream->write((uint64_t*)&cgen_var_407, 1 * 8);
        marshal_VkDescriptorPoolCreateInfo(countingStream, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_408 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_408);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_409;
        countingStream->handleMapping()->mapHandles_VkDescriptorPool_u64(pDescriptorPool, &cgen_var_409, 1);
        countingStream->write((uint64_t*)&cgen_var_409, 8);
    }
    uint32_t packetSize_vkCreateDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorPool = OP_vkCreateDescriptorPool;
    stream->write(&opcode_vkCreateDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorPool, sizeof(uint32_t));
    uint64_t cgen_var_410;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_410, 1);
    stream->write((uint64_t*)&cgen_var_410, 1 * 8);
    marshal_VkDescriptorPoolCreateInfo(stream, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_411 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_411);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_412;
    stream->handleMapping()->mapHandles_VkDescriptorPool_u64(pDescriptorPool, &cgen_var_412, 1);
    stream->write((uint64_t*)&cgen_var_412, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDescriptorPool readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_413;
    stream->read((uint64_t*)&cgen_var_413, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_413, (VkDescriptorPool*)pDescriptorPool, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateDescriptorPool returnUnmarshal");
    VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateDescriptorPool");;
    return vkCreateDescriptorPool_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyDescriptorPool encode");
    mImpl->log("start vkDestroyDescriptorPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_414;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_414, 1);
        countingStream->write((uint64_t*)&cgen_var_414, 1 * 8);
        uint64_t cgen_var_415;
        countingStream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_415, 1);
        countingStream->write((uint64_t*)&cgen_var_415, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_416 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_416);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorPool = OP_vkDestroyDescriptorPool;
    stream->write(&opcode_vkDestroyDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorPool, sizeof(uint32_t));
    uint64_t cgen_var_417;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_417, 1);
    stream->write((uint64_t*)&cgen_var_417, 1 * 8);
    uint64_t cgen_var_418;
    stream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_418, 1);
    stream->write((uint64_t*)&cgen_var_418, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_419 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_419);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyDescriptorPool readParams");
    AEMU_SCOPED_TRACE("vkDestroyDescriptorPool returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkDescriptorPool((VkDescriptorPool*)&descriptorPool);
    mImpl->log("finish vkDestroyDescriptorPool");;
}

VkResult VkEncoder::vkResetDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    VkDescriptorPoolResetFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkResetDescriptorPool encode");
    mImpl->log("start vkResetDescriptorPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    VkDescriptorPoolResetFlags local_flags;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_420;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_420, 1);
        countingStream->write((uint64_t*)&cgen_var_420, 1 * 8);
        uint64_t cgen_var_421;
        countingStream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_421, 1);
        countingStream->write((uint64_t*)&cgen_var_421, 1 * 8);
        countingStream->write((VkDescriptorPoolResetFlags*)&local_flags, sizeof(VkDescriptorPoolResetFlags));
    }
    uint32_t packetSize_vkResetDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetDescriptorPool = OP_vkResetDescriptorPool;
    stream->write(&opcode_vkResetDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkResetDescriptorPool, sizeof(uint32_t));
    uint64_t cgen_var_422;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_422, 1);
    stream->write((uint64_t*)&cgen_var_422, 1 * 8);
    uint64_t cgen_var_423;
    stream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_423, 1);
    stream->write((uint64_t*)&cgen_var_423, 1 * 8);
    stream->write((VkDescriptorPoolResetFlags*)&local_flags, sizeof(VkDescriptorPoolResetFlags));
    AEMU_SCOPED_TRACE("vkResetDescriptorPool readParams");
    AEMU_SCOPED_TRACE("vkResetDescriptorPool returnUnmarshal");
    VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkResetDescriptorPool");;
    return vkResetDescriptorPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateDescriptorSets(
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet* pDescriptorSets)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkAllocateDescriptorSets encode");
    mImpl->log("start vkAllocateDescriptorSets");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetAllocateInfo* local_pAllocateInfo;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkDescriptorSetAllocateInfo*)pool->alloc(sizeof(const VkDescriptorSetAllocateInfo));
        deepcopy_VkDescriptorSetAllocateInfo(pool, pAllocateInfo, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocateInfo)
    {
        transform_tohost_VkDescriptorSetAllocateInfo(mImpl->resources(), (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_424;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_424, 1);
        countingStream->write((uint64_t*)&cgen_var_424, 1 * 8);
        marshal_VkDescriptorSetAllocateInfo(countingStream, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
        if (pAllocateInfo->descriptorSetCount)
        {
            uint64_t* cgen_var_425;
            countingStream->alloc((void**)&cgen_var_425, pAllocateInfo->descriptorSetCount * 8);
            countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(pDescriptorSets, cgen_var_425, pAllocateInfo->descriptorSetCount);
            countingStream->write((uint64_t*)cgen_var_425, pAllocateInfo->descriptorSetCount * 8);
        }
    }
    uint32_t packetSize_vkAllocateDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateDescriptorSets = OP_vkAllocateDescriptorSets;
    stream->write(&opcode_vkAllocateDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateDescriptorSets, sizeof(uint32_t));
    uint64_t cgen_var_426;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_426, 1);
    stream->write((uint64_t*)&cgen_var_426, 1 * 8);
    marshal_VkDescriptorSetAllocateInfo(stream, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (pAllocateInfo->descriptorSetCount)
    {
        uint64_t* cgen_var_427;
        stream->alloc((void**)&cgen_var_427, pAllocateInfo->descriptorSetCount * 8);
        stream->handleMapping()->mapHandles_VkDescriptorSet_u64(pDescriptorSets, cgen_var_427, pAllocateInfo->descriptorSetCount);
        stream->write((uint64_t*)cgen_var_427, pAllocateInfo->descriptorSetCount * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkAllocateDescriptorSets readParams");
    stream->setHandleMapping(resources->createMapping());
    if (pAllocateInfo->descriptorSetCount)
    {
        uint64_t* cgen_var_428;
        stream->alloc((void**)&cgen_var_428, pAllocateInfo->descriptorSetCount * 8);
        stream->read((uint64_t*)cgen_var_428, pAllocateInfo->descriptorSetCount * 8);
        stream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_428, (VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
    }
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkAllocateDescriptorSets returnUnmarshal");
    VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkAllocateDescriptorSets");;
    return vkAllocateDescriptorSets_VkResult_return;
}

VkResult VkEncoder::vkFreeDescriptorSets(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkFreeDescriptorSets encode");
    mImpl->log("start vkFreeDescriptorSets");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    uint32_t local_descriptorSetCount;
    VkDescriptorSet* local_pDescriptorSets;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_descriptorSetCount = descriptorSetCount;
    local_pDescriptorSets = nullptr;
    if (pDescriptorSets)
    {
        local_pDescriptorSets = (VkDescriptorSet*)pool->dupArray(pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_429;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_429, 1);
        countingStream->write((uint64_t*)&cgen_var_429, 1 * 8);
        uint64_t cgen_var_430;
        countingStream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_430, 1);
        countingStream->write((uint64_t*)&cgen_var_430, 1 * 8);
        countingStream->write((uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_431 = (uint64_t)(uintptr_t)local_pDescriptorSets;
        countingStream->putBe64(cgen_var_431);
        if (local_pDescriptorSets)
        {
            if (((descriptorSetCount)))
            {
                uint64_t* cgen_var_432;
                countingStream->alloc((void**)&cgen_var_432, ((descriptorSetCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(local_pDescriptorSets, cgen_var_432, ((descriptorSetCount)));
                countingStream->write((uint64_t*)cgen_var_432, ((descriptorSetCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkFreeDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeDescriptorSets = OP_vkFreeDescriptorSets;
    stream->write(&opcode_vkFreeDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeDescriptorSets, sizeof(uint32_t));
    uint64_t cgen_var_433;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_433, 1);
    stream->write((uint64_t*)&cgen_var_433, 1 * 8);
    uint64_t cgen_var_434;
    stream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_434, 1);
    stream->write((uint64_t*)&cgen_var_434, 1 * 8);
    stream->write((uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_435 = (uint64_t)(uintptr_t)local_pDescriptorSets;
    stream->putBe64(cgen_var_435);
    if (local_pDescriptorSets)
    {
        if (((descriptorSetCount)))
        {
            uint64_t* cgen_var_436;
            stream->alloc((void**)&cgen_var_436, ((descriptorSetCount)) * 8);
            stream->handleMapping()->mapHandles_VkDescriptorSet_u64(local_pDescriptorSets, cgen_var_436, ((descriptorSetCount)));
            stream->write((uint64_t*)cgen_var_436, ((descriptorSetCount)) * 8);
        }
    }
    AEMU_SCOPED_TRACE("vkFreeDescriptorSets readParams");
    AEMU_SCOPED_TRACE("vkFreeDescriptorSets returnUnmarshal");
    VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    if (pDescriptorSets)
    {
        resources->destroyMapping()->mapHandles_VkDescriptorSet((VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
    }
    mImpl->log("finish vkFreeDescriptorSets");;
    return vkFreeDescriptorSets_VkResult_return;
}

void VkEncoder::vkUpdateDescriptorSets(
    VkDevice device,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSets encode");
    mImpl->log("start vkUpdateDescriptorSets");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_descriptorWriteCount;
    VkWriteDescriptorSet* local_pDescriptorWrites;
    uint32_t local_descriptorCopyCount;
    VkCopyDescriptorSet* local_pDescriptorCopies;
    local_device = device;
    local_descriptorWriteCount = descriptorWriteCount;
    local_pDescriptorWrites = nullptr;
    if (pDescriptorWrites)
    {
        local_pDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, pDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    local_descriptorCopyCount = descriptorCopyCount;
    local_pDescriptorCopies = nullptr;
    if (pDescriptorCopies)
    {
        local_pDescriptorCopies = (VkCopyDescriptorSet*)pool->alloc(((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            deepcopy_VkCopyDescriptorSet(pool, pDescriptorCopies + i, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    if (local_pDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(mImpl->resources(), (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    if (local_pDescriptorCopies)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            transform_tohost_VkCopyDescriptorSet(mImpl->resources(), (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_437;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_437, 1);
        countingStream->write((uint64_t*)&cgen_var_437, 1 * 8);
        countingStream->write((uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            marshal_VkWriteDescriptorSet(countingStream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
        countingStream->write((uint32_t*)&local_descriptorCopyCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            marshal_VkCopyDescriptorSet(countingStream, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSets = OP_vkUpdateDescriptorSets;
    stream->write(&opcode_vkUpdateDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSets, sizeof(uint32_t));
    uint64_t cgen_var_438;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_438, 1);
    stream->write((uint64_t*)&cgen_var_438, 1 * 8);
    stream->write((uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        marshal_VkWriteDescriptorSet(stream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
    }
    stream->write((uint32_t*)&local_descriptorCopyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
    {
        marshal_VkCopyDescriptorSet(stream, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSets readParams");
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSets returnUnmarshal");
    mImpl->log("finish vkUpdateDescriptorSets");;
}

VkResult VkEncoder::vkCreateFramebuffer(
    VkDevice device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFramebuffer* pFramebuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateFramebuffer encode");
    mImpl->log("start vkCreateFramebuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFramebufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkFramebufferCreateInfo*)pool->alloc(sizeof(const VkFramebufferCreateInfo));
        deepcopy_VkFramebufferCreateInfo(pool, pCreateInfo, (VkFramebufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkFramebufferCreateInfo(mImpl->resources(), (VkFramebufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_439;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_439, 1);
        countingStream->write((uint64_t*)&cgen_var_439, 1 * 8);
        marshal_VkFramebufferCreateInfo(countingStream, (VkFramebufferCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_440 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_440);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_441;
        countingStream->handleMapping()->mapHandles_VkFramebuffer_u64(pFramebuffer, &cgen_var_441, 1);
        countingStream->write((uint64_t*)&cgen_var_441, 8);
    }
    uint32_t packetSize_vkCreateFramebuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateFramebuffer = OP_vkCreateFramebuffer;
    stream->write(&opcode_vkCreateFramebuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateFramebuffer, sizeof(uint32_t));
    uint64_t cgen_var_442;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_442, 1);
    stream->write((uint64_t*)&cgen_var_442, 1 * 8);
    marshal_VkFramebufferCreateInfo(stream, (VkFramebufferCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_443 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_443);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_444;
    stream->handleMapping()->mapHandles_VkFramebuffer_u64(pFramebuffer, &cgen_var_444, 1);
    stream->write((uint64_t*)&cgen_var_444, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateFramebuffer readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_445;
    stream->read((uint64_t*)&cgen_var_445, 8);
    stream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_445, (VkFramebuffer*)pFramebuffer, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateFramebuffer returnUnmarshal");
    VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateFramebuffer");;
    return vkCreateFramebuffer_VkResult_return;
}

void VkEncoder::vkDestroyFramebuffer(
    VkDevice device,
    VkFramebuffer framebuffer,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyFramebuffer encode");
    mImpl->log("start vkDestroyFramebuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFramebuffer local_framebuffer;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_framebuffer = framebuffer;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_446;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_446, 1);
        countingStream->write((uint64_t*)&cgen_var_446, 1 * 8);
        uint64_t cgen_var_447;
        countingStream->handleMapping()->mapHandles_VkFramebuffer_u64(&local_framebuffer, &cgen_var_447, 1);
        countingStream->write((uint64_t*)&cgen_var_447, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_448 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_448);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyFramebuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyFramebuffer = OP_vkDestroyFramebuffer;
    stream->write(&opcode_vkDestroyFramebuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyFramebuffer, sizeof(uint32_t));
    uint64_t cgen_var_449;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_449, 1);
    stream->write((uint64_t*)&cgen_var_449, 1 * 8);
    uint64_t cgen_var_450;
    stream->handleMapping()->mapHandles_VkFramebuffer_u64(&local_framebuffer, &cgen_var_450, 1);
    stream->write((uint64_t*)&cgen_var_450, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_451 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_451);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyFramebuffer readParams");
    AEMU_SCOPED_TRACE("vkDestroyFramebuffer returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkFramebuffer((VkFramebuffer*)&framebuffer);
    mImpl->log("finish vkDestroyFramebuffer");;
}

VkResult VkEncoder::vkCreateRenderPass(
    VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateRenderPass encode");
    mImpl->log("start vkCreateRenderPass");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkRenderPassCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo*)pool->alloc(sizeof(const VkRenderPassCreateInfo));
        deepcopy_VkRenderPassCreateInfo(pool, pCreateInfo, (VkRenderPassCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo(mImpl->resources(), (VkRenderPassCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_452;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_452, 1);
        countingStream->write((uint64_t*)&cgen_var_452, 1 * 8);
        marshal_VkRenderPassCreateInfo(countingStream, (VkRenderPassCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_453 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_453);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_454;
        countingStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_454, 1);
        countingStream->write((uint64_t*)&cgen_var_454, 8);
    }
    uint32_t packetSize_vkCreateRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateRenderPass = OP_vkCreateRenderPass;
    stream->write(&opcode_vkCreateRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateRenderPass, sizeof(uint32_t));
    uint64_t cgen_var_455;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_455, 1);
    stream->write((uint64_t*)&cgen_var_455, 1 * 8);
    marshal_VkRenderPassCreateInfo(stream, (VkRenderPassCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_456 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_456);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_457;
    stream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_457, 1);
    stream->write((uint64_t*)&cgen_var_457, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateRenderPass readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_458;
    stream->read((uint64_t*)&cgen_var_458, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_458, (VkRenderPass*)pRenderPass, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateRenderPass returnUnmarshal");
    VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateRenderPass");;
    return vkCreateRenderPass_VkResult_return;
}

void VkEncoder::vkDestroyRenderPass(
    VkDevice device,
    VkRenderPass renderPass,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyRenderPass encode");
    mImpl->log("start vkDestroyRenderPass");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkRenderPass local_renderPass;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_renderPass = renderPass;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_459;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_459, 1);
        countingStream->write((uint64_t*)&cgen_var_459, 1 * 8);
        uint64_t cgen_var_460;
        countingStream->handleMapping()->mapHandles_VkRenderPass_u64(&local_renderPass, &cgen_var_460, 1);
        countingStream->write((uint64_t*)&cgen_var_460, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_461 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_461);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyRenderPass = OP_vkDestroyRenderPass;
    stream->write(&opcode_vkDestroyRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyRenderPass, sizeof(uint32_t));
    uint64_t cgen_var_462;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_462, 1);
    stream->write((uint64_t*)&cgen_var_462, 1 * 8);
    uint64_t cgen_var_463;
    stream->handleMapping()->mapHandles_VkRenderPass_u64(&local_renderPass, &cgen_var_463, 1);
    stream->write((uint64_t*)&cgen_var_463, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_464 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_464);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyRenderPass readParams");
    AEMU_SCOPED_TRACE("vkDestroyRenderPass returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkRenderPass((VkRenderPass*)&renderPass);
    mImpl->log("finish vkDestroyRenderPass");;
}

void VkEncoder::vkGetRenderAreaGranularity(
    VkDevice device,
    VkRenderPass renderPass,
    VkExtent2D* pGranularity)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetRenderAreaGranularity encode");
    mImpl->log("start vkGetRenderAreaGranularity");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkRenderPass local_renderPass;
    local_device = device;
    local_renderPass = renderPass;
    countingStream->rewind();
    {
        uint64_t cgen_var_465;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_465, 1);
        countingStream->write((uint64_t*)&cgen_var_465, 1 * 8);
        uint64_t cgen_var_466;
        countingStream->handleMapping()->mapHandles_VkRenderPass_u64(&local_renderPass, &cgen_var_466, 1);
        countingStream->write((uint64_t*)&cgen_var_466, 1 * 8);
        marshal_VkExtent2D(countingStream, (VkExtent2D*)(pGranularity));
    }
    uint32_t packetSize_vkGetRenderAreaGranularity = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRenderAreaGranularity = OP_vkGetRenderAreaGranularity;
    stream->write(&opcode_vkGetRenderAreaGranularity, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRenderAreaGranularity, sizeof(uint32_t));
    uint64_t cgen_var_467;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_467, 1);
    stream->write((uint64_t*)&cgen_var_467, 1 * 8);
    uint64_t cgen_var_468;
    stream->handleMapping()->mapHandles_VkRenderPass_u64(&local_renderPass, &cgen_var_468, 1);
    stream->write((uint64_t*)&cgen_var_468, 1 * 8);
    marshal_VkExtent2D(stream, (VkExtent2D*)(pGranularity));
    AEMU_SCOPED_TRACE("vkGetRenderAreaGranularity readParams");
    unmarshal_VkExtent2D(stream, (VkExtent2D*)(pGranularity));
    if (pGranularity)
    {
        transform_fromhost_VkExtent2D(mImpl->resources(), (VkExtent2D*)(pGranularity));
    }
    AEMU_SCOPED_TRACE("vkGetRenderAreaGranularity returnUnmarshal");
    mImpl->log("finish vkGetRenderAreaGranularity");;
}

VkResult VkEncoder::vkCreateCommandPool(
    VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkCommandPool* pCommandPool)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateCommandPool encode");
    mImpl->log("start vkCreateCommandPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkCommandPoolCreateInfo*)pool->alloc(sizeof(const VkCommandPoolCreateInfo));
        deepcopy_VkCommandPoolCreateInfo(pool, pCreateInfo, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkCommandPoolCreateInfo(mImpl->resources(), (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_469;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_469, 1);
        countingStream->write((uint64_t*)&cgen_var_469, 1 * 8);
        marshal_VkCommandPoolCreateInfo(countingStream, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_470 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_470);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_471;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(pCommandPool, &cgen_var_471, 1);
        countingStream->write((uint64_t*)&cgen_var_471, 8);
    }
    uint32_t packetSize_vkCreateCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateCommandPool = OP_vkCreateCommandPool;
    stream->write(&opcode_vkCreateCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateCommandPool, sizeof(uint32_t));
    uint64_t cgen_var_472;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_472, 1);
    stream->write((uint64_t*)&cgen_var_472, 1 * 8);
    marshal_VkCommandPoolCreateInfo(stream, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_473 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_473);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_474;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(pCommandPool, &cgen_var_474, 1);
    stream->write((uint64_t*)&cgen_var_474, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateCommandPool readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_475;
    stream->read((uint64_t*)&cgen_var_475, 8);
    stream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_475, (VkCommandPool*)pCommandPool, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateCommandPool returnUnmarshal");
    VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateCommandPool");;
    return vkCreateCommandPool_VkResult_return;
}

void VkEncoder::vkDestroyCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyCommandPool encode");
    mImpl->log("start vkDestroyCommandPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_commandPool = commandPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_476;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_476, 1);
        countingStream->write((uint64_t*)&cgen_var_476, 1 * 8);
        uint64_t cgen_var_477;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_477, 1);
        countingStream->write((uint64_t*)&cgen_var_477, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_478 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_478);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyCommandPool = OP_vkDestroyCommandPool;
    stream->write(&opcode_vkDestroyCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyCommandPool, sizeof(uint32_t));
    uint64_t cgen_var_479;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_479, 1);
    stream->write((uint64_t*)&cgen_var_479, 1 * 8);
    uint64_t cgen_var_480;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_480, 1);
    stream->write((uint64_t*)&cgen_var_480, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_481 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_481);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyCommandPool readParams");
    AEMU_SCOPED_TRACE("vkDestroyCommandPool returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkCommandPool((VkCommandPool*)&commandPool);
    mImpl->log("finish vkDestroyCommandPool");;
}

VkResult VkEncoder::vkResetCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolResetFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkResetCommandPool encode");
    mImpl->log("start vkResetCommandPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolResetFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_482;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_482, 1);
        countingStream->write((uint64_t*)&cgen_var_482, 1 * 8);
        uint64_t cgen_var_483;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_483, 1);
        countingStream->write((uint64_t*)&cgen_var_483, 1 * 8);
        countingStream->write((VkCommandPoolResetFlags*)&local_flags, sizeof(VkCommandPoolResetFlags));
    }
    uint32_t packetSize_vkResetCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetCommandPool = OP_vkResetCommandPool;
    stream->write(&opcode_vkResetCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkResetCommandPool, sizeof(uint32_t));
    uint64_t cgen_var_484;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_484, 1);
    stream->write((uint64_t*)&cgen_var_484, 1 * 8);
    uint64_t cgen_var_485;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_485, 1);
    stream->write((uint64_t*)&cgen_var_485, 1 * 8);
    stream->write((VkCommandPoolResetFlags*)&local_flags, sizeof(VkCommandPoolResetFlags));
    AEMU_SCOPED_TRACE("vkResetCommandPool readParams");
    AEMU_SCOPED_TRACE("vkResetCommandPool returnUnmarshal");
    VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkResetCommandPool");;
    return vkResetCommandPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateCommandBuffers(
    VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer* pCommandBuffers)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkAllocateCommandBuffers encode");
    mImpl->log("start vkAllocateCommandBuffers");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandBufferAllocateInfo* local_pAllocateInfo;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkCommandBufferAllocateInfo*)pool->alloc(sizeof(const VkCommandBufferAllocateInfo));
        deepcopy_VkCommandBufferAllocateInfo(pool, pAllocateInfo, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocateInfo)
    {
        transform_tohost_VkCommandBufferAllocateInfo(mImpl->resources(), (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_486;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_486, 1);
        countingStream->write((uint64_t*)&cgen_var_486, 1 * 8);
        marshal_VkCommandBufferAllocateInfo(countingStream, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
        if (pAllocateInfo->commandBufferCount)
        {
            uint64_t* cgen_var_487;
            countingStream->alloc((void**)&cgen_var_487, pAllocateInfo->commandBufferCount * 8);
            countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(pCommandBuffers, cgen_var_487, pAllocateInfo->commandBufferCount);
            countingStream->write((uint64_t*)cgen_var_487, pAllocateInfo->commandBufferCount * 8);
        }
    }
    uint32_t packetSize_vkAllocateCommandBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateCommandBuffers = OP_vkAllocateCommandBuffers;
    stream->write(&opcode_vkAllocateCommandBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateCommandBuffers, sizeof(uint32_t));
    uint64_t cgen_var_488;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_488, 1);
    stream->write((uint64_t*)&cgen_var_488, 1 * 8);
    marshal_VkCommandBufferAllocateInfo(stream, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (pAllocateInfo->commandBufferCount)
    {
        uint64_t* cgen_var_489;
        stream->alloc((void**)&cgen_var_489, pAllocateInfo->commandBufferCount * 8);
        stream->handleMapping()->mapHandles_VkCommandBuffer_u64(pCommandBuffers, cgen_var_489, pAllocateInfo->commandBufferCount);
        stream->write((uint64_t*)cgen_var_489, pAllocateInfo->commandBufferCount * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkAllocateCommandBuffers readParams");
    stream->setHandleMapping(resources->createMapping());
    if (pAllocateInfo->commandBufferCount)
    {
        uint64_t* cgen_var_490;
        stream->alloc((void**)&cgen_var_490, pAllocateInfo->commandBufferCount * 8);
        stream->read((uint64_t*)cgen_var_490, pAllocateInfo->commandBufferCount * 8);
        stream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_490, (VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
    }
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkAllocateCommandBuffers returnUnmarshal");
    VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkAllocateCommandBuffers");;
    return vkAllocateCommandBuffers_VkResult_return;
}

void VkEncoder::vkFreeCommandBuffers(
    VkDevice device,
    VkCommandPool commandPool,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkFreeCommandBuffers encode");
    mImpl->log("start vkFreeCommandBuffers");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    uint32_t local_commandBufferCount;
    VkCommandBuffer* local_pCommandBuffers;
    local_device = device;
    local_commandPool = commandPool;
    local_commandBufferCount = commandBufferCount;
    local_pCommandBuffers = nullptr;
    if (pCommandBuffers)
    {
        local_pCommandBuffers = (VkCommandBuffer*)pool->dupArray(pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_491;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_491, 1);
        countingStream->write((uint64_t*)&cgen_var_491, 1 * 8);
        uint64_t cgen_var_492;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_492, 1);
        countingStream->write((uint64_t*)&cgen_var_492, 1 * 8);
        countingStream->write((uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_493 = (uint64_t)(uintptr_t)local_pCommandBuffers;
        countingStream->putBe64(cgen_var_493);
        if (local_pCommandBuffers)
        {
            if (((commandBufferCount)))
            {
                uint64_t* cgen_var_494;
                countingStream->alloc((void**)&cgen_var_494, ((commandBufferCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(local_pCommandBuffers, cgen_var_494, ((commandBufferCount)));
                countingStream->write((uint64_t*)cgen_var_494, ((commandBufferCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkFreeCommandBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeCommandBuffers = OP_vkFreeCommandBuffers;
    stream->write(&opcode_vkFreeCommandBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeCommandBuffers, sizeof(uint32_t));
    uint64_t cgen_var_495;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_495, 1);
    stream->write((uint64_t*)&cgen_var_495, 1 * 8);
    uint64_t cgen_var_496;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_496, 1);
    stream->write((uint64_t*)&cgen_var_496, 1 * 8);
    stream->write((uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_497 = (uint64_t)(uintptr_t)local_pCommandBuffers;
    stream->putBe64(cgen_var_497);
    if (local_pCommandBuffers)
    {
        if (((commandBufferCount)))
        {
            uint64_t* cgen_var_498;
            stream->alloc((void**)&cgen_var_498, ((commandBufferCount)) * 8);
            stream->handleMapping()->mapHandles_VkCommandBuffer_u64(local_pCommandBuffers, cgen_var_498, ((commandBufferCount)));
            stream->write((uint64_t*)cgen_var_498, ((commandBufferCount)) * 8);
        }
    }
    AEMU_SCOPED_TRACE("vkFreeCommandBuffers readParams");
    AEMU_SCOPED_TRACE("vkFreeCommandBuffers returnUnmarshal");
    if (pCommandBuffers)
    {
        resources->destroyMapping()->mapHandles_VkCommandBuffer((VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
    }
    mImpl->log("finish vkFreeCommandBuffers");;
}

VkResult VkEncoder::vkBeginCommandBuffer(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkBeginCommandBuffer encode");
    mImpl->log("start vkBeginCommandBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferBeginInfo* local_pBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pBeginInfo = nullptr;
    if (pBeginInfo)
    {
        local_pBeginInfo = (VkCommandBufferBeginInfo*)pool->alloc(sizeof(const VkCommandBufferBeginInfo));
        deepcopy_VkCommandBufferBeginInfo(pool, pBeginInfo, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    if (local_pBeginInfo)
    {
        transform_tohost_VkCommandBufferBeginInfo(mImpl->resources(), (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_499;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_499, 1);
        countingStream->write((uint64_t*)&cgen_var_499, 1 * 8);
        marshal_VkCommandBufferBeginInfo(countingStream, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    uint32_t packetSize_vkBeginCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBeginCommandBuffer = OP_vkBeginCommandBuffer;
    stream->write(&opcode_vkBeginCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkBeginCommandBuffer, sizeof(uint32_t));
    uint64_t cgen_var_500;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_500, 1);
    stream->write((uint64_t*)&cgen_var_500, 1 * 8);
    marshal_VkCommandBufferBeginInfo(stream, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    AEMU_SCOPED_TRACE("vkBeginCommandBuffer readParams");
    AEMU_SCOPED_TRACE("vkBeginCommandBuffer returnUnmarshal");
    VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkBeginCommandBuffer");;
    return vkBeginCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkEndCommandBuffer(
    VkCommandBuffer commandBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEndCommandBuffer encode");
    mImpl->log("start vkEndCommandBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_501;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_501, 1);
        countingStream->write((uint64_t*)&cgen_var_501, 1 * 8);
    }
    uint32_t packetSize_vkEndCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEndCommandBuffer = OP_vkEndCommandBuffer;
    stream->write(&opcode_vkEndCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkEndCommandBuffer, sizeof(uint32_t));
    uint64_t cgen_var_502;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_502, 1);
    stream->write((uint64_t*)&cgen_var_502, 1 * 8);
    AEMU_SCOPED_TRACE("vkEndCommandBuffer readParams");
    AEMU_SCOPED_TRACE("vkEndCommandBuffer returnUnmarshal");
    VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEndCommandBuffer");;
    return vkEndCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkResetCommandBuffer(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkResetCommandBuffer encode");
    mImpl->log("start vkResetCommandBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferResetFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_503;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_503, 1);
        countingStream->write((uint64_t*)&cgen_var_503, 1 * 8);
        countingStream->write((VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    }
    uint32_t packetSize_vkResetCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetCommandBuffer = OP_vkResetCommandBuffer;
    stream->write(&opcode_vkResetCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkResetCommandBuffer, sizeof(uint32_t));
    uint64_t cgen_var_504;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_504, 1);
    stream->write((uint64_t*)&cgen_var_504, 1 * 8);
    stream->write((VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    AEMU_SCOPED_TRACE("vkResetCommandBuffer readParams");
    AEMU_SCOPED_TRACE("vkResetCommandBuffer returnUnmarshal");
    VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkResetCommandBuffer");;
    return vkResetCommandBuffer_VkResult_return;
}

void VkEncoder::vkCmdBindPipeline(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBindPipeline encode");
    mImpl->log("start vkCmdBindPipeline");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipeline local_pipeline;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_pipeline = pipeline;
    countingStream->rewind();
    {
        uint64_t cgen_var_505;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_505, 1);
        countingStream->write((uint64_t*)&cgen_var_505, 1 * 8);
        countingStream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
        uint64_t cgen_var_506;
        countingStream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_506, 1);
        countingStream->write((uint64_t*)&cgen_var_506, 1 * 8);
    }
    uint32_t packetSize_vkCmdBindPipeline = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindPipeline = OP_vkCmdBindPipeline;
    stream->write(&opcode_vkCmdBindPipeline, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindPipeline, sizeof(uint32_t));
    uint64_t cgen_var_507;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_507, 1);
    stream->write((uint64_t*)&cgen_var_507, 1 * 8);
    stream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_508;
    stream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_508, 1);
    stream->write((uint64_t*)&cgen_var_508, 1 * 8);
    AEMU_SCOPED_TRACE("vkCmdBindPipeline readParams");
    AEMU_SCOPED_TRACE("vkCmdBindPipeline returnUnmarshal");
    mImpl->log("finish vkCmdBindPipeline");;
}

void VkEncoder::vkCmdSetViewport(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewport* pViewports)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetViewport encode");
    mImpl->log("start vkCmdSetViewport");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkViewport* local_pViewports;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pViewports = nullptr;
    if (pViewports)
    {
        local_pViewports = (VkViewport*)pool->alloc(((viewportCount)) * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewport(pool, pViewports + i, (VkViewport*)(local_pViewports + i));
        }
    }
    if (local_pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewport(mImpl->resources(), (VkViewport*)(local_pViewports + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_509;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_509, 1);
        countingStream->write((uint64_t*)&cgen_var_509, 1 * 8);
        countingStream->write((uint32_t*)&local_firstViewport, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_viewportCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            marshal_VkViewport(countingStream, (VkViewport*)(local_pViewports + i));
        }
    }
    uint32_t packetSize_vkCmdSetViewport = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetViewport = OP_vkCmdSetViewport;
    stream->write(&opcode_vkCmdSetViewport, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetViewport, sizeof(uint32_t));
    uint64_t cgen_var_510;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_510, 1);
    stream->write((uint64_t*)&cgen_var_510, 1 * 8);
    stream->write((uint32_t*)&local_firstViewport, sizeof(uint32_t));
    stream->write((uint32_t*)&local_viewportCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        marshal_VkViewport(stream, (VkViewport*)(local_pViewports + i));
    }
    AEMU_SCOPED_TRACE("vkCmdSetViewport readParams");
    AEMU_SCOPED_TRACE("vkCmdSetViewport returnUnmarshal");
    mImpl->log("finish vkCmdSetViewport");;
}

void VkEncoder::vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    uint32_t firstScissor,
    uint32_t scissorCount,
    const VkRect2D* pScissors)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetScissor encode");
    mImpl->log("start vkCmdSetScissor");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstScissor;
    uint32_t local_scissorCount;
    VkRect2D* local_pScissors;
    local_commandBuffer = commandBuffer;
    local_firstScissor = firstScissor;
    local_scissorCount = scissorCount;
    local_pScissors = nullptr;
    if (pScissors)
    {
        local_pScissors = (VkRect2D*)pool->alloc(((scissorCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            deepcopy_VkRect2D(pool, pScissors + i, (VkRect2D*)(local_pScissors + i));
        }
    }
    if (local_pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            transform_tohost_VkRect2D(mImpl->resources(), (VkRect2D*)(local_pScissors + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_511;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_511, 1);
        countingStream->write((uint64_t*)&cgen_var_511, 1 * 8);
        countingStream->write((uint32_t*)&local_firstScissor, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_scissorCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            marshal_VkRect2D(countingStream, (VkRect2D*)(local_pScissors + i));
        }
    }
    uint32_t packetSize_vkCmdSetScissor = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetScissor = OP_vkCmdSetScissor;
    stream->write(&opcode_vkCmdSetScissor, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetScissor, sizeof(uint32_t));
    uint64_t cgen_var_512;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_512, 1);
    stream->write((uint64_t*)&cgen_var_512, 1 * 8);
    stream->write((uint32_t*)&local_firstScissor, sizeof(uint32_t));
    stream->write((uint32_t*)&local_scissorCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
    {
        marshal_VkRect2D(stream, (VkRect2D*)(local_pScissors + i));
    }
    AEMU_SCOPED_TRACE("vkCmdSetScissor readParams");
    AEMU_SCOPED_TRACE("vkCmdSetScissor returnUnmarshal");
    mImpl->log("finish vkCmdSetScissor");;
}

void VkEncoder::vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    float lineWidth)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetLineWidth encode");
    mImpl->log("start vkCmdSetLineWidth");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    float local_lineWidth;
    local_commandBuffer = commandBuffer;
    local_lineWidth = lineWidth;
    countingStream->rewind();
    {
        uint64_t cgen_var_513;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_513, 1);
        countingStream->write((uint64_t*)&cgen_var_513, 1 * 8);
        countingStream->write((float*)&local_lineWidth, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetLineWidth = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetLineWidth = OP_vkCmdSetLineWidth;
    stream->write(&opcode_vkCmdSetLineWidth, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetLineWidth, sizeof(uint32_t));
    uint64_t cgen_var_514;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_514, 1);
    stream->write((uint64_t*)&cgen_var_514, 1 * 8);
    stream->write((float*)&local_lineWidth, sizeof(float));
    AEMU_SCOPED_TRACE("vkCmdSetLineWidth readParams");
    AEMU_SCOPED_TRACE("vkCmdSetLineWidth returnUnmarshal");
    mImpl->log("finish vkCmdSetLineWidth");;
}

void VkEncoder::vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    float depthBiasConstantFactor,
    float depthBiasClamp,
    float depthBiasSlopeFactor)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetDepthBias encode");
    mImpl->log("start vkCmdSetDepthBias");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    float local_depthBiasConstantFactor;
    float local_depthBiasClamp;
    float local_depthBiasSlopeFactor;
    local_commandBuffer = commandBuffer;
    local_depthBiasConstantFactor = depthBiasConstantFactor;
    local_depthBiasClamp = depthBiasClamp;
    local_depthBiasSlopeFactor = depthBiasSlopeFactor;
    countingStream->rewind();
    {
        uint64_t cgen_var_515;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_515, 1);
        countingStream->write((uint64_t*)&cgen_var_515, 1 * 8);
        countingStream->write((float*)&local_depthBiasConstantFactor, sizeof(float));
        countingStream->write((float*)&local_depthBiasClamp, sizeof(float));
        countingStream->write((float*)&local_depthBiasSlopeFactor, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetDepthBias = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDepthBias = OP_vkCmdSetDepthBias;
    stream->write(&opcode_vkCmdSetDepthBias, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDepthBias, sizeof(uint32_t));
    uint64_t cgen_var_516;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_516, 1);
    stream->write((uint64_t*)&cgen_var_516, 1 * 8);
    stream->write((float*)&local_depthBiasConstantFactor, sizeof(float));
    stream->write((float*)&local_depthBiasClamp, sizeof(float));
    stream->write((float*)&local_depthBiasSlopeFactor, sizeof(float));
    AEMU_SCOPED_TRACE("vkCmdSetDepthBias readParams");
    AEMU_SCOPED_TRACE("vkCmdSetDepthBias returnUnmarshal");
    mImpl->log("finish vkCmdSetDepthBias");;
}

void VkEncoder::vkCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
    const float blendConstants[4])
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetBlendConstants encode");
    mImpl->log("start vkCmdSetBlendConstants");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    float local_blendConstants[4];
    local_commandBuffer = commandBuffer;
    memcpy(local_blendConstants, blendConstants, 4 * sizeof(const float));
    countingStream->rewind();
    {
        uint64_t cgen_var_517;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_517, 1);
        countingStream->write((uint64_t*)&cgen_var_517, 1 * 8);
        countingStream->write((float*)local_blendConstants, 4 * sizeof(float));
    }
    uint32_t packetSize_vkCmdSetBlendConstants = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetBlendConstants = OP_vkCmdSetBlendConstants;
    stream->write(&opcode_vkCmdSetBlendConstants, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetBlendConstants, sizeof(uint32_t));
    uint64_t cgen_var_518;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_518, 1);
    stream->write((uint64_t*)&cgen_var_518, 1 * 8);
    stream->write((float*)local_blendConstants, 4 * sizeof(float));
    AEMU_SCOPED_TRACE("vkCmdSetBlendConstants readParams");
    AEMU_SCOPED_TRACE("vkCmdSetBlendConstants returnUnmarshal");
    mImpl->log("finish vkCmdSetBlendConstants");;
}

void VkEncoder::vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    float minDepthBounds,
    float maxDepthBounds)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetDepthBounds encode");
    mImpl->log("start vkCmdSetDepthBounds");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    float local_minDepthBounds;
    float local_maxDepthBounds;
    local_commandBuffer = commandBuffer;
    local_minDepthBounds = minDepthBounds;
    local_maxDepthBounds = maxDepthBounds;
    countingStream->rewind();
    {
        uint64_t cgen_var_519;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_519, 1);
        countingStream->write((uint64_t*)&cgen_var_519, 1 * 8);
        countingStream->write((float*)&local_minDepthBounds, sizeof(float));
        countingStream->write((float*)&local_maxDepthBounds, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetDepthBounds = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDepthBounds = OP_vkCmdSetDepthBounds;
    stream->write(&opcode_vkCmdSetDepthBounds, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDepthBounds, sizeof(uint32_t));
    uint64_t cgen_var_520;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_520, 1);
    stream->write((uint64_t*)&cgen_var_520, 1 * 8);
    stream->write((float*)&local_minDepthBounds, sizeof(float));
    stream->write((float*)&local_maxDepthBounds, sizeof(float));
    AEMU_SCOPED_TRACE("vkCmdSetDepthBounds readParams");
    AEMU_SCOPED_TRACE("vkCmdSetDepthBounds returnUnmarshal");
    mImpl->log("finish vkCmdSetDepthBounds");;
}

void VkEncoder::vkCmdSetStencilCompareMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t compareMask)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetStencilCompareMask encode");
    mImpl->log("start vkCmdSetStencilCompareMask");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_compareMask;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_compareMask = compareMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_521;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_521, 1);
        countingStream->write((uint64_t*)&cgen_var_521, 1 * 8);
        countingStream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&local_compareMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilCompareMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilCompareMask = OP_vkCmdSetStencilCompareMask;
    stream->write(&opcode_vkCmdSetStencilCompareMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilCompareMask, sizeof(uint32_t));
    uint64_t cgen_var_522;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_522, 1);
    stream->write((uint64_t*)&cgen_var_522, 1 * 8);
    stream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&local_compareMask, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdSetStencilCompareMask readParams");
    AEMU_SCOPED_TRACE("vkCmdSetStencilCompareMask returnUnmarshal");
    mImpl->log("finish vkCmdSetStencilCompareMask");;
}

void VkEncoder::vkCmdSetStencilWriteMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t writeMask)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetStencilWriteMask encode");
    mImpl->log("start vkCmdSetStencilWriteMask");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_writeMask;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_writeMask = writeMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_523;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_523, 1);
        countingStream->write((uint64_t*)&cgen_var_523, 1 * 8);
        countingStream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&local_writeMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilWriteMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilWriteMask = OP_vkCmdSetStencilWriteMask;
    stream->write(&opcode_vkCmdSetStencilWriteMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilWriteMask, sizeof(uint32_t));
    uint64_t cgen_var_524;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_524, 1);
    stream->write((uint64_t*)&cgen_var_524, 1 * 8);
    stream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&local_writeMask, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdSetStencilWriteMask readParams");
    AEMU_SCOPED_TRACE("vkCmdSetStencilWriteMask returnUnmarshal");
    mImpl->log("finish vkCmdSetStencilWriteMask");;
}

void VkEncoder::vkCmdSetStencilReference(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t reference)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetStencilReference encode");
    mImpl->log("start vkCmdSetStencilReference");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_reference;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_reference = reference;
    countingStream->rewind();
    {
        uint64_t cgen_var_525;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_525, 1);
        countingStream->write((uint64_t*)&cgen_var_525, 1 * 8);
        countingStream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&local_reference, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilReference = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilReference = OP_vkCmdSetStencilReference;
    stream->write(&opcode_vkCmdSetStencilReference, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilReference, sizeof(uint32_t));
    uint64_t cgen_var_526;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_526, 1);
    stream->write((uint64_t*)&cgen_var_526, 1 * 8);
    stream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&local_reference, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdSetStencilReference readParams");
    AEMU_SCOPED_TRACE("vkCmdSetStencilReference returnUnmarshal");
    mImpl->log("finish vkCmdSetStencilReference");;
}

void VkEncoder::vkCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t firstSet,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBindDescriptorSets encode");
    mImpl->log("start vkCmdBindDescriptorSets");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipelineLayout local_layout;
    uint32_t local_firstSet;
    uint32_t local_descriptorSetCount;
    VkDescriptorSet* local_pDescriptorSets;
    uint32_t local_dynamicOffsetCount;
    uint32_t* local_pDynamicOffsets;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_layout = layout;
    local_firstSet = firstSet;
    local_descriptorSetCount = descriptorSetCount;
    local_pDescriptorSets = nullptr;
    if (pDescriptorSets)
    {
        local_pDescriptorSets = (VkDescriptorSet*)pool->dupArray(pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    }
    local_dynamicOffsetCount = dynamicOffsetCount;
    local_pDynamicOffsets = nullptr;
    if (pDynamicOffsets)
    {
        local_pDynamicOffsets = (uint32_t*)pool->dupArray(pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_527;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_527, 1);
        countingStream->write((uint64_t*)&cgen_var_527, 1 * 8);
        countingStream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
        uint64_t cgen_var_528;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_528, 1);
        countingStream->write((uint64_t*)&cgen_var_528, 1 * 8);
        countingStream->write((uint32_t*)&local_firstSet, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
        if (((descriptorSetCount)))
        {
            uint64_t* cgen_var_529;
            countingStream->alloc((void**)&cgen_var_529, ((descriptorSetCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(local_pDescriptorSets, cgen_var_529, ((descriptorSetCount)));
            countingStream->write((uint64_t*)cgen_var_529, ((descriptorSetCount)) * 8);
        }
        countingStream->write((uint32_t*)&local_dynamicOffsetCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)local_pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdBindDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindDescriptorSets = OP_vkCmdBindDescriptorSets;
    stream->write(&opcode_vkCmdBindDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindDescriptorSets, sizeof(uint32_t));
    uint64_t cgen_var_530;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_530, 1);
    stream->write((uint64_t*)&cgen_var_530, 1 * 8);
    stream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_531;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_531, 1);
    stream->write((uint64_t*)&cgen_var_531, 1 * 8);
    stream->write((uint32_t*)&local_firstSet, sizeof(uint32_t));
    stream->write((uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    if (((descriptorSetCount)))
    {
        uint64_t* cgen_var_532;
        stream->alloc((void**)&cgen_var_532, ((descriptorSetCount)) * 8);
        stream->handleMapping()->mapHandles_VkDescriptorSet_u64(local_pDescriptorSets, cgen_var_532, ((descriptorSetCount)));
        stream->write((uint64_t*)cgen_var_532, ((descriptorSetCount)) * 8);
    }
    stream->write((uint32_t*)&local_dynamicOffsetCount, sizeof(uint32_t));
    stream->write((uint32_t*)local_pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdBindDescriptorSets readParams");
    AEMU_SCOPED_TRACE("vkCmdBindDescriptorSets returnUnmarshal");
    mImpl->log("finish vkCmdBindDescriptorSets");;
}

void VkEncoder::vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkIndexType indexType)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBindIndexBuffer encode");
    mImpl->log("start vkCmdBindIndexBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkIndexType local_indexType;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_indexType = indexType;
    countingStream->rewind();
    {
        uint64_t cgen_var_533;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_533, 1);
        countingStream->write((uint64_t*)&cgen_var_533, 1 * 8);
        uint64_t cgen_var_534;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_534, 1);
        countingStream->write((uint64_t*)&cgen_var_534, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        countingStream->write((VkIndexType*)&local_indexType, sizeof(VkIndexType));
    }
    uint32_t packetSize_vkCmdBindIndexBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindIndexBuffer = OP_vkCmdBindIndexBuffer;
    stream->write(&opcode_vkCmdBindIndexBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindIndexBuffer, sizeof(uint32_t));
    uint64_t cgen_var_535;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_535, 1);
    stream->write((uint64_t*)&cgen_var_535, 1 * 8);
    uint64_t cgen_var_536;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_536, 1);
    stream->write((uint64_t*)&cgen_var_536, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    stream->write((VkIndexType*)&local_indexType, sizeof(VkIndexType));
    AEMU_SCOPED_TRACE("vkCmdBindIndexBuffer readParams");
    AEMU_SCOPED_TRACE("vkCmdBindIndexBuffer returnUnmarshal");
    mImpl->log("finish vkCmdBindIndexBuffer");;
}

void VkEncoder::vkCmdBindVertexBuffers(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers encode");
    mImpl->log("start vkCmdBindVertexBuffers");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstBinding;
    uint32_t local_bindingCount;
    VkBuffer* local_pBuffers;
    VkDeviceSize* local_pOffsets;
    local_commandBuffer = commandBuffer;
    local_firstBinding = firstBinding;
    local_bindingCount = bindingCount;
    local_pBuffers = nullptr;
    if (pBuffers)
    {
        local_pBuffers = (VkBuffer*)pool->dupArray(pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
    }
    local_pOffsets = nullptr;
    if (pOffsets)
    {
        local_pOffsets = (VkDeviceSize*)pool->dupArray(pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_537;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_537, 1);
        countingStream->write((uint64_t*)&cgen_var_537, 1 * 8);
        countingStream->write((uint32_t*)&local_firstBinding, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_bindingCount, sizeof(uint32_t));
        if (((bindingCount)))
        {
            uint64_t* cgen_var_538;
            countingStream->alloc((void**)&cgen_var_538, ((bindingCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkBuffer_u64(local_pBuffers, cgen_var_538, ((bindingCount)));
            countingStream->write((uint64_t*)cgen_var_538, ((bindingCount)) * 8);
        }
        countingStream->write((VkDeviceSize*)local_pOffsets, ((bindingCount)) * sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkCmdBindVertexBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindVertexBuffers = OP_vkCmdBindVertexBuffers;
    stream->write(&opcode_vkCmdBindVertexBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindVertexBuffers, sizeof(uint32_t));
    uint64_t cgen_var_539;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_539, 1);
    stream->write((uint64_t*)&cgen_var_539, 1 * 8);
    stream->write((uint32_t*)&local_firstBinding, sizeof(uint32_t));
    stream->write((uint32_t*)&local_bindingCount, sizeof(uint32_t));
    if (((bindingCount)))
    {
        uint64_t* cgen_var_540;
        stream->alloc((void**)&cgen_var_540, ((bindingCount)) * 8);
        stream->handleMapping()->mapHandles_VkBuffer_u64(local_pBuffers, cgen_var_540, ((bindingCount)));
        stream->write((uint64_t*)cgen_var_540, ((bindingCount)) * 8);
    }
    stream->write((VkDeviceSize*)local_pOffsets, ((bindingCount)) * sizeof(VkDeviceSize));
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers readParams");
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers returnUnmarshal");
    mImpl->log("finish vkCmdBindVertexBuffers");;
}

void VkEncoder::vkCmdDraw(
    VkCommandBuffer commandBuffer,
    uint32_t vertexCount,
    uint32_t instanceCount,
    uint32_t firstVertex,
    uint32_t firstInstance)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDraw encode");
    mImpl->log("start vkCmdDraw");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_vertexCount;
    uint32_t local_instanceCount;
    uint32_t local_firstVertex;
    uint32_t local_firstInstance;
    local_commandBuffer = commandBuffer;
    local_vertexCount = vertexCount;
    local_instanceCount = instanceCount;
    local_firstVertex = firstVertex;
    local_firstInstance = firstInstance;
    countingStream->rewind();
    {
        uint64_t cgen_var_541;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_541, 1);
        countingStream->write((uint64_t*)&cgen_var_541, 1 * 8);
        countingStream->write((uint32_t*)&local_vertexCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_instanceCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_firstVertex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_firstInstance, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDraw = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDraw = OP_vkCmdDraw;
    stream->write(&opcode_vkCmdDraw, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDraw, sizeof(uint32_t));
    uint64_t cgen_var_542;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_542, 1);
    stream->write((uint64_t*)&cgen_var_542, 1 * 8);
    stream->write((uint32_t*)&local_vertexCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_instanceCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_firstVertex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_firstInstance, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDraw readParams");
    AEMU_SCOPED_TRACE("vkCmdDraw returnUnmarshal");
    mImpl->log("finish vkCmdDraw");;
}

void VkEncoder::vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    uint32_t indexCount,
    uint32_t instanceCount,
    uint32_t firstIndex,
    int32_t vertexOffset,
    uint32_t firstInstance)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDrawIndexed encode");
    mImpl->log("start vkCmdDrawIndexed");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_indexCount;
    uint32_t local_instanceCount;
    uint32_t local_firstIndex;
    int32_t local_vertexOffset;
    uint32_t local_firstInstance;
    local_commandBuffer = commandBuffer;
    local_indexCount = indexCount;
    local_instanceCount = instanceCount;
    local_firstIndex = firstIndex;
    local_vertexOffset = vertexOffset;
    local_firstInstance = firstInstance;
    countingStream->rewind();
    {
        uint64_t cgen_var_543;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_543, 1);
        countingStream->write((uint64_t*)&cgen_var_543, 1 * 8);
        countingStream->write((uint32_t*)&local_indexCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_instanceCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_firstIndex, sizeof(uint32_t));
        countingStream->write((int32_t*)&local_vertexOffset, sizeof(int32_t));
        countingStream->write((uint32_t*)&local_firstInstance, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexed = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexed = OP_vkCmdDrawIndexed;
    stream->write(&opcode_vkCmdDrawIndexed, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexed, sizeof(uint32_t));
    uint64_t cgen_var_544;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_544, 1);
    stream->write((uint64_t*)&cgen_var_544, 1 * 8);
    stream->write((uint32_t*)&local_indexCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_instanceCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_firstIndex, sizeof(uint32_t));
    stream->write((int32_t*)&local_vertexOffset, sizeof(int32_t));
    stream->write((uint32_t*)&local_firstInstance, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDrawIndexed readParams");
    AEMU_SCOPED_TRACE("vkCmdDrawIndexed returnUnmarshal");
    mImpl->log("finish vkCmdDrawIndexed");;
}

void VkEncoder::vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDrawIndirect encode");
    mImpl->log("start vkCmdDrawIndirect");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_545;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_545, 1);
        countingStream->write((uint64_t*)&cgen_var_545, 1 * 8);
        uint64_t cgen_var_546;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_546, 1);
        countingStream->write((uint64_t*)&cgen_var_546, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_drawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirect = OP_vkCmdDrawIndirect;
    stream->write(&opcode_vkCmdDrawIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirect, sizeof(uint32_t));
    uint64_t cgen_var_547;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_547, 1);
    stream->write((uint64_t*)&cgen_var_547, 1 * 8);
    uint64_t cgen_var_548;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_548, 1);
    stream->write((uint64_t*)&cgen_var_548, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_drawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDrawIndirect readParams");
    AEMU_SCOPED_TRACE("vkCmdDrawIndirect returnUnmarshal");
    mImpl->log("finish vkCmdDrawIndirect");;
}

void VkEncoder::vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirect encode");
    mImpl->log("start vkCmdDrawIndexedIndirect");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_549;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_549, 1);
        countingStream->write((uint64_t*)&cgen_var_549, 1 * 8);
        uint64_t cgen_var_550;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_550, 1);
        countingStream->write((uint64_t*)&cgen_var_550, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_drawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirect = OP_vkCmdDrawIndexedIndirect;
    stream->write(&opcode_vkCmdDrawIndexedIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirect, sizeof(uint32_t));
    uint64_t cgen_var_551;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_551, 1);
    stream->write((uint64_t*)&cgen_var_551, 1 * 8);
    uint64_t cgen_var_552;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_552, 1);
    stream->write((uint64_t*)&cgen_var_552, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_drawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirect readParams");
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirect returnUnmarshal");
    mImpl->log("finish vkCmdDrawIndexedIndirect");;
}

void VkEncoder::vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDispatch encode");
    mImpl->log("start vkCmdDispatch");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    countingStream->rewind();
    {
        uint64_t cgen_var_553;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_553, 1);
        countingStream->write((uint64_t*)&cgen_var_553, 1 * 8);
        countingStream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatch = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatch = OP_vkCmdDispatch;
    stream->write(&opcode_vkCmdDispatch, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatch, sizeof(uint32_t));
    uint64_t cgen_var_554;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_554, 1);
    stream->write((uint64_t*)&cgen_var_554, 1 * 8);
    stream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDispatch readParams");
    AEMU_SCOPED_TRACE("vkCmdDispatch returnUnmarshal");
    mImpl->log("finish vkCmdDispatch");;
}

void VkEncoder::vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDispatchIndirect encode");
    mImpl->log("start vkCmdDispatchIndirect");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    countingStream->rewind();
    {
        uint64_t cgen_var_555;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_555, 1);
        countingStream->write((uint64_t*)&cgen_var_555, 1 * 8);
        uint64_t cgen_var_556;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_556, 1);
        countingStream->write((uint64_t*)&cgen_var_556, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkCmdDispatchIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchIndirect = OP_vkCmdDispatchIndirect;
    stream->write(&opcode_vkCmdDispatchIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchIndirect, sizeof(uint32_t));
    uint64_t cgen_var_557;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_557, 1);
    stream->write((uint64_t*)&cgen_var_557, 1 * 8);
    uint64_t cgen_var_558;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_558, 1);
    stream->write((uint64_t*)&cgen_var_558, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    AEMU_SCOPED_TRACE("vkCmdDispatchIndirect readParams");
    AEMU_SCOPED_TRACE("vkCmdDispatchIndirect returnUnmarshal");
    mImpl->log("finish vkCmdDispatchIndirect");;
}

void VkEncoder::vkCmdCopyBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferCopy* pRegions)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer encode");
    mImpl->log("start vkCmdCopyBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_srcBuffer;
    VkBuffer local_dstBuffer;
    uint32_t local_regionCount;
    VkBufferCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcBuffer = srcBuffer;
    local_dstBuffer = dstBuffer;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferCopy(pool, pRegions + i, (VkBufferCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferCopy(mImpl->resources(), (VkBufferCopy*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_559;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_559, 1);
        countingStream->write((uint64_t*)&cgen_var_559, 1 * 8);
        uint64_t cgen_var_560;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_srcBuffer, &cgen_var_560, 1);
        countingStream->write((uint64_t*)&cgen_var_560, 1 * 8);
        uint64_t cgen_var_561;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_561, 1);
        countingStream->write((uint64_t*)&cgen_var_561, 1 * 8);
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferCopy(countingStream, (VkBufferCopy*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyBuffer = OP_vkCmdCopyBuffer;
    stream->write(&opcode_vkCmdCopyBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyBuffer, sizeof(uint32_t));
    uint64_t cgen_var_562;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_562, 1);
    stream->write((uint64_t*)&cgen_var_562, 1 * 8);
    uint64_t cgen_var_563;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_srcBuffer, &cgen_var_563, 1);
    stream->write((uint64_t*)&cgen_var_563, 1 * 8);
    uint64_t cgen_var_564;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_564, 1);
    stream->write((uint64_t*)&cgen_var_564, 1 * 8);
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferCopy(stream, (VkBufferCopy*)(local_pRegions + i));
    }
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer readParams");
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer returnUnmarshal");
    mImpl->log("finish vkCmdCopyBuffer");;
}

void VkEncoder::vkCmdCopyImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageCopy* pRegions)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdCopyImage encode");
    mImpl->log("start vkCmdCopyImage");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageCopy(pool, pRegions + i, (VkImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageCopy(mImpl->resources(), (VkImageCopy*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_565;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_565, 1);
        countingStream->write((uint64_t*)&cgen_var_565, 1 * 8);
        uint64_t cgen_var_566;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_566, 1);
        countingStream->write((uint64_t*)&cgen_var_566, 1 * 8);
        countingStream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
        uint64_t cgen_var_567;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_567, 1);
        countingStream->write((uint64_t*)&cgen_var_567, 1 * 8);
        countingStream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageCopy(countingStream, (VkImageCopy*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyImage = OP_vkCmdCopyImage;
    stream->write(&opcode_vkCmdCopyImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyImage, sizeof(uint32_t));
    uint64_t cgen_var_568;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_568, 1);
    stream->write((uint64_t*)&cgen_var_568, 1 * 8);
    uint64_t cgen_var_569;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_569, 1);
    stream->write((uint64_t*)&cgen_var_569, 1 * 8);
    stream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_570;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_570, 1);
    stream->write((uint64_t*)&cgen_var_570, 1 * 8);
    stream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageCopy(stream, (VkImageCopy*)(local_pRegions + i));
    }
    AEMU_SCOPED_TRACE("vkCmdCopyImage readParams");
    AEMU_SCOPED_TRACE("vkCmdCopyImage returnUnmarshal");
    mImpl->log("finish vkCmdCopyImage");;
}

void VkEncoder::vkCmdBlitImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageBlit* pRegions,
    VkFilter filter)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBlitImage encode");
    mImpl->log("start vkCmdBlitImage");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageBlit* local_pRegions;
    VkFilter local_filter;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageBlit*)pool->alloc(((regionCount)) * sizeof(const VkImageBlit));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageBlit(pool, pRegions + i, (VkImageBlit*)(local_pRegions + i));
        }
    }
    local_filter = filter;
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageBlit(mImpl->resources(), (VkImageBlit*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_571;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_571, 1);
        countingStream->write((uint64_t*)&cgen_var_571, 1 * 8);
        uint64_t cgen_var_572;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_572, 1);
        countingStream->write((uint64_t*)&cgen_var_572, 1 * 8);
        countingStream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
        uint64_t cgen_var_573;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_573, 1);
        countingStream->write((uint64_t*)&cgen_var_573, 1 * 8);
        countingStream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageBlit(countingStream, (VkImageBlit*)(local_pRegions + i));
        }
        countingStream->write((VkFilter*)&local_filter, sizeof(VkFilter));
    }
    uint32_t packetSize_vkCmdBlitImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBlitImage = OP_vkCmdBlitImage;
    stream->write(&opcode_vkCmdBlitImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBlitImage, sizeof(uint32_t));
    uint64_t cgen_var_574;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_574, 1);
    stream->write((uint64_t*)&cgen_var_574, 1 * 8);
    uint64_t cgen_var_575;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_575, 1);
    stream->write((uint64_t*)&cgen_var_575, 1 * 8);
    stream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_576;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_576, 1);
    stream->write((uint64_t*)&cgen_var_576, 1 * 8);
    stream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageBlit(stream, (VkImageBlit*)(local_pRegions + i));
    }
    stream->write((VkFilter*)&local_filter, sizeof(VkFilter));
    AEMU_SCOPED_TRACE("vkCmdBlitImage readParams");
    AEMU_SCOPED_TRACE("vkCmdBlitImage returnUnmarshal");
    mImpl->log("finish vkCmdBlitImage");;
}

void VkEncoder::vkCmdCopyBufferToImage(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage encode");
    mImpl->log("start vkCmdCopyBufferToImage");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_srcBuffer;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkBufferImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcBuffer = srcBuffer;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferImageCopy(pool, pRegions + i, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferImageCopy(mImpl->resources(), (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_577;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_577, 1);
        countingStream->write((uint64_t*)&cgen_var_577, 1 * 8);
        uint64_t cgen_var_578;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_srcBuffer, &cgen_var_578, 1);
        countingStream->write((uint64_t*)&cgen_var_578, 1 * 8);
        uint64_t cgen_var_579;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_579, 1);
        countingStream->write((uint64_t*)&cgen_var_579, 1 * 8);
        countingStream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferImageCopy(countingStream, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyBufferToImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyBufferToImage = OP_vkCmdCopyBufferToImage;
    stream->write(&opcode_vkCmdCopyBufferToImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyBufferToImage, sizeof(uint32_t));
    uint64_t cgen_var_580;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_580, 1);
    stream->write((uint64_t*)&cgen_var_580, 1 * 8);
    uint64_t cgen_var_581;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_srcBuffer, &cgen_var_581, 1);
    stream->write((uint64_t*)&cgen_var_581, 1 * 8);
    uint64_t cgen_var_582;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_582, 1);
    stream->write((uint64_t*)&cgen_var_582, 1 * 8);
    stream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferImageCopy(stream, (VkBufferImageCopy*)(local_pRegions + i));
    }
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage readParams");
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage returnUnmarshal");
    mImpl->log("finish vkCmdCopyBufferToImage");;
}

void VkEncoder::vkCmdCopyImageToBuffer(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer encode");
    mImpl->log("start vkCmdCopyImageToBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkBuffer local_dstBuffer;
    uint32_t local_regionCount;
    VkBufferImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstBuffer = dstBuffer;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferImageCopy(pool, pRegions + i, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferImageCopy(mImpl->resources(), (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_583;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_583, 1);
        countingStream->write((uint64_t*)&cgen_var_583, 1 * 8);
        uint64_t cgen_var_584;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_584, 1);
        countingStream->write((uint64_t*)&cgen_var_584, 1 * 8);
        countingStream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
        uint64_t cgen_var_585;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_585, 1);
        countingStream->write((uint64_t*)&cgen_var_585, 1 * 8);
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferImageCopy(countingStream, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyImageToBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyImageToBuffer = OP_vkCmdCopyImageToBuffer;
    stream->write(&opcode_vkCmdCopyImageToBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyImageToBuffer, sizeof(uint32_t));
    uint64_t cgen_var_586;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_586, 1);
    stream->write((uint64_t*)&cgen_var_586, 1 * 8);
    uint64_t cgen_var_587;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_587, 1);
    stream->write((uint64_t*)&cgen_var_587, 1 * 8);
    stream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_588;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_588, 1);
    stream->write((uint64_t*)&cgen_var_588, 1 * 8);
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferImageCopy(stream, (VkBufferImageCopy*)(local_pRegions + i));
    }
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer readParams");
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer returnUnmarshal");
    mImpl->log("finish vkCmdCopyImageToBuffer");;
}

void VkEncoder::vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize dataSize,
    const void* pData)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdUpdateBuffer encode");
    mImpl->log("start vkCmdUpdateBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_dataSize;
    void* local_pData;
    local_commandBuffer = commandBuffer;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_dataSize = dataSize;
    local_pData = nullptr;
    if (pData)
    {
        local_pData = (void*)pool->dupArray(pData, ((dataSize)) * sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_589;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_589, 1);
        countingStream->write((uint64_t*)&cgen_var_589, 1 * 8);
        uint64_t cgen_var_590;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_590, 1);
        countingStream->write((uint64_t*)&cgen_var_590, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&local_dataSize, sizeof(VkDeviceSize));
        countingStream->write((void*)local_pData, ((dataSize)) * sizeof(uint8_t));
    }
    uint32_t packetSize_vkCmdUpdateBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdUpdateBuffer = OP_vkCmdUpdateBuffer;
    stream->write(&opcode_vkCmdUpdateBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdUpdateBuffer, sizeof(uint32_t));
    uint64_t cgen_var_591;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_591, 1);
    stream->write((uint64_t*)&cgen_var_591, 1 * 8);
    uint64_t cgen_var_592;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_592, 1);
    stream->write((uint64_t*)&cgen_var_592, 1 * 8);
    stream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&local_dataSize, sizeof(VkDeviceSize));
    stream->write((void*)local_pData, ((dataSize)) * sizeof(uint8_t));
    AEMU_SCOPED_TRACE("vkCmdUpdateBuffer readParams");
    AEMU_SCOPED_TRACE("vkCmdUpdateBuffer returnUnmarshal");
    mImpl->log("finish vkCmdUpdateBuffer");;
}

void VkEncoder::vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize size,
    uint32_t data)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdFillBuffer encode");
    mImpl->log("start vkCmdFillBuffer");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_size;
    uint32_t local_data;
    local_commandBuffer = commandBuffer;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_size = size;
    local_data = data;
    countingStream->rewind();
    {
        uint64_t cgen_var_593;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_593, 1);
        countingStream->write((uint64_t*)&cgen_var_593, 1 * 8);
        uint64_t cgen_var_594;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_594, 1);
        countingStream->write((uint64_t*)&cgen_var_594, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&local_size, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_data, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdFillBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdFillBuffer = OP_vkCmdFillBuffer;
    stream->write(&opcode_vkCmdFillBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdFillBuffer, sizeof(uint32_t));
    uint64_t cgen_var_595;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_595, 1);
    stream->write((uint64_t*)&cgen_var_595, 1 * 8);
    uint64_t cgen_var_596;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_596, 1);
    stream->write((uint64_t*)&cgen_var_596, 1 * 8);
    stream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&local_size, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_data, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdFillBuffer readParams");
    AEMU_SCOPED_TRACE("vkCmdFillBuffer returnUnmarshal");
    mImpl->log("finish vkCmdFillBuffer");;
}

void VkEncoder::vkCmdClearColorImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearColorValue* pColor,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdClearColorImage encode");
    mImpl->log("start vkCmdClearColorImage");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_image;
    VkImageLayout local_imageLayout;
    VkClearColorValue* local_pColor;
    uint32_t local_rangeCount;
    VkImageSubresourceRange* local_pRanges;
    local_commandBuffer = commandBuffer;
    local_image = image;
    local_imageLayout = imageLayout;
    local_pColor = nullptr;
    if (pColor)
    {
        local_pColor = (VkClearColorValue*)pool->alloc(sizeof(const VkClearColorValue));
        deepcopy_VkClearColorValue(pool, pColor, (VkClearColorValue*)(local_pColor));
    }
    local_rangeCount = rangeCount;
    local_pRanges = nullptr;
    if (pRanges)
    {
        local_pRanges = (VkImageSubresourceRange*)pool->alloc(((rangeCount)) * sizeof(const VkImageSubresourceRange));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            deepcopy_VkImageSubresourceRange(pool, pRanges + i, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    if (local_pColor)
    {
        transform_tohost_VkClearColorValue(mImpl->resources(), (VkClearColorValue*)(local_pColor));
    }
    if (local_pRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            transform_tohost_VkImageSubresourceRange(mImpl->resources(), (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_597;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_597, 1);
        countingStream->write((uint64_t*)&cgen_var_597, 1 * 8);
        uint64_t cgen_var_598;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_598, 1);
        countingStream->write((uint64_t*)&cgen_var_598, 1 * 8);
        countingStream->write((VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
        marshal_VkClearColorValue(countingStream, (VkClearColorValue*)(local_pColor));
        countingStream->write((uint32_t*)&local_rangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            marshal_VkImageSubresourceRange(countingStream, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    uint32_t packetSize_vkCmdClearColorImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearColorImage = OP_vkCmdClearColorImage;
    stream->write(&opcode_vkCmdClearColorImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearColorImage, sizeof(uint32_t));
    uint64_t cgen_var_599;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_599, 1);
    stream->write((uint64_t*)&cgen_var_599, 1 * 8);
    uint64_t cgen_var_600;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_600, 1);
    stream->write((uint64_t*)&cgen_var_600, 1 * 8);
    stream->write((VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    marshal_VkClearColorValue(stream, (VkClearColorValue*)(local_pColor));
    stream->write((uint32_t*)&local_rangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        marshal_VkImageSubresourceRange(stream, (VkImageSubresourceRange*)(local_pRanges + i));
    }
    AEMU_SCOPED_TRACE("vkCmdClearColorImage readParams");
    AEMU_SCOPED_TRACE("vkCmdClearColorImage returnUnmarshal");
    mImpl->log("finish vkCmdClearColorImage");;
}

void VkEncoder::vkCmdClearDepthStencilImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdClearDepthStencilImage encode");
    mImpl->log("start vkCmdClearDepthStencilImage");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_image;
    VkImageLayout local_imageLayout;
    VkClearDepthStencilValue* local_pDepthStencil;
    uint32_t local_rangeCount;
    VkImageSubresourceRange* local_pRanges;
    local_commandBuffer = commandBuffer;
    local_image = image;
    local_imageLayout = imageLayout;
    local_pDepthStencil = nullptr;
    if (pDepthStencil)
    {
        local_pDepthStencil = (VkClearDepthStencilValue*)pool->alloc(sizeof(const VkClearDepthStencilValue));
        deepcopy_VkClearDepthStencilValue(pool, pDepthStencil, (VkClearDepthStencilValue*)(local_pDepthStencil));
    }
    local_rangeCount = rangeCount;
    local_pRanges = nullptr;
    if (pRanges)
    {
        local_pRanges = (VkImageSubresourceRange*)pool->alloc(((rangeCount)) * sizeof(const VkImageSubresourceRange));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            deepcopy_VkImageSubresourceRange(pool, pRanges + i, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    if (local_pDepthStencil)
    {
        transform_tohost_VkClearDepthStencilValue(mImpl->resources(), (VkClearDepthStencilValue*)(local_pDepthStencil));
    }
    if (local_pRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            transform_tohost_VkImageSubresourceRange(mImpl->resources(), (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_601;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_601, 1);
        countingStream->write((uint64_t*)&cgen_var_601, 1 * 8);
        uint64_t cgen_var_602;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_602, 1);
        countingStream->write((uint64_t*)&cgen_var_602, 1 * 8);
        countingStream->write((VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
        marshal_VkClearDepthStencilValue(countingStream, (VkClearDepthStencilValue*)(local_pDepthStencil));
        countingStream->write((uint32_t*)&local_rangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            marshal_VkImageSubresourceRange(countingStream, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    uint32_t packetSize_vkCmdClearDepthStencilImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearDepthStencilImage = OP_vkCmdClearDepthStencilImage;
    stream->write(&opcode_vkCmdClearDepthStencilImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearDepthStencilImage, sizeof(uint32_t));
    uint64_t cgen_var_603;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_603, 1);
    stream->write((uint64_t*)&cgen_var_603, 1 * 8);
    uint64_t cgen_var_604;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_604, 1);
    stream->write((uint64_t*)&cgen_var_604, 1 * 8);
    stream->write((VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    marshal_VkClearDepthStencilValue(stream, (VkClearDepthStencilValue*)(local_pDepthStencil));
    stream->write((uint32_t*)&local_rangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        marshal_VkImageSubresourceRange(stream, (VkImageSubresourceRange*)(local_pRanges + i));
    }
    AEMU_SCOPED_TRACE("vkCmdClearDepthStencilImage readParams");
    AEMU_SCOPED_TRACE("vkCmdClearDepthStencilImage returnUnmarshal");
    mImpl->log("finish vkCmdClearDepthStencilImage");;
}

void VkEncoder::vkCmdClearAttachments(
    VkCommandBuffer commandBuffer,
    uint32_t attachmentCount,
    const VkClearAttachment* pAttachments,
    uint32_t rectCount,
    const VkClearRect* pRects)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdClearAttachments encode");
    mImpl->log("start vkCmdClearAttachments");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_attachmentCount;
    VkClearAttachment* local_pAttachments;
    uint32_t local_rectCount;
    VkClearRect* local_pRects;
    local_commandBuffer = commandBuffer;
    local_attachmentCount = attachmentCount;
    local_pAttachments = nullptr;
    if (pAttachments)
    {
        local_pAttachments = (VkClearAttachment*)pool->alloc(((attachmentCount)) * sizeof(const VkClearAttachment));
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            deepcopy_VkClearAttachment(pool, pAttachments + i, (VkClearAttachment*)(local_pAttachments + i));
        }
    }
    local_rectCount = rectCount;
    local_pRects = nullptr;
    if (pRects)
    {
        local_pRects = (VkClearRect*)pool->alloc(((rectCount)) * sizeof(const VkClearRect));
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            deepcopy_VkClearRect(pool, pRects + i, (VkClearRect*)(local_pRects + i));
        }
    }
    if (local_pAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            transform_tohost_VkClearAttachment(mImpl->resources(), (VkClearAttachment*)(local_pAttachments + i));
        }
    }
    if (local_pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            transform_tohost_VkClearRect(mImpl->resources(), (VkClearRect*)(local_pRects + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_605;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_605, 1);
        countingStream->write((uint64_t*)&cgen_var_605, 1 * 8);
        countingStream->write((uint32_t*)&local_attachmentCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            marshal_VkClearAttachment(countingStream, (VkClearAttachment*)(local_pAttachments + i));
        }
        countingStream->write((uint32_t*)&local_rectCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            marshal_VkClearRect(countingStream, (VkClearRect*)(local_pRects + i));
        }
    }
    uint32_t packetSize_vkCmdClearAttachments = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearAttachments = OP_vkCmdClearAttachments;
    stream->write(&opcode_vkCmdClearAttachments, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearAttachments, sizeof(uint32_t));
    uint64_t cgen_var_606;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_606, 1);
    stream->write((uint64_t*)&cgen_var_606, 1 * 8);
    stream->write((uint32_t*)&local_attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
    {
        marshal_VkClearAttachment(stream, (VkClearAttachment*)(local_pAttachments + i));
    }
    stream->write((uint32_t*)&local_rectCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
    {
        marshal_VkClearRect(stream, (VkClearRect*)(local_pRects + i));
    }
    AEMU_SCOPED_TRACE("vkCmdClearAttachments readParams");
    AEMU_SCOPED_TRACE("vkCmdClearAttachments returnUnmarshal");
    mImpl->log("finish vkCmdClearAttachments");;
}

void VkEncoder::vkCmdResolveImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageResolve* pRegions)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdResolveImage encode");
    mImpl->log("start vkCmdResolveImage");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageResolve* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageResolve*)pool->alloc(((regionCount)) * sizeof(const VkImageResolve));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageResolve(pool, pRegions + i, (VkImageResolve*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageResolve(mImpl->resources(), (VkImageResolve*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_607;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_607, 1);
        countingStream->write((uint64_t*)&cgen_var_607, 1 * 8);
        uint64_t cgen_var_608;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_608, 1);
        countingStream->write((uint64_t*)&cgen_var_608, 1 * 8);
        countingStream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
        uint64_t cgen_var_609;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_609, 1);
        countingStream->write((uint64_t*)&cgen_var_609, 1 * 8);
        countingStream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageResolve(countingStream, (VkImageResolve*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdResolveImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResolveImage = OP_vkCmdResolveImage;
    stream->write(&opcode_vkCmdResolveImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResolveImage, sizeof(uint32_t));
    uint64_t cgen_var_610;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_610, 1);
    stream->write((uint64_t*)&cgen_var_610, 1 * 8);
    uint64_t cgen_var_611;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_611, 1);
    stream->write((uint64_t*)&cgen_var_611, 1 * 8);
    stream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_612;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_612, 1);
    stream->write((uint64_t*)&cgen_var_612, 1 * 8);
    stream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageResolve(stream, (VkImageResolve*)(local_pRegions + i));
    }
    AEMU_SCOPED_TRACE("vkCmdResolveImage readParams");
    AEMU_SCOPED_TRACE("vkCmdResolveImage returnUnmarshal");
    mImpl->log("finish vkCmdResolveImage");;
}

void VkEncoder::vkCmdSetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetEvent encode");
    mImpl->log("start vkCmdSetEvent");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkEvent local_event;
    VkPipelineStageFlags local_stageMask;
    local_commandBuffer = commandBuffer;
    local_event = event;
    local_stageMask = stageMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_613;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_613, 1);
        countingStream->write((uint64_t*)&cgen_var_613, 1 * 8);
        uint64_t cgen_var_614;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_614, 1);
        countingStream->write((uint64_t*)&cgen_var_614, 1 * 8);
        countingStream->write((VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    }
    uint32_t packetSize_vkCmdSetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetEvent = OP_vkCmdSetEvent;
    stream->write(&opcode_vkCmdSetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetEvent, sizeof(uint32_t));
    uint64_t cgen_var_615;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_615, 1);
    stream->write((uint64_t*)&cgen_var_615, 1 * 8);
    uint64_t cgen_var_616;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_616, 1);
    stream->write((uint64_t*)&cgen_var_616, 1 * 8);
    stream->write((VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    AEMU_SCOPED_TRACE("vkCmdSetEvent readParams");
    AEMU_SCOPED_TRACE("vkCmdSetEvent returnUnmarshal");
    mImpl->log("finish vkCmdSetEvent");;
}

void VkEncoder::vkCmdResetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdResetEvent encode");
    mImpl->log("start vkCmdResetEvent");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkEvent local_event;
    VkPipelineStageFlags local_stageMask;
    local_commandBuffer = commandBuffer;
    local_event = event;
    local_stageMask = stageMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_617;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_617, 1);
        countingStream->write((uint64_t*)&cgen_var_617, 1 * 8);
        uint64_t cgen_var_618;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_618, 1);
        countingStream->write((uint64_t*)&cgen_var_618, 1 * 8);
        countingStream->write((VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    }
    uint32_t packetSize_vkCmdResetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResetEvent = OP_vkCmdResetEvent;
    stream->write(&opcode_vkCmdResetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResetEvent, sizeof(uint32_t));
    uint64_t cgen_var_619;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_619, 1);
    stream->write((uint64_t*)&cgen_var_619, 1 * 8);
    uint64_t cgen_var_620;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_620, 1);
    stream->write((uint64_t*)&cgen_var_620, 1 * 8);
    stream->write((VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    AEMU_SCOPED_TRACE("vkCmdResetEvent readParams");
    AEMU_SCOPED_TRACE("vkCmdResetEvent returnUnmarshal");
    mImpl->log("finish vkCmdResetEvent");;
}

void VkEncoder::vkCmdWaitEvents(
    VkCommandBuffer commandBuffer,
    uint32_t eventCount,
    const VkEvent* pEvents,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdWaitEvents encode");
    mImpl->log("start vkCmdWaitEvents");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_eventCount;
    VkEvent* local_pEvents;
    VkPipelineStageFlags local_srcStageMask;
    VkPipelineStageFlags local_dstStageMask;
    uint32_t local_memoryBarrierCount;
    VkMemoryBarrier* local_pMemoryBarriers;
    uint32_t local_bufferMemoryBarrierCount;
    VkBufferMemoryBarrier* local_pBufferMemoryBarriers;
    uint32_t local_imageMemoryBarrierCount;
    VkImageMemoryBarrier* local_pImageMemoryBarriers;
    local_commandBuffer = commandBuffer;
    local_eventCount = eventCount;
    local_pEvents = nullptr;
    if (pEvents)
    {
        local_pEvents = (VkEvent*)pool->dupArray(pEvents, ((eventCount)) * sizeof(const VkEvent));
    }
    local_srcStageMask = srcStageMask;
    local_dstStageMask = dstStageMask;
    local_memoryBarrierCount = memoryBarrierCount;
    local_pMemoryBarriers = nullptr;
    if (pMemoryBarriers)
    {
        local_pMemoryBarriers = (VkMemoryBarrier*)pool->alloc(((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            deepcopy_VkMemoryBarrier(pool, pMemoryBarriers + i, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    local_bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    local_pBufferMemoryBarriers = nullptr;
    if (pBufferMemoryBarriers)
    {
        local_pBufferMemoryBarriers = (VkBufferMemoryBarrier*)pool->alloc(((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            deepcopy_VkBufferMemoryBarrier(pool, pBufferMemoryBarriers + i, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    local_imageMemoryBarrierCount = imageMemoryBarrierCount;
    local_pImageMemoryBarriers = nullptr;
    if (pImageMemoryBarriers)
    {
        local_pImageMemoryBarriers = (VkImageMemoryBarrier*)pool->alloc(((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            deepcopy_VkImageMemoryBarrier(pool, pImageMemoryBarriers + i, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    if (local_pMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            transform_tohost_VkMemoryBarrier(mImpl->resources(), (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    if (local_pBufferMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkBufferMemoryBarrier(mImpl->resources(), (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    if (local_pImageMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkImageMemoryBarrier(mImpl->resources(), (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_621;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_621, 1);
        countingStream->write((uint64_t*)&cgen_var_621, 1 * 8);
        countingStream->write((uint32_t*)&local_eventCount, sizeof(uint32_t));
        if (((eventCount)))
        {
            uint64_t* cgen_var_622;
            countingStream->alloc((void**)&cgen_var_622, ((eventCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkEvent_u64(local_pEvents, cgen_var_622, ((eventCount)));
            countingStream->write((uint64_t*)cgen_var_622, ((eventCount)) * 8);
        }
        countingStream->write((VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            marshal_VkMemoryBarrier(countingStream, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            marshal_VkBufferMemoryBarrier(countingStream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            marshal_VkImageMemoryBarrier(countingStream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    uint32_t packetSize_vkCmdWaitEvents = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWaitEvents = OP_vkCmdWaitEvents;
    stream->write(&opcode_vkCmdWaitEvents, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWaitEvents, sizeof(uint32_t));
    uint64_t cgen_var_623;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_623, 1);
    stream->write((uint64_t*)&cgen_var_623, 1 * 8);
    stream->write((uint32_t*)&local_eventCount, sizeof(uint32_t));
    if (((eventCount)))
    {
        uint64_t* cgen_var_624;
        stream->alloc((void**)&cgen_var_624, ((eventCount)) * 8);
        stream->handleMapping()->mapHandles_VkEvent_u64(local_pEvents, cgen_var_624, ((eventCount)));
        stream->write((uint64_t*)cgen_var_624, ((eventCount)) * 8);
    }
    stream->write((VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
    stream->write((uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        marshal_VkMemoryBarrier(stream, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
    }
    stream->write((uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        marshal_VkBufferMemoryBarrier(stream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
    }
    stream->write((uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        marshal_VkImageMemoryBarrier(stream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
    }
    AEMU_SCOPED_TRACE("vkCmdWaitEvents readParams");
    AEMU_SCOPED_TRACE("vkCmdWaitEvents returnUnmarshal");
    mImpl->log("finish vkCmdWaitEvents");;
}

void VkEncoder::vkCmdPipelineBarrier(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier encode");
    mImpl->log("start vkCmdPipelineBarrier");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlags local_srcStageMask;
    VkPipelineStageFlags local_dstStageMask;
    VkDependencyFlags local_dependencyFlags;
    uint32_t local_memoryBarrierCount;
    VkMemoryBarrier* local_pMemoryBarriers;
    uint32_t local_bufferMemoryBarrierCount;
    VkBufferMemoryBarrier* local_pBufferMemoryBarriers;
    uint32_t local_imageMemoryBarrierCount;
    VkImageMemoryBarrier* local_pImageMemoryBarriers;
    local_commandBuffer = commandBuffer;
    local_srcStageMask = srcStageMask;
    local_dstStageMask = dstStageMask;
    local_dependencyFlags = dependencyFlags;
    local_memoryBarrierCount = memoryBarrierCount;
    local_pMemoryBarriers = nullptr;
    if (pMemoryBarriers)
    {
        local_pMemoryBarriers = (VkMemoryBarrier*)pool->alloc(((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            deepcopy_VkMemoryBarrier(pool, pMemoryBarriers + i, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    local_bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    local_pBufferMemoryBarriers = nullptr;
    if (pBufferMemoryBarriers)
    {
        local_pBufferMemoryBarriers = (VkBufferMemoryBarrier*)pool->alloc(((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            deepcopy_VkBufferMemoryBarrier(pool, pBufferMemoryBarriers + i, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    local_imageMemoryBarrierCount = imageMemoryBarrierCount;
    local_pImageMemoryBarriers = nullptr;
    if (pImageMemoryBarriers)
    {
        local_pImageMemoryBarriers = (VkImageMemoryBarrier*)pool->alloc(((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            deepcopy_VkImageMemoryBarrier(pool, pImageMemoryBarriers + i, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    if (local_pMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            transform_tohost_VkMemoryBarrier(mImpl->resources(), (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    if (local_pBufferMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkBufferMemoryBarrier(mImpl->resources(), (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    if (local_pImageMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkImageMemoryBarrier(mImpl->resources(), (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_625;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_625, 1);
        countingStream->write((uint64_t*)&cgen_var_625, 1 * 8);
        countingStream->write((VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkDependencyFlags*)&local_dependencyFlags, sizeof(VkDependencyFlags));
        countingStream->write((uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            marshal_VkMemoryBarrier(countingStream, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            marshal_VkBufferMemoryBarrier(countingStream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            marshal_VkImageMemoryBarrier(countingStream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    uint32_t packetSize_vkCmdPipelineBarrier = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPipelineBarrier = OP_vkCmdPipelineBarrier;
    stream->write(&opcode_vkCmdPipelineBarrier, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPipelineBarrier, sizeof(uint32_t));
    uint64_t cgen_var_626;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_626, 1);
    stream->write((uint64_t*)&cgen_var_626, 1 * 8);
    stream->write((VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkDependencyFlags*)&local_dependencyFlags, sizeof(VkDependencyFlags));
    stream->write((uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        marshal_VkMemoryBarrier(stream, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
    }
    stream->write((uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        marshal_VkBufferMemoryBarrier(stream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
    }
    stream->write((uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        marshal_VkImageMemoryBarrier(stream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
    }
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier readParams");
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier returnUnmarshal");
    mImpl->log("finish vkCmdPipelineBarrier");;
}

void VkEncoder::vkCmdBeginQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBeginQuery encode");
    mImpl->log("start vkCmdBeginQuery");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    VkQueryControlFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_627;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_627, 1);
        countingStream->write((uint64_t*)&cgen_var_627, 1 * 8);
        uint64_t cgen_var_628;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_628, 1);
        countingStream->write((uint64_t*)&cgen_var_628, 1 * 8);
        countingStream->write((uint32_t*)&local_query, sizeof(uint32_t));
        countingStream->write((VkQueryControlFlags*)&local_flags, sizeof(VkQueryControlFlags));
    }
    uint32_t packetSize_vkCmdBeginQuery = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginQuery = OP_vkCmdBeginQuery;
    stream->write(&opcode_vkCmdBeginQuery, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginQuery, sizeof(uint32_t));
    uint64_t cgen_var_629;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_629, 1);
    stream->write((uint64_t*)&cgen_var_629, 1 * 8);
    uint64_t cgen_var_630;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_630, 1);
    stream->write((uint64_t*)&cgen_var_630, 1 * 8);
    stream->write((uint32_t*)&local_query, sizeof(uint32_t));
    stream->write((VkQueryControlFlags*)&local_flags, sizeof(VkQueryControlFlags));
    AEMU_SCOPED_TRACE("vkCmdBeginQuery readParams");
    AEMU_SCOPED_TRACE("vkCmdBeginQuery returnUnmarshal");
    mImpl->log("finish vkCmdBeginQuery");;
}

void VkEncoder::vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdEndQuery encode");
    mImpl->log("start vkCmdEndQuery");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    countingStream->rewind();
    {
        uint64_t cgen_var_631;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_631, 1);
        countingStream->write((uint64_t*)&cgen_var_631, 1 * 8);
        uint64_t cgen_var_632;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_632, 1);
        countingStream->write((uint64_t*)&cgen_var_632, 1 * 8);
        countingStream->write((uint32_t*)&local_query, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdEndQuery = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndQuery = OP_vkCmdEndQuery;
    stream->write(&opcode_vkCmdEndQuery, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndQuery, sizeof(uint32_t));
    uint64_t cgen_var_633;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_633, 1);
    stream->write((uint64_t*)&cgen_var_633, 1 * 8);
    uint64_t cgen_var_634;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_634, 1);
    stream->write((uint64_t*)&cgen_var_634, 1 * 8);
    stream->write((uint32_t*)&local_query, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdEndQuery readParams");
    AEMU_SCOPED_TRACE("vkCmdEndQuery returnUnmarshal");
    mImpl->log("finish vkCmdEndQuery");;
}

void VkEncoder::vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdResetQueryPool encode");
    mImpl->log("start vkCmdResetQueryPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    countingStream->rewind();
    {
        uint64_t cgen_var_635;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_635, 1);
        countingStream->write((uint64_t*)&cgen_var_635, 1 * 8);
        uint64_t cgen_var_636;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_636, 1);
        countingStream->write((uint64_t*)&cgen_var_636, 1 * 8);
        countingStream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdResetQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResetQueryPool = OP_vkCmdResetQueryPool;
    stream->write(&opcode_vkCmdResetQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResetQueryPool, sizeof(uint32_t));
    uint64_t cgen_var_637;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_637, 1);
    stream->write((uint64_t*)&cgen_var_637, 1 * 8);
    uint64_t cgen_var_638;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_638, 1);
    stream->write((uint64_t*)&cgen_var_638, 1 * 8);
    stream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdResetQueryPool readParams");
    AEMU_SCOPED_TRACE("vkCmdResetQueryPool returnUnmarshal");
    mImpl->log("finish vkCmdResetQueryPool");;
}

void VkEncoder::vkCmdWriteTimestamp(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool queryPool,
    uint32_t query)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp encode");
    mImpl->log("start vkCmdWriteTimestamp");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlagBits local_pipelineStage;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    local_commandBuffer = commandBuffer;
    local_pipelineStage = pipelineStage;
    local_queryPool = queryPool;
    local_query = query;
    countingStream->rewind();
    {
        uint64_t cgen_var_639;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_639, 1);
        countingStream->write((uint64_t*)&cgen_var_639, 1 * 8);
        countingStream->write((VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
        uint64_t cgen_var_640;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_640, 1);
        countingStream->write((uint64_t*)&cgen_var_640, 1 * 8);
        countingStream->write((uint32_t*)&local_query, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdWriteTimestamp = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWriteTimestamp = OP_vkCmdWriteTimestamp;
    stream->write(&opcode_vkCmdWriteTimestamp, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWriteTimestamp, sizeof(uint32_t));
    uint64_t cgen_var_641;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_641, 1);
    stream->write((uint64_t*)&cgen_var_641, 1 * 8);
    stream->write((VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
    uint64_t cgen_var_642;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_642, 1);
    stream->write((uint64_t*)&cgen_var_642, 1 * 8);
    stream->write((uint32_t*)&local_query, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp readParams");
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp returnUnmarshal");
    mImpl->log("finish vkCmdWriteTimestamp");;
}

void VkEncoder::vkCmdCopyQueryPoolResults(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdCopyQueryPoolResults encode");
    mImpl->log("start vkCmdCopyQueryPoolResults");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_stride;
    VkQueryResultFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_stride = stride;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_643;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_643, 1);
        countingStream->write((uint64_t*)&cgen_var_643, 1 * 8);
        uint64_t cgen_var_644;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_644, 1);
        countingStream->write((uint64_t*)&cgen_var_644, 1 * 8);
        countingStream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
        uint64_t cgen_var_645;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_645, 1);
        countingStream->write((uint64_t*)&cgen_var_645, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
        countingStream->write((VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    }
    uint32_t packetSize_vkCmdCopyQueryPoolResults = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyQueryPoolResults = OP_vkCmdCopyQueryPoolResults;
    stream->write(&opcode_vkCmdCopyQueryPoolResults, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyQueryPoolResults, sizeof(uint32_t));
    uint64_t cgen_var_646;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_646, 1);
    stream->write((uint64_t*)&cgen_var_646, 1 * 8);
    uint64_t cgen_var_647;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_647, 1);
    stream->write((uint64_t*)&cgen_var_647, 1 * 8);
    stream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
    uint64_t cgen_var_648;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_648, 1);
    stream->write((uint64_t*)&cgen_var_648, 1 * 8);
    stream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
    stream->write((VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    AEMU_SCOPED_TRACE("vkCmdCopyQueryPoolResults readParams");
    AEMU_SCOPED_TRACE("vkCmdCopyQueryPoolResults returnUnmarshal");
    mImpl->log("finish vkCmdCopyQueryPoolResults");;
}

void VkEncoder::vkCmdPushConstants(
    VkCommandBuffer commandBuffer,
    VkPipelineLayout layout,
    VkShaderStageFlags stageFlags,
    uint32_t offset,
    uint32_t size,
    const void* pValues)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdPushConstants encode");
    mImpl->log("start vkCmdPushConstants");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineLayout local_layout;
    VkShaderStageFlags local_stageFlags;
    uint32_t local_offset;
    uint32_t local_size;
    void* local_pValues;
    local_commandBuffer = commandBuffer;
    local_layout = layout;
    local_stageFlags = stageFlags;
    local_offset = offset;
    local_size = size;
    local_pValues = nullptr;
    if (pValues)
    {
        local_pValues = (void*)pool->dupArray(pValues, ((size)) * sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_649;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_649, 1);
        countingStream->write((uint64_t*)&cgen_var_649, 1 * 8);
        uint64_t cgen_var_650;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_650, 1);
        countingStream->write((uint64_t*)&cgen_var_650, 1 * 8);
        countingStream->write((VkShaderStageFlags*)&local_stageFlags, sizeof(VkShaderStageFlags));
        countingStream->write((uint32_t*)&local_offset, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_size, sizeof(uint32_t));
        countingStream->write((void*)local_pValues, ((size)) * sizeof(uint8_t));
    }
    uint32_t packetSize_vkCmdPushConstants = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushConstants = OP_vkCmdPushConstants;
    stream->write(&opcode_vkCmdPushConstants, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushConstants, sizeof(uint32_t));
    uint64_t cgen_var_651;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_651, 1);
    stream->write((uint64_t*)&cgen_var_651, 1 * 8);
    uint64_t cgen_var_652;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_652, 1);
    stream->write((uint64_t*)&cgen_var_652, 1 * 8);
    stream->write((VkShaderStageFlags*)&local_stageFlags, sizeof(VkShaderStageFlags));
    stream->write((uint32_t*)&local_offset, sizeof(uint32_t));
    stream->write((uint32_t*)&local_size, sizeof(uint32_t));
    stream->write((void*)local_pValues, ((size)) * sizeof(uint8_t));
    AEMU_SCOPED_TRACE("vkCmdPushConstants readParams");
    AEMU_SCOPED_TRACE("vkCmdPushConstants returnUnmarshal");
    mImpl->log("finish vkCmdPushConstants");;
}

void VkEncoder::vkCmdBeginRenderPass(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents contents)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass encode");
    mImpl->log("start vkCmdBeginRenderPass");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassContents local_contents;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_contents = contents;
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(mImpl->resources(), (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_653;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_653, 1);
        countingStream->write((uint64_t*)&cgen_var_653, 1 * 8);
        marshal_VkRenderPassBeginInfo(countingStream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
        countingStream->write((VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    }
    uint32_t packetSize_vkCmdBeginRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginRenderPass = OP_vkCmdBeginRenderPass;
    stream->write(&opcode_vkCmdBeginRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginRenderPass, sizeof(uint32_t));
    uint64_t cgen_var_654;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_654, 1);
    stream->write((uint64_t*)&cgen_var_654, 1 * 8);
    marshal_VkRenderPassBeginInfo(stream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    stream->write((VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass readParams");
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass returnUnmarshal");
    mImpl->log("finish vkCmdBeginRenderPass");;
}

void VkEncoder::vkCmdNextSubpass(
    VkCommandBuffer commandBuffer,
    VkSubpassContents contents)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdNextSubpass encode");
    mImpl->log("start vkCmdNextSubpass");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkSubpassContents local_contents;
    local_commandBuffer = commandBuffer;
    local_contents = contents;
    countingStream->rewind();
    {
        uint64_t cgen_var_655;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_655, 1);
        countingStream->write((uint64_t*)&cgen_var_655, 1 * 8);
        countingStream->write((VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    }
    uint32_t packetSize_vkCmdNextSubpass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdNextSubpass = OP_vkCmdNextSubpass;
    stream->write(&opcode_vkCmdNextSubpass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdNextSubpass, sizeof(uint32_t));
    uint64_t cgen_var_656;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_656, 1);
    stream->write((uint64_t*)&cgen_var_656, 1 * 8);
    stream->write((VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    AEMU_SCOPED_TRACE("vkCmdNextSubpass readParams");
    AEMU_SCOPED_TRACE("vkCmdNextSubpass returnUnmarshal");
    mImpl->log("finish vkCmdNextSubpass");;
}

void VkEncoder::vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass encode");
    mImpl->log("start vkCmdEndRenderPass");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_657;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_657, 1);
        countingStream->write((uint64_t*)&cgen_var_657, 1 * 8);
    }
    uint32_t packetSize_vkCmdEndRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndRenderPass = OP_vkCmdEndRenderPass;
    stream->write(&opcode_vkCmdEndRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndRenderPass, sizeof(uint32_t));
    uint64_t cgen_var_658;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_658, 1);
    stream->write((uint64_t*)&cgen_var_658, 1 * 8);
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass readParams");
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass returnUnmarshal");
    mImpl->log("finish vkCmdEndRenderPass");;
}

void VkEncoder::vkCmdExecuteCommands(
    VkCommandBuffer commandBuffer,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdExecuteCommands encode");
    mImpl->log("start vkCmdExecuteCommands");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_commandBufferCount;
    VkCommandBuffer* local_pCommandBuffers;
    local_commandBuffer = commandBuffer;
    local_commandBufferCount = commandBufferCount;
    local_pCommandBuffers = nullptr;
    if (pCommandBuffers)
    {
        local_pCommandBuffers = (VkCommandBuffer*)pool->dupArray(pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_659;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_659, 1);
        countingStream->write((uint64_t*)&cgen_var_659, 1 * 8);
        countingStream->write((uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
        if (((commandBufferCount)))
        {
            uint64_t* cgen_var_660;
            countingStream->alloc((void**)&cgen_var_660, ((commandBufferCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(local_pCommandBuffers, cgen_var_660, ((commandBufferCount)));
            countingStream->write((uint64_t*)cgen_var_660, ((commandBufferCount)) * 8);
        }
    }
    uint32_t packetSize_vkCmdExecuteCommands = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdExecuteCommands = OP_vkCmdExecuteCommands;
    stream->write(&opcode_vkCmdExecuteCommands, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdExecuteCommands, sizeof(uint32_t));
    uint64_t cgen_var_661;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_661, 1);
    stream->write((uint64_t*)&cgen_var_661, 1 * 8);
    stream->write((uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
    if (((commandBufferCount)))
    {
        uint64_t* cgen_var_662;
        stream->alloc((void**)&cgen_var_662, ((commandBufferCount)) * 8);
        stream->handleMapping()->mapHandles_VkCommandBuffer_u64(local_pCommandBuffers, cgen_var_662, ((commandBufferCount)));
        stream->write((uint64_t*)cgen_var_662, ((commandBufferCount)) * 8);
    }
    AEMU_SCOPED_TRACE("vkCmdExecuteCommands readParams");
    AEMU_SCOPED_TRACE("vkCmdExecuteCommands returnUnmarshal");
    mImpl->log("finish vkCmdExecuteCommands");;
}

#endif
#ifdef VK_VERSION_1_1
VkResult VkEncoder::vkEnumerateInstanceVersion(
    uint32_t* pApiVersion)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEnumerateInstanceVersion encode");
    mImpl->log("start vkEnumerateInstanceVersion");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    countingStream->rewind();
    {
        countingStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
    }
    uint32_t packetSize_vkEnumerateInstanceVersion = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateInstanceVersion = OP_vkEnumerateInstanceVersion;
    stream->write(&opcode_vkEnumerateInstanceVersion, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateInstanceVersion, sizeof(uint32_t));
    stream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkEnumerateInstanceVersion readParams");
    stream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkEnumerateInstanceVersion returnUnmarshal");
    VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEnumerateInstanceVersion");;
    return vkEnumerateInstanceVersion_VkResult_return;
}

VkResult VkEncoder::vkBindBufferMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkBindBufferMemory2 encode");
    mImpl->log("start vkBindBufferMemory2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindBufferMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindBufferMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindBufferMemoryInfo(pool, pBindInfos + i, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindBufferMemoryInfo(mImpl->resources(), (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_663;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_663, 1);
        countingStream->write((uint64_t*)&cgen_var_663, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindBufferMemoryInfo(countingStream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindBufferMemory2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory2 = OP_vkBindBufferMemory2;
    stream->write(&opcode_vkBindBufferMemory2, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory2, sizeof(uint32_t));
    uint64_t cgen_var_664;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_664, 1);
    stream->write((uint64_t*)&cgen_var_664, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindBufferMemoryInfo(stream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
    }
    AEMU_SCOPED_TRACE("vkBindBufferMemory2 readParams");
    AEMU_SCOPED_TRACE("vkBindBufferMemory2 returnUnmarshal");
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkBindBufferMemory2");;
    return vkBindBufferMemory2_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkBindImageMemory2 encode");
    mImpl->log("start vkBindImageMemory2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindImageMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindImageMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindImageMemoryInfo(pool, pBindInfos + i, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindImageMemoryInfo(mImpl->resources(), (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_665;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_665, 1);
        countingStream->write((uint64_t*)&cgen_var_665, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindImageMemoryInfo(countingStream, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindImageMemory2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory2 = OP_vkBindImageMemory2;
    stream->write(&opcode_vkBindImageMemory2, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory2, sizeof(uint32_t));
    uint64_t cgen_var_666;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_666, 1);
    stream->write((uint64_t*)&cgen_var_666, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindImageMemoryInfo(stream, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
    }
    AEMU_SCOPED_TRACE("vkBindImageMemory2 readParams");
    AEMU_SCOPED_TRACE("vkBindImageMemory2 returnUnmarshal");
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkBindImageMemory2");;
    return vkBindImageMemory2_VkResult_return;
}

void VkEncoder::vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeatures encode");
    mImpl->log("start vkGetDeviceGroupPeerMemoryFeatures");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_heapIndex;
    uint32_t local_localDeviceIndex;
    uint32_t local_remoteDeviceIndex;
    local_device = device;
    local_heapIndex = heapIndex;
    local_localDeviceIndex = localDeviceIndex;
    local_remoteDeviceIndex = remoteDeviceIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_667;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_667, 1);
        countingStream->write((uint64_t*)&cgen_var_667, 1 * 8);
        countingStream->write((uint32_t*)&local_heapIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
        countingStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeatures = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeatures = OP_vkGetDeviceGroupPeerMemoryFeatures;
    stream->write(&opcode_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t));
    uint64_t cgen_var_668;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_668, 1);
    stream->write((uint64_t*)&cgen_var_668, 1 * 8);
    stream->write((uint32_t*)&local_heapIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
    stream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeatures readParams");
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeatures returnUnmarshal");
    mImpl->log("finish vkGetDeviceGroupPeerMemoryFeatures");;
}

void VkEncoder::vkCmdSetDeviceMask(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMask encode");
    mImpl->log("start vkCmdSetDeviceMask");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_deviceMask;
    local_commandBuffer = commandBuffer;
    local_deviceMask = deviceMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_669;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_669, 1);
        countingStream->write((uint64_t*)&cgen_var_669, 1 * 8);
        countingStream->write((uint32_t*)&local_deviceMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetDeviceMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDeviceMask = OP_vkCmdSetDeviceMask;
    stream->write(&opcode_vkCmdSetDeviceMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDeviceMask, sizeof(uint32_t));
    uint64_t cgen_var_670;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_670, 1);
    stream->write((uint64_t*)&cgen_var_670, 1 * 8);
    stream->write((uint32_t*)&local_deviceMask, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMask readParams");
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMask returnUnmarshal");
    mImpl->log("finish vkCmdSetDeviceMask");;
}

void VkEncoder::vkCmdDispatchBase(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDispatchBase encode");
    mImpl->log("start vkCmdDispatchBase");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_baseGroupX;
    uint32_t local_baseGroupY;
    uint32_t local_baseGroupZ;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_baseGroupX = baseGroupX;
    local_baseGroupY = baseGroupY;
    local_baseGroupZ = baseGroupZ;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    countingStream->rewind();
    {
        uint64_t cgen_var_671;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_671, 1);
        countingStream->write((uint64_t*)&cgen_var_671, 1 * 8);
        countingStream->write((uint32_t*)&local_baseGroupX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_baseGroupY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatchBase = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchBase = OP_vkCmdDispatchBase;
    stream->write(&opcode_vkCmdDispatchBase, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchBase, sizeof(uint32_t));
    uint64_t cgen_var_672;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_672, 1);
    stream->write((uint64_t*)&cgen_var_672, 1 * 8);
    stream->write((uint32_t*)&local_baseGroupX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_baseGroupY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDispatchBase readParams");
    AEMU_SCOPED_TRACE("vkCmdDispatchBase returnUnmarshal");
    mImpl->log("finish vkCmdDispatchBase");;
}

VkResult VkEncoder::vkEnumeratePhysicalDeviceGroups(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroups encode");
    mImpl->log("start vkEnumeratePhysicalDeviceGroups");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    local_instance = instance;
    countingStream->rewind();
    {
        uint64_t cgen_var_673;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_673, 1);
        countingStream->write((uint64_t*)&cgen_var_673, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_674 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
        countingStream->putBe64(cgen_var_674);
        if (pPhysicalDeviceGroupCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_675 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
        countingStream->putBe64(cgen_var_675);
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                marshal_VkPhysicalDeviceGroupProperties(countingStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroups = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDeviceGroups = OP_vkEnumeratePhysicalDeviceGroups;
    stream->write(&opcode_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t));
    uint64_t cgen_var_676;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_676, 1);
    stream->write((uint64_t*)&cgen_var_676, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_677 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
    stream->putBe64(cgen_var_677);
    if (pPhysicalDeviceGroupCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_678 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
    stream->putBe64(cgen_var_678);
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            marshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroups readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceGroupCount;
    check_pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    check_pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            unmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            transform_fromhost_VkPhysicalDeviceGroupProperties(mImpl->resources(), (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroups returnUnmarshal");
    VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEnumeratePhysicalDeviceGroups");;
    return vkEnumeratePhysicalDeviceGroups_VkResult_return;
}

void VkEncoder::vkGetImageMemoryRequirements2(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2 encode");
    mImpl->log("start vkGetImageMemoryRequirements2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageMemoryRequirementsInfo2));
        deepcopy_VkImageMemoryRequirementsInfo2(pool, pInfo, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageMemoryRequirementsInfo2(mImpl->resources(), (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_681;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_681, 1);
        countingStream->write((uint64_t*)&cgen_var_681, 1 * 8);
        marshal_VkImageMemoryRequirementsInfo2(countingStream, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements2 = OP_vkGetImageMemoryRequirements2;
    stream->write(&opcode_vkGetImageMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements2, sizeof(uint32_t));
    uint64_t cgen_var_682;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_682, 1);
    stream->write((uint64_t*)&cgen_var_682, 1 * 8);
    marshal_VkImageMemoryRequirementsInfo2(stream, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2 readParams");
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(mImpl->resources(), (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2 returnUnmarshal");
    mImpl->log("finish vkGetImageMemoryRequirements2");;
}

void VkEncoder::vkGetBufferMemoryRequirements2(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2 encode");
    mImpl->log("start vkGetBufferMemoryRequirements2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkBufferMemoryRequirementsInfo2));
        deepcopy_VkBufferMemoryRequirementsInfo2(pool, pInfo, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferMemoryRequirementsInfo2(mImpl->resources(), (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_683;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_683, 1);
        countingStream->write((uint64_t*)&cgen_var_683, 1 * 8);
        marshal_VkBufferMemoryRequirementsInfo2(countingStream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements2 = OP_vkGetBufferMemoryRequirements2;
    stream->write(&opcode_vkGetBufferMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements2, sizeof(uint32_t));
    uint64_t cgen_var_684;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_684, 1);
    stream->write((uint64_t*)&cgen_var_684, 1 * 8);
    marshal_VkBufferMemoryRequirementsInfo2(stream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2 readParams");
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(mImpl->resources(), (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2 returnUnmarshal");
    mImpl->log("finish vkGetBufferMemoryRequirements2");;
}

void VkEncoder::vkGetImageSparseMemoryRequirements2(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2 encode");
    mImpl->log("start vkGetImageSparseMemoryRequirements2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageSparseMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageSparseMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageSparseMemoryRequirementsInfo2));
        deepcopy_VkImageSparseMemoryRequirementsInfo2(pool, pInfo, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageSparseMemoryRequirementsInfo2(mImpl->resources(), (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_685;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_685, 1);
        countingStream->write((uint64_t*)&cgen_var_685, 1 * 8);
        marshal_VkImageSparseMemoryRequirementsInfo2(countingStream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_686 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
        countingStream->putBe64(cgen_var_686);
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_687 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
        countingStream->putBe64(cgen_var_687);
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements2(countingStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements2 = OP_vkGetImageSparseMemoryRequirements2;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t));
    uint64_t cgen_var_688;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_688, 1);
    stream->write((uint64_t*)&cgen_var_688, 1 * 8);
    marshal_VkImageSparseMemoryRequirementsInfo2(stream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_689 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    stream->putBe64(cgen_var_689);
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_690 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    stream->putBe64(cgen_var_690);
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2 readParams");
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements2(mImpl->resources(), (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2 returnUnmarshal");
    mImpl->log("finish vkGetImageSparseMemoryRequirements2");;
}

void VkEncoder::vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2 encode");
    mImpl->log("start vkGetPhysicalDeviceFeatures2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_693;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_693, 1);
        countingStream->write((uint64_t*)&cgen_var_693, 1 * 8);
        marshal_VkPhysicalDeviceFeatures2(countingStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures2 = OP_vkGetPhysicalDeviceFeatures2;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t));
    uint64_t cgen_var_694;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_694, 1);
    stream->write((uint64_t*)&cgen_var_694, 1 * 8);
    marshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2 readParams");
    unmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures2(mImpl->resources(), (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2 returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceFeatures2");;
}

void VkEncoder::vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2 encode");
    mImpl->log("start vkGetPhysicalDeviceProperties2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_695;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_695, 1);
        countingStream->write((uint64_t*)&cgen_var_695, 1 * 8);
        marshal_VkPhysicalDeviceProperties2(countingStream, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceProperties2 = OP_vkGetPhysicalDeviceProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceProperties2, sizeof(uint32_t));
    uint64_t cgen_var_696;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_696, 1);
    stream->write((uint64_t*)&cgen_var_696, 1 * 8);
    marshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2 readParams");
    unmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties2(mImpl->resources(), (VkPhysicalDeviceProperties2*)(pProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2 returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceProperties2");;
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2 encode");
    mImpl->log("start vkGetPhysicalDeviceFormatProperties2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    countingStream->rewind();
    {
        uint64_t cgen_var_697;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_697, 1);
        countingStream->write((uint64_t*)&cgen_var_697, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        marshal_VkFormatProperties2(countingStream, (VkFormatProperties2*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2 = OP_vkGetPhysicalDeviceFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t));
    uint64_t cgen_var_698;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_698, 1);
    stream->write((uint64_t*)&cgen_var_698, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    marshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2 readParams");
    unmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties2(mImpl->resources(), (VkFormatProperties2*)(pFormatProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2 returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceFormatProperties2");;
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2 encode");
    mImpl->log("start vkGetPhysicalDeviceImageFormatProperties2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceImageFormatInfo2* local_pImageFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pImageFormatInfo = nullptr;
    if (pImageFormatInfo)
    {
        local_pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceImageFormatInfo2));
        deepcopy_VkPhysicalDeviceImageFormatInfo2(pool, pImageFormatInfo, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    if (local_pImageFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceImageFormatInfo2(mImpl->resources(), (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_699;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_699, 1);
        countingStream->write((uint64_t*)&cgen_var_699, 1 * 8);
        marshal_VkPhysicalDeviceImageFormatInfo2(countingStream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
        marshal_VkImageFormatProperties2(countingStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2 = OP_vkGetPhysicalDeviceImageFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t));
    uint64_t cgen_var_700;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_700, 1);
    stream->write((uint64_t*)&cgen_var_700, 1 * 8);
    marshal_VkPhysicalDeviceImageFormatInfo2(stream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    marshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2 readParams");
    unmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties2(mImpl->resources(), (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2 returnUnmarshal");
    VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceImageFormatProperties2");;
    return vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2 encode");
    mImpl->log("start vkGetPhysicalDeviceQueueFamilyProperties2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_701;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_701, 1);
        countingStream->write((uint64_t*)&cgen_var_701, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_702 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
        countingStream->putBe64(cgen_var_702);
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_703 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
        countingStream->putBe64(cgen_var_703);
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties2(countingStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2 = OP_vkGetPhysicalDeviceQueueFamilyProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t));
    uint64_t cgen_var_704;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_704, 1);
    stream->write((uint64_t*)&cgen_var_704, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_705 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    stream->putBe64(cgen_var_705);
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_706 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    stream->putBe64(cgen_var_706);
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2 readParams");
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties2(mImpl->resources(), (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2 returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceQueueFamilyProperties2");;
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2 encode");
    mImpl->log("start vkGetPhysicalDeviceMemoryProperties2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_709;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_709, 1);
        countingStream->write((uint64_t*)&cgen_var_709, 1 * 8);
        marshal_VkPhysicalDeviceMemoryProperties2(countingStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2 = OP_vkGetPhysicalDeviceMemoryProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t));
    uint64_t cgen_var_710;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_710, 1);
    stream->write((uint64_t*)&cgen_var_710, 1 * 8);
    marshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2 readParams");
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties2(mImpl->resources(), (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2 returnUnmarshal");
    encoderLock.unlock();
    mImpl->resources()->on_vkGetPhysicalDeviceMemoryProperties2(this, physicalDevice, pMemoryProperties);
    encoderLock.lock();
    mImpl->log("finish vkGetPhysicalDeviceMemoryProperties2");;
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2 encode");
    mImpl->log("start vkGetPhysicalDeviceSparseImageFormatProperties2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSparseImageFormatInfo2* local_pFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pFormatInfo = nullptr;
    if (pFormatInfo)
    {
        local_pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
        deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(pool, pFormatInfo, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    if (local_pFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(mImpl->resources(), (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_711;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_711, 1);
        countingStream->write((uint64_t*)&cgen_var_711, 1 * 8);
        marshal_VkPhysicalDeviceSparseImageFormatInfo2(countingStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_712 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_712);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_713 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_713);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties2(countingStream, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2 = OP_vkGetPhysicalDeviceSparseImageFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t));
    uint64_t cgen_var_714;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_714, 1);
    stream->write((uint64_t*)&cgen_var_714, 1 * 8);
    marshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_715 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_715);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_716 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_716);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2 readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties2* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties2(mImpl->resources(), (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2 returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceSparseImageFormatProperties2");;
}

void VkEncoder::vkTrimCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkTrimCommandPool encode");
    mImpl->log("start vkTrimCommandPool");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolTrimFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_719;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_719, 1);
        countingStream->write((uint64_t*)&cgen_var_719, 1 * 8);
        uint64_t cgen_var_720;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_720, 1);
        countingStream->write((uint64_t*)&cgen_var_720, 1 * 8);
        countingStream->write((VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    }
    uint32_t packetSize_vkTrimCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkTrimCommandPool = OP_vkTrimCommandPool;
    stream->write(&opcode_vkTrimCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkTrimCommandPool, sizeof(uint32_t));
    uint64_t cgen_var_721;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_721, 1);
    stream->write((uint64_t*)&cgen_var_721, 1 * 8);
    uint64_t cgen_var_722;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_722, 1);
    stream->write((uint64_t*)&cgen_var_722, 1 * 8);
    stream->write((VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    AEMU_SCOPED_TRACE("vkTrimCommandPool readParams");
    AEMU_SCOPED_TRACE("vkTrimCommandPool returnUnmarshal");
    mImpl->log("finish vkTrimCommandPool");;
}

void VkEncoder::vkGetDeviceQueue2(
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDeviceQueue2 encode");
    mImpl->log("start vkGetDeviceQueue2");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceQueueInfo2* local_pQueueInfo;
    local_device = device;
    local_pQueueInfo = nullptr;
    if (pQueueInfo)
    {
        local_pQueueInfo = (VkDeviceQueueInfo2*)pool->alloc(sizeof(const VkDeviceQueueInfo2));
        deepcopy_VkDeviceQueueInfo2(pool, pQueueInfo, (VkDeviceQueueInfo2*)(local_pQueueInfo));
    }
    if (local_pQueueInfo)
    {
        transform_tohost_VkDeviceQueueInfo2(mImpl->resources(), (VkDeviceQueueInfo2*)(local_pQueueInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_723;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_723, 1);
        countingStream->write((uint64_t*)&cgen_var_723, 1 * 8);
        marshal_VkDeviceQueueInfo2(countingStream, (VkDeviceQueueInfo2*)(local_pQueueInfo));
        uint64_t cgen_var_724;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_724, 1);
        countingStream->write((uint64_t*)&cgen_var_724, 8);
    }
    uint32_t packetSize_vkGetDeviceQueue2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceQueue2 = OP_vkGetDeviceQueue2;
    stream->write(&opcode_vkGetDeviceQueue2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceQueue2, sizeof(uint32_t));
    uint64_t cgen_var_725;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_725, 1);
    stream->write((uint64_t*)&cgen_var_725, 1 * 8);
    marshal_VkDeviceQueueInfo2(stream, (VkDeviceQueueInfo2*)(local_pQueueInfo));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_726;
    stream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_726, 1);
    stream->write((uint64_t*)&cgen_var_726, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkGetDeviceQueue2 readParams");
    uint64_t cgen_var_727;
    stream->read((uint64_t*)&cgen_var_727, 8);
    stream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_727, (VkQueue*)pQueue, 1);
    AEMU_SCOPED_TRACE("vkGetDeviceQueue2 returnUnmarshal");
    mImpl->log("finish vkGetDeviceQueue2");;
}

VkResult VkEncoder::vkCreateSamplerYcbcrConversion(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversion encode");
    mImpl->log("start vkCreateSamplerYcbcrConversion");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerYcbcrConversionCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerYcbcrConversionCreateInfo*)pool->alloc(sizeof(const VkSamplerYcbcrConversionCreateInfo));
        deepcopy_VkSamplerYcbcrConversionCreateInfo(pool, pCreateInfo, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerYcbcrConversionCreateInfo(mImpl->resources(), (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_728;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_728, 1);
        countingStream->write((uint64_t*)&cgen_var_728, 1 * 8);
        marshal_VkSamplerYcbcrConversionCreateInfo(countingStream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_729 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_729);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_730;
        countingStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_730, 1);
        countingStream->write((uint64_t*)&cgen_var_730, 8);
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversion = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSamplerYcbcrConversion = OP_vkCreateSamplerYcbcrConversion;
    stream->write(&opcode_vkCreateSamplerYcbcrConversion, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSamplerYcbcrConversion, sizeof(uint32_t));
    uint64_t cgen_var_731;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_731, 1);
    stream->write((uint64_t*)&cgen_var_731, 1 * 8);
    marshal_VkSamplerYcbcrConversionCreateInfo(stream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_732 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_732);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_733;
    stream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_733, 1);
    stream->write((uint64_t*)&cgen_var_733, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversion readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_734;
    stream->read((uint64_t*)&cgen_var_734, 8);
    stream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_734, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversion returnUnmarshal");
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateSamplerYcbcrConversion");;
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversion(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversion encode");
    mImpl->log("start vkDestroySamplerYcbcrConversion");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerYcbcrConversion local_ycbcrConversion;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_ycbcrConversion = ycbcrConversion;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_735;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_735, 1);
        countingStream->write((uint64_t*)&cgen_var_735, 1 * 8);
        uint64_t cgen_var_736;
        countingStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&local_ycbcrConversion, &cgen_var_736, 1);
        countingStream->write((uint64_t*)&cgen_var_736, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_737 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_737);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversion = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySamplerYcbcrConversion = OP_vkDestroySamplerYcbcrConversion;
    stream->write(&opcode_vkDestroySamplerYcbcrConversion, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySamplerYcbcrConversion, sizeof(uint32_t));
    uint64_t cgen_var_738;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_738, 1);
    stream->write((uint64_t*)&cgen_var_738, 1 * 8);
    uint64_t cgen_var_739;
    stream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&local_ycbcrConversion, &cgen_var_739, 1);
    stream->write((uint64_t*)&cgen_var_739, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_740 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_740);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversion readParams");
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversion returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&ycbcrConversion);
    mImpl->log("finish vkDestroySamplerYcbcrConversion");;
}

VkResult VkEncoder::vkCreateDescriptorUpdateTemplate(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplate encode");
    mImpl->log("start vkCreateDescriptorUpdateTemplate");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorUpdateTemplateCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo*)pool->alloc(sizeof(const VkDescriptorUpdateTemplateCreateInfo));
        deepcopy_VkDescriptorUpdateTemplateCreateInfo(pool, pCreateInfo, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorUpdateTemplateCreateInfo(mImpl->resources(), (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_741;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_741, 1);
        countingStream->write((uint64_t*)&cgen_var_741, 1 * 8);
        marshal_VkDescriptorUpdateTemplateCreateInfo(countingStream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_742 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_742);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_743;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_743, 1);
        countingStream->write((uint64_t*)&cgen_var_743, 8);
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorUpdateTemplate = OP_vkCreateDescriptorUpdateTemplate;
    stream->write(&opcode_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t));
    uint64_t cgen_var_744;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_744, 1);
    stream->write((uint64_t*)&cgen_var_744, 1 * 8);
    marshal_VkDescriptorUpdateTemplateCreateInfo(stream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_745 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_745);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_746;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_746, 1);
    stream->write((uint64_t*)&cgen_var_746, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplate readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_747;
    stream->read((uint64_t*)&cgen_var_747, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_747, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplate returnUnmarshal");
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    encoderLock.unlock();
    mImpl->resources()->on_vkCreateDescriptorUpdateTemplate(this, vkCreateDescriptorUpdateTemplate_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    encoderLock.lock();
    mImpl->log("finish vkCreateDescriptorUpdateTemplate");;
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplate(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplate encode");
    mImpl->log("start vkDestroyDescriptorUpdateTemplate");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_748;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_748, 1);
        countingStream->write((uint64_t*)&cgen_var_748, 1 * 8);
        uint64_t cgen_var_749;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_749, 1);
        countingStream->write((uint64_t*)&cgen_var_749, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_750 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_750);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorUpdateTemplate = OP_vkDestroyDescriptorUpdateTemplate;
    stream->write(&opcode_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t));
    uint64_t cgen_var_751;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_751, 1);
    stream->write((uint64_t*)&cgen_var_751, 1 * 8);
    uint64_t cgen_var_752;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_752, 1);
    stream->write((uint64_t*)&cgen_var_752, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_753 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_753);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplate readParams");
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplate returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate);
    mImpl->log("finish vkDestroyDescriptorUpdateTemplate");;
}

void VkEncoder::vkUpdateDescriptorSetWithTemplate(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplate encode");
    mImpl->log("start vkUpdateDescriptorSetWithTemplate");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    void* local_pData;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pData = nullptr;
    if (pData)
    {
        local_pData = (void*)pool->dupArray(pData, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_754;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_754, 1);
        countingStream->write((uint64_t*)&cgen_var_754, 1 * 8);
        uint64_t cgen_var_755;
        countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_755, 1);
        countingStream->write((uint64_t*)&cgen_var_755, 1 * 8);
        uint64_t cgen_var_756;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_756, 1);
        countingStream->write((uint64_t*)&cgen_var_756, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_757 = (uint64_t)(uintptr_t)local_pData;
        countingStream->putBe64(cgen_var_757);
        if (local_pData)
        {
            countingStream->write((void*)local_pData, sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSetWithTemplate = OP_vkUpdateDescriptorSetWithTemplate;
    stream->write(&opcode_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t));
    uint64_t cgen_var_758;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_758, 1);
    stream->write((uint64_t*)&cgen_var_758, 1 * 8);
    uint64_t cgen_var_759;
    stream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_759, 1);
    stream->write((uint64_t*)&cgen_var_759, 1 * 8);
    uint64_t cgen_var_760;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_760, 1);
    stream->write((uint64_t*)&cgen_var_760, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_761 = (uint64_t)(uintptr_t)local_pData;
    stream->putBe64(cgen_var_761);
    if (local_pData)
    {
        stream->write((void*)local_pData, sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplate readParams");
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplate returnUnmarshal");
    mImpl->log("finish vkUpdateDescriptorSetWithTemplate");;
}

void VkEncoder::vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferProperties encode");
    mImpl->log("start vkGetPhysicalDeviceExternalBufferProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalBufferInfo* local_pExternalBufferInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalBufferInfo = nullptr;
    if (pExternalBufferInfo)
    {
        local_pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalBufferInfo));
        deepcopy_VkPhysicalDeviceExternalBufferInfo(pool, pExternalBufferInfo, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    if (local_pExternalBufferInfo)
    {
        mImpl->resources()->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(local_pExternalBufferInfo, 1);
        transform_tohost_VkPhysicalDeviceExternalBufferInfo(mImpl->resources(), (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_762;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_762, 1);
        countingStream->write((uint64_t*)&cgen_var_762, 1 * 8);
        marshal_VkPhysicalDeviceExternalBufferInfo(countingStream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
        marshal_VkExternalBufferProperties(countingStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferProperties = OP_vkGetPhysicalDeviceExternalBufferProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t));
    uint64_t cgen_var_763;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_763, 1);
    stream->write((uint64_t*)&cgen_var_763, 1 * 8);
    marshal_VkPhysicalDeviceExternalBufferInfo(stream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    marshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferProperties readParams");
    unmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    if (pExternalBufferProperties)
    {
        mImpl->resources()->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
        transform_fromhost_VkExternalBufferProperties(mImpl->resources(), (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferProperties returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceExternalBufferProperties");;
}

void VkEncoder::vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFenceProperties encode");
    mImpl->log("start vkGetPhysicalDeviceExternalFenceProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalFenceInfo* local_pExternalFenceInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalFenceInfo = nullptr;
    if (pExternalFenceInfo)
    {
        local_pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalFenceInfo));
        deepcopy_VkPhysicalDeviceExternalFenceInfo(pool, pExternalFenceInfo, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    if (local_pExternalFenceInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalFenceInfo(mImpl->resources(), (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_764;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_764, 1);
        countingStream->write((uint64_t*)&cgen_var_764, 1 * 8);
        marshal_VkPhysicalDeviceExternalFenceInfo(countingStream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
        marshal_VkExternalFenceProperties(countingStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFenceProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalFenceProperties = OP_vkGetPhysicalDeviceExternalFenceProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t));
    uint64_t cgen_var_765;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_765, 1);
    stream->write((uint64_t*)&cgen_var_765, 1 * 8);
    marshal_VkPhysicalDeviceExternalFenceInfo(stream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    marshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFenceProperties readParams");
    unmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    if (pExternalFenceProperties)
    {
        transform_fromhost_VkExternalFenceProperties(mImpl->resources(), (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFenceProperties returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceExternalFenceProperties");;
}

void VkEncoder::vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphoreProperties encode");
    mImpl->log("start vkGetPhysicalDeviceExternalSemaphoreProperties");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalSemaphoreInfo* local_pExternalSemaphoreInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalSemaphoreInfo = nullptr;
    if (pExternalSemaphoreInfo)
    {
        local_pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
        deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(pool, pExternalSemaphoreInfo, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    if (local_pExternalSemaphoreInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(mImpl->resources(), (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_766;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_766, 1);
        countingStream->write((uint64_t*)&cgen_var_766, 1 * 8);
        marshal_VkPhysicalDeviceExternalSemaphoreInfo(countingStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
        marshal_VkExternalSemaphoreProperties(countingStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphoreProperties = OP_vkGetPhysicalDeviceExternalSemaphoreProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t));
    uint64_t cgen_var_767;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_767, 1);
    stream->write((uint64_t*)&cgen_var_767, 1 * 8);
    marshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    marshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphoreProperties readParams");
    unmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    if (pExternalSemaphoreProperties)
    {
        transform_fromhost_VkExternalSemaphoreProperties(mImpl->resources(), (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphoreProperties returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceExternalSemaphoreProperties");;
}

void VkEncoder::vkGetDescriptorSetLayoutSupport(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupport encode");
    mImpl->log("start vkGetDescriptorSetLayoutSupport");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(mImpl->resources(), (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_768;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_768, 1);
        countingStream->write((uint64_t*)&cgen_var_768, 1 * 8);
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
        marshal_VkDescriptorSetLayoutSupport(countingStream, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupport = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDescriptorSetLayoutSupport = OP_vkGetDescriptorSetLayoutSupport;
    stream->write(&opcode_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t));
    uint64_t cgen_var_769;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_769, 1);
    stream->write((uint64_t*)&cgen_var_769, 1 * 8);
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    marshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupport readParams");
    unmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    if (pSupport)
    {
        transform_fromhost_VkDescriptorSetLayoutSupport(mImpl->resources(), (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupport returnUnmarshal");
    mImpl->log("finish vkGetDescriptorSetLayoutSupport");;
}

#endif
#ifdef VK_KHR_surface
void VkEncoder::vkDestroySurfaceKHR(
    VkInstance instance,
    VkSurfaceKHR surface,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroySurfaceKHR encode");
    mImpl->log("start vkDestroySurfaceKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkSurfaceKHR local_surface;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_surface = surface;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_770;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_770, 1);
        countingStream->write((uint64_t*)&cgen_var_770, 1 * 8);
        uint64_t cgen_var_771;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_771, 1);
        countingStream->write((uint64_t*)&cgen_var_771, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_772 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_772);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySurfaceKHR = OP_vkDestroySurfaceKHR;
    stream->write(&opcode_vkDestroySurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_773;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_773, 1);
    stream->write((uint64_t*)&cgen_var_773, 1 * 8);
    uint64_t cgen_var_774;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_774, 1);
    stream->write((uint64_t*)&cgen_var_774, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_775 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_775);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroySurfaceKHR readParams");
    AEMU_SCOPED_TRACE("vkDestroySurfaceKHR returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&surface);
    mImpl->log("finish vkDestroySurfaceKHR");;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    VkSurfaceKHR surface,
    VkBool32* pSupported)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceSupportKHR encode");
    mImpl->log("start vkGetPhysicalDeviceSurfaceSupportKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_776;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_776, 1);
        countingStream->write((uint64_t*)&cgen_var_776, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        uint64_t cgen_var_777;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_777, 1);
        countingStream->write((uint64_t*)&cgen_var_777, 1 * 8);
        countingStream->write((VkBool32*)pSupported, sizeof(VkBool32));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceSupportKHR = OP_vkGetPhysicalDeviceSurfaceSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_778;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_778, 1);
    stream->write((uint64_t*)&cgen_var_778, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_779;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_779, 1);
    stream->write((uint64_t*)&cgen_var_779, 1 * 8);
    stream->write((VkBool32*)pSupported, sizeof(VkBool32));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceSupportKHR readParams");
    stream->read((VkBool32*)pSupported, sizeof(VkBool32));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceSupportKHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceSurfaceSupportKHR");;
    return vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilitiesKHR encode");
    mImpl->log("start vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_780;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_780, 1);
        countingStream->write((uint64_t*)&cgen_var_780, 1 * 8);
        uint64_t cgen_var_781;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_781, 1);
        countingStream->write((uint64_t*)&cgen_var_781, 1 * 8);
        marshal_VkSurfaceCapabilitiesKHR(countingStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_782;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_782, 1);
    stream->write((uint64_t*)&cgen_var_782, 1 * 8);
    uint64_t cgen_var_783;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_783, 1);
    stream->write((uint64_t*)&cgen_var_783, 1 * 8);
    marshal_VkSurfaceCapabilitiesKHR(stream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilitiesKHR readParams");
    unmarshal_VkSurfaceCapabilitiesKHR(stream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilitiesKHR(mImpl->resources(), (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilitiesKHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceSurfaceCapabilitiesKHR");;
    return vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceFormatsKHR encode");
    mImpl->log("start vkGetPhysicalDeviceSurfaceFormatsKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_784;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_784, 1);
        countingStream->write((uint64_t*)&cgen_var_784, 1 * 8);
        uint64_t cgen_var_785;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_785, 1);
        countingStream->write((uint64_t*)&cgen_var_785, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_786 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
        countingStream->putBe64(cgen_var_786);
        if (pSurfaceFormatCount)
        {
            countingStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_787 = (uint64_t)(uintptr_t)pSurfaceFormats;
        countingStream->putBe64(cgen_var_787);
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                marshal_VkSurfaceFormatKHR(countingStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormatsKHR = OP_vkGetPhysicalDeviceSurfaceFormatsKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t));
    uint64_t cgen_var_788;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_788, 1);
    stream->write((uint64_t*)&cgen_var_788, 1 * 8);
    uint64_t cgen_var_789;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_789, 1);
    stream->write((uint64_t*)&cgen_var_789, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_790 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
    stream->putBe64(cgen_var_790);
    if (pSurfaceFormatCount)
    {
        stream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_791 = (uint64_t)(uintptr_t)pSurfaceFormats;
    stream->putBe64(cgen_var_791);
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            marshal_VkSurfaceFormatKHR(stream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceFormatsKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pSurfaceFormatCount;
    check_pSurfaceFormatCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSurfaceFormatKHR* check_pSurfaceFormats;
    check_pSurfaceFormats = (VkSurfaceFormatKHR*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            unmarshal_VkSurfaceFormatKHR(stream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            transform_fromhost_VkSurfaceFormatKHR(mImpl->resources(), (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceFormatsKHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceSurfaceFormatsKHR");;
    return vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfacePresentModesKHR encode");
    mImpl->log("start vkGetPhysicalDeviceSurfacePresentModesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_794;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_794, 1);
        countingStream->write((uint64_t*)&cgen_var_794, 1 * 8);
        uint64_t cgen_var_795;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_795, 1);
        countingStream->write((uint64_t*)&cgen_var_795, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_796 = (uint64_t)(uintptr_t)pPresentModeCount;
        countingStream->putBe64(cgen_var_796);
        if (pPresentModeCount)
        {
            countingStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_797 = (uint64_t)(uintptr_t)pPresentModes;
        countingStream->putBe64(cgen_var_797);
        if (pPresentModes)
        {
            countingStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfacePresentModesKHR = OP_vkGetPhysicalDeviceSurfacePresentModesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t));
    uint64_t cgen_var_798;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_798, 1);
    stream->write((uint64_t*)&cgen_var_798, 1 * 8);
    uint64_t cgen_var_799;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_799, 1);
    stream->write((uint64_t*)&cgen_var_799, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_800 = (uint64_t)(uintptr_t)pPresentModeCount;
    stream->putBe64(cgen_var_800);
    if (pPresentModeCount)
    {
        stream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_801 = (uint64_t)(uintptr_t)pPresentModes;
    stream->putBe64(cgen_var_801);
    if (pPresentModes)
    {
        stream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfacePresentModesKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPresentModeCount;
    check_pPresentModeCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentModeCount)
    {
        if (!(check_pPresentModeCount))
        {
            fprintf(stderr, "fatal: pPresentModeCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPresentModeKHR* check_pPresentModes;
    check_pPresentModes = (VkPresentModeKHR*)(uintptr_t)stream->getBe64();
    if (pPresentModes)
    {
        if (!(check_pPresentModes))
        {
            fprintf(stderr, "fatal: pPresentModes inconsistent between guest and host\n");
        }
        stream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfacePresentModesKHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceSurfacePresentModesKHR");;
    return vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_swapchain
VkResult VkEncoder::vkCreateSwapchainKHR(
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateSwapchainKHR encode");
    mImpl->log("start vkCreateSwapchainKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSwapchainCreateInfoKHR*)pool->alloc(sizeof(const VkSwapchainCreateInfoKHR));
        deepcopy_VkSwapchainCreateInfoKHR(pool, pCreateInfo, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSwapchainCreateInfoKHR(mImpl->resources(), (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_804;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_804, 1);
        countingStream->write((uint64_t*)&cgen_var_804, 1 * 8);
        marshal_VkSwapchainCreateInfoKHR(countingStream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_805 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_805);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_806;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchain, &cgen_var_806, 1);
        countingStream->write((uint64_t*)&cgen_var_806, 8);
    }
    uint32_t packetSize_vkCreateSwapchainKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSwapchainKHR = OP_vkCreateSwapchainKHR;
    stream->write(&opcode_vkCreateSwapchainKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSwapchainKHR, sizeof(uint32_t));
    uint64_t cgen_var_807;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_807, 1);
    stream->write((uint64_t*)&cgen_var_807, 1 * 8);
    marshal_VkSwapchainCreateInfoKHR(stream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_808 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_808);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_809;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchain, &cgen_var_809, 1);
    stream->write((uint64_t*)&cgen_var_809, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateSwapchainKHR readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_810;
    stream->read((uint64_t*)&cgen_var_810, 8);
    stream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_810, (VkSwapchainKHR*)pSwapchain, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateSwapchainKHR returnUnmarshal");
    VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateSwapchainKHR");;
    return vkCreateSwapchainKHR_VkResult_return;
}

void VkEncoder::vkDestroySwapchainKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroySwapchainKHR encode");
    mImpl->log("start vkDestroySwapchainKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_swapchain = swapchain;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_811;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_811, 1);
        countingStream->write((uint64_t*)&cgen_var_811, 1 * 8);
        uint64_t cgen_var_812;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_812, 1);
        countingStream->write((uint64_t*)&cgen_var_812, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_813 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_813);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySwapchainKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySwapchainKHR = OP_vkDestroySwapchainKHR;
    stream->write(&opcode_vkDestroySwapchainKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySwapchainKHR, sizeof(uint32_t));
    uint64_t cgen_var_814;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_814, 1);
    stream->write((uint64_t*)&cgen_var_814, 1 * 8);
    uint64_t cgen_var_815;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_815, 1);
    stream->write((uint64_t*)&cgen_var_815, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_816 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_816);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroySwapchainKHR readParams");
    AEMU_SCOPED_TRACE("vkDestroySwapchainKHR returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&swapchain);
    mImpl->log("finish vkDestroySwapchainKHR");;
}

VkResult VkEncoder::vkGetSwapchainImagesKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetSwapchainImagesKHR encode");
    mImpl->log("start vkGetSwapchainImagesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    countingStream->rewind();
    {
        uint64_t cgen_var_817;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_817, 1);
        countingStream->write((uint64_t*)&cgen_var_817, 1 * 8);
        uint64_t cgen_var_818;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_818, 1);
        countingStream->write((uint64_t*)&cgen_var_818, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_819 = (uint64_t)(uintptr_t)pSwapchainImageCount;
        countingStream->putBe64(cgen_var_819);
        if (pSwapchainImageCount)
        {
            countingStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_820 = (uint64_t)(uintptr_t)pSwapchainImages;
        countingStream->putBe64(cgen_var_820);
        if (pSwapchainImages)
        {
            if ((*(pSwapchainImageCount)))
            {
                uint64_t* cgen_var_821;
                countingStream->alloc((void**)&cgen_var_821, (*(pSwapchainImageCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_821, (*(pSwapchainImageCount)));
                countingStream->write((uint64_t*)cgen_var_821, (*(pSwapchainImageCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkGetSwapchainImagesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainImagesKHR = OP_vkGetSwapchainImagesKHR;
    stream->write(&opcode_vkGetSwapchainImagesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainImagesKHR, sizeof(uint32_t));
    uint64_t cgen_var_822;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_822, 1);
    stream->write((uint64_t*)&cgen_var_822, 1 * 8);
    uint64_t cgen_var_823;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_823, 1);
    stream->write((uint64_t*)&cgen_var_823, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_824 = (uint64_t)(uintptr_t)pSwapchainImageCount;
    stream->putBe64(cgen_var_824);
    if (pSwapchainImageCount)
    {
        stream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_825 = (uint64_t)(uintptr_t)pSwapchainImages;
    stream->putBe64(cgen_var_825);
    if (pSwapchainImages)
    {
        if ((*(pSwapchainImageCount)))
        {
            uint64_t* cgen_var_826;
            stream->alloc((void**)&cgen_var_826, (*(pSwapchainImageCount)) * 8);
            stream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_826, (*(pSwapchainImageCount)));
            stream->write((uint64_t*)cgen_var_826, (*(pSwapchainImageCount)) * 8);
        }
    }
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkGetSwapchainImagesKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pSwapchainImageCount;
    check_pSwapchainImageCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSwapchainImageCount)
    {
        if (!(check_pSwapchainImageCount))
        {
            fprintf(stderr, "fatal: pSwapchainImageCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkImage* check_pSwapchainImages;
    check_pSwapchainImages = (VkImage*)(uintptr_t)stream->getBe64();
    if (pSwapchainImages)
    {
        if (!(check_pSwapchainImages))
        {
            fprintf(stderr, "fatal: pSwapchainImages inconsistent between guest and host\n");
        }
        if ((*(pSwapchainImageCount)))
        {
            uint64_t* cgen_var_829;
            stream->alloc((void**)&cgen_var_829, (*(pSwapchainImageCount)) * 8);
            stream->read((uint64_t*)cgen_var_829, (*(pSwapchainImageCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkImage(cgen_var_829, (VkImage*)pSwapchainImages, (*(pSwapchainImageCount)));
        }
    }
    AEMU_SCOPED_TRACE("vkGetSwapchainImagesKHR returnUnmarshal");
    VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetSwapchainImagesKHR");;
    return vkGetSwapchainImagesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImageKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkAcquireNextImageKHR encode");
    mImpl->log("start vkAcquireNextImageKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    uint64_t local_timeout;
    VkSemaphore local_semaphore;
    VkFence local_fence;
    local_device = device;
    local_swapchain = swapchain;
    local_timeout = timeout;
    local_semaphore = semaphore;
    local_fence = fence;
    countingStream->rewind();
    {
        uint64_t cgen_var_830;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_830, 1);
        countingStream->write((uint64_t*)&cgen_var_830, 1 * 8);
        uint64_t cgen_var_831;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_831, 1);
        countingStream->write((uint64_t*)&cgen_var_831, 1 * 8);
        countingStream->write((uint64_t*)&local_timeout, sizeof(uint64_t));
        uint64_t cgen_var_832;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_832, 1);
        countingStream->write((uint64_t*)&cgen_var_832, 1 * 8);
        uint64_t cgen_var_833;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_833, 1);
        countingStream->write((uint64_t*)&cgen_var_833, 1 * 8);
        countingStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkAcquireNextImageKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireNextImageKHR = OP_vkAcquireNextImageKHR;
    stream->write(&opcode_vkAcquireNextImageKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireNextImageKHR, sizeof(uint32_t));
    uint64_t cgen_var_834;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_834, 1);
    stream->write((uint64_t*)&cgen_var_834, 1 * 8);
    uint64_t cgen_var_835;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_835, 1);
    stream->write((uint64_t*)&cgen_var_835, 1 * 8);
    stream->write((uint64_t*)&local_timeout, sizeof(uint64_t));
    uint64_t cgen_var_836;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_836, 1);
    stream->write((uint64_t*)&cgen_var_836, 1 * 8);
    uint64_t cgen_var_837;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_837, 1);
    stream->write((uint64_t*)&cgen_var_837, 1 * 8);
    stream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkAcquireNextImageKHR readParams");
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkAcquireNextImageKHR returnUnmarshal");
    VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkAcquireNextImageKHR");;
    return vkAcquireNextImageKHR_VkResult_return;
}

VkResult VkEncoder::vkQueuePresentKHR(
    VkQueue queue,
    const VkPresentInfoKHR* pPresentInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkQueuePresentKHR encode");
    mImpl->log("start vkQueuePresentKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    VkPresentInfoKHR* local_pPresentInfo;
    local_queue = queue;
    local_pPresentInfo = nullptr;
    if (pPresentInfo)
    {
        local_pPresentInfo = (VkPresentInfoKHR*)pool->alloc(sizeof(const VkPresentInfoKHR));
        deepcopy_VkPresentInfoKHR(pool, pPresentInfo, (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    if (local_pPresentInfo)
    {
        transform_tohost_VkPresentInfoKHR(mImpl->resources(), (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_838;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_838, 1);
        countingStream->write((uint64_t*)&cgen_var_838, 1 * 8);
        marshal_VkPresentInfoKHR(countingStream, (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    uint32_t packetSize_vkQueuePresentKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueuePresentKHR = OP_vkQueuePresentKHR;
    stream->write(&opcode_vkQueuePresentKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkQueuePresentKHR, sizeof(uint32_t));
    uint64_t cgen_var_839;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_839, 1);
    stream->write((uint64_t*)&cgen_var_839, 1 * 8);
    marshal_VkPresentInfoKHR(stream, (VkPresentInfoKHR*)(local_pPresentInfo));
    AEMU_SCOPED_TRACE("vkQueuePresentKHR readParams");
    AEMU_SCOPED_TRACE("vkQueuePresentKHR returnUnmarshal");
    VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
    stream->read(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkQueuePresentKHR");;
    return vkQueuePresentKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPresentCapabilitiesKHR encode");
    mImpl->log("start vkGetDeviceGroupPresentCapabilitiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    local_device = device;
    countingStream->rewind();
    {
        uint64_t cgen_var_840;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_840, 1);
        countingStream->write((uint64_t*)&cgen_var_840, 1 * 8);
        marshal_VkDeviceGroupPresentCapabilitiesKHR(countingStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    }
    uint32_t packetSize_vkGetDeviceGroupPresentCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPresentCapabilitiesKHR = OP_vkGetDeviceGroupPresentCapabilitiesKHR;
    stream->write(&opcode_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_841;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_841, 1);
    stream->write((uint64_t*)&cgen_var_841, 1 * 8);
    marshal_VkDeviceGroupPresentCapabilitiesKHR(stream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPresentCapabilitiesKHR readParams");
    unmarshal_VkDeviceGroupPresentCapabilitiesKHR(stream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    if (pDeviceGroupPresentCapabilities)
    {
        transform_fromhost_VkDeviceGroupPresentCapabilitiesKHR(mImpl->resources(), (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPresentCapabilitiesKHR returnUnmarshal");
    VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetDeviceGroupPresentCapabilitiesKHR");;
    return vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDeviceGroupSurfacePresentModesKHR encode");
    mImpl->log("start vkGetDeviceGroupSurfacePresentModesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSurfaceKHR local_surface;
    local_device = device;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_842;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_842, 1);
        countingStream->write((uint64_t*)&cgen_var_842, 1 * 8);
        uint64_t cgen_var_843;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_843, 1);
        countingStream->write((uint64_t*)&cgen_var_843, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_844 = (uint64_t)(uintptr_t)pModes;
        countingStream->putBe64(cgen_var_844);
        if (pModes)
        {
            countingStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
        }
    }
    uint32_t packetSize_vkGetDeviceGroupSurfacePresentModesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupSurfacePresentModesKHR = OP_vkGetDeviceGroupSurfacePresentModesKHR;
    stream->write(&opcode_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t));
    uint64_t cgen_var_845;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_845, 1);
    stream->write((uint64_t*)&cgen_var_845, 1 * 8);
    uint64_t cgen_var_846;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_846, 1);
    stream->write((uint64_t*)&cgen_var_846, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_847 = (uint64_t)(uintptr_t)pModes;
    stream->putBe64(cgen_var_847);
    if (pModes)
    {
        stream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupSurfacePresentModesKHR readParams");
    // WARNING PTR CHECK
    VkDeviceGroupPresentModeFlagsKHR* check_pModes;
    check_pModes = (VkDeviceGroupPresentModeFlagsKHR*)(uintptr_t)stream->getBe64();
    if (pModes)
    {
        if (!(check_pModes))
        {
            fprintf(stderr, "fatal: pModes inconsistent between guest and host\n");
        }
        stream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupSurfacePresentModesKHR returnUnmarshal");
    VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetDeviceGroupSurfacePresentModesKHR");;
    return vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pRectCount,
    VkRect2D* pRects)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDevicePresentRectanglesKHR encode");
    mImpl->log("start vkGetPhysicalDevicePresentRectanglesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_849;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_849, 1);
        countingStream->write((uint64_t*)&cgen_var_849, 1 * 8);
        uint64_t cgen_var_850;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_850, 1);
        countingStream->write((uint64_t*)&cgen_var_850, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_851 = (uint64_t)(uintptr_t)pRectCount;
        countingStream->putBe64(cgen_var_851);
        if (pRectCount)
        {
            countingStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_852 = (uint64_t)(uintptr_t)pRects;
        countingStream->putBe64(cgen_var_852);
        if (pRects)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
            {
                marshal_VkRect2D(countingStream, (VkRect2D*)(pRects + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDevicePresentRectanglesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDevicePresentRectanglesKHR = OP_vkGetPhysicalDevicePresentRectanglesKHR;
    stream->write(&opcode_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t));
    uint64_t cgen_var_853;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_853, 1);
    stream->write((uint64_t*)&cgen_var_853, 1 * 8);
    uint64_t cgen_var_854;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_854, 1);
    stream->write((uint64_t*)&cgen_var_854, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_855 = (uint64_t)(uintptr_t)pRectCount;
    stream->putBe64(cgen_var_855);
    if (pRectCount)
    {
        stream->write((uint32_t*)pRectCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_856 = (uint64_t)(uintptr_t)pRects;
    stream->putBe64(cgen_var_856);
    if (pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            marshal_VkRect2D(stream, (VkRect2D*)(pRects + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDevicePresentRectanglesKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pRectCount;
    check_pRectCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pRectCount)
    {
        if (!(check_pRectCount))
        {
            fprintf(stderr, "fatal: pRectCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pRectCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkRect2D* check_pRects;
    check_pRects = (VkRect2D*)(uintptr_t)stream->getBe64();
    if (pRects)
    {
        if (!(check_pRects))
        {
            fprintf(stderr, "fatal: pRects inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            unmarshal_VkRect2D(stream, (VkRect2D*)(pRects + i));
        }
    }
    if (pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            transform_fromhost_VkRect2D(mImpl->resources(), (VkRect2D*)(pRects + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDevicePresentRectanglesKHR returnUnmarshal");
    VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDevicePresentRectanglesKHR");;
    return vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImage2KHR(
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkAcquireNextImage2KHR encode");
    mImpl->log("start vkAcquireNextImage2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkAcquireNextImageInfoKHR* local_pAcquireInfo;
    local_device = device;
    local_pAcquireInfo = nullptr;
    if (pAcquireInfo)
    {
        local_pAcquireInfo = (VkAcquireNextImageInfoKHR*)pool->alloc(sizeof(const VkAcquireNextImageInfoKHR));
        deepcopy_VkAcquireNextImageInfoKHR(pool, pAcquireInfo, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    }
    if (local_pAcquireInfo)
    {
        transform_tohost_VkAcquireNextImageInfoKHR(mImpl->resources(), (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_859;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_859, 1);
        countingStream->write((uint64_t*)&cgen_var_859, 1 * 8);
        marshal_VkAcquireNextImageInfoKHR(countingStream, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
        countingStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkAcquireNextImage2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireNextImage2KHR = OP_vkAcquireNextImage2KHR;
    stream->write(&opcode_vkAcquireNextImage2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireNextImage2KHR, sizeof(uint32_t));
    uint64_t cgen_var_860;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_860, 1);
    stream->write((uint64_t*)&cgen_var_860, 1 * 8);
    marshal_VkAcquireNextImageInfoKHR(stream, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    stream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkAcquireNextImage2KHR readParams");
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkAcquireNextImage2KHR returnUnmarshal");
    VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkAcquireNextImage2KHR");;
    return vkAcquireNextImage2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display
VkResult VkEncoder::vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPropertiesKHR* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPropertiesKHR encode");
    mImpl->log("start vkGetPhysicalDeviceDisplayPropertiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_861;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_861, 1);
        countingStream->write((uint64_t*)&cgen_var_861, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_862 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_862);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_863 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_863);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPropertiesKHR(countingStream, (VkDisplayPropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPropertiesKHR = OP_vkGetPhysicalDeviceDisplayPropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_864;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_864, 1);
    stream->write((uint64_t*)&cgen_var_864, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_865 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_865);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_866 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_866);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPropertiesKHR(stream, (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPropertiesKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayPropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPropertiesKHR(stream, (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPropertiesKHR(mImpl->resources(), (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPropertiesKHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceDisplayPropertiesKHR");;
    return vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPlanePropertiesKHR encode");
    mImpl->log("start vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_869;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_869, 1);
        countingStream->write((uint64_t*)&cgen_var_869, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_870 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_870);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_871 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_871);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPlanePropertiesKHR(countingStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_872;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_872, 1);
    stream->write((uint64_t*)&cgen_var_872, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_873 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_873);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_874 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_874);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPlanePropertiesKHR(stream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPlanePropertiesKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPlanePropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayPlanePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPlanePropertiesKHR(stream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPlanePropertiesKHR(mImpl->resources(), (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPlanePropertiesKHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceDisplayPlanePropertiesKHR");;
    return vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t planeIndex,
    uint32_t* pDisplayCount,
    VkDisplayKHR* pDisplays)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneSupportedDisplaysKHR encode");
    mImpl->log("start vkGetDisplayPlaneSupportedDisplaysKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_planeIndex;
    local_physicalDevice = physicalDevice;
    local_planeIndex = planeIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_877;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_877, 1);
        countingStream->write((uint64_t*)&cgen_var_877, 1 * 8);
        countingStream->write((uint32_t*)&local_planeIndex, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_878 = (uint64_t)(uintptr_t)pDisplayCount;
        countingStream->putBe64(cgen_var_878);
        if (pDisplayCount)
        {
            countingStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_879 = (uint64_t)(uintptr_t)pDisplays;
        countingStream->putBe64(cgen_var_879);
        if (pDisplays)
        {
            if ((*(pDisplayCount)))
            {
                uint64_t* cgen_var_880;
                countingStream->alloc((void**)&cgen_var_880, (*(pDisplayCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_880, (*(pDisplayCount)));
                countingStream->write((uint64_t*)cgen_var_880, (*(pDisplayCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkGetDisplayPlaneSupportedDisplaysKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneSupportedDisplaysKHR = OP_vkGetDisplayPlaneSupportedDisplaysKHR;
    stream->write(&opcode_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t));
    uint64_t cgen_var_881;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_881, 1);
    stream->write((uint64_t*)&cgen_var_881, 1 * 8);
    stream->write((uint32_t*)&local_planeIndex, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_882 = (uint64_t)(uintptr_t)pDisplayCount;
    stream->putBe64(cgen_var_882);
    if (pDisplayCount)
    {
        stream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_883 = (uint64_t)(uintptr_t)pDisplays;
    stream->putBe64(cgen_var_883);
    if (pDisplays)
    {
        if ((*(pDisplayCount)))
        {
            uint64_t* cgen_var_884;
            stream->alloc((void**)&cgen_var_884, (*(pDisplayCount)) * 8);
            stream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_884, (*(pDisplayCount)));
            stream->write((uint64_t*)cgen_var_884, (*(pDisplayCount)) * 8);
        }
    }
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneSupportedDisplaysKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pDisplayCount;
    check_pDisplayCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pDisplayCount)
    {
        if (!(check_pDisplayCount))
        {
            fprintf(stderr, "fatal: pDisplayCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayKHR* check_pDisplays;
    check_pDisplays = (VkDisplayKHR*)(uintptr_t)stream->getBe64();
    if (pDisplays)
    {
        if (!(check_pDisplays))
        {
            fprintf(stderr, "fatal: pDisplays inconsistent between guest and host\n");
        }
        if ((*(pDisplayCount)))
        {
            uint64_t* cgen_var_887;
            stream->alloc((void**)&cgen_var_887, (*(pDisplayCount)) * 8);
            stream->read((uint64_t*)cgen_var_887, (*(pDisplayCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkDisplayKHR(cgen_var_887, (VkDisplayKHR*)pDisplays, (*(pDisplayCount)));
        }
    }
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneSupportedDisplaysKHR returnUnmarshal");
    VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetDisplayPlaneSupportedDisplaysKHR");;
    return vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDisplayModePropertiesKHR encode");
    mImpl->log("start vkGetDisplayModePropertiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    countingStream->rewind();
    {
        uint64_t cgen_var_888;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_888, 1);
        countingStream->write((uint64_t*)&cgen_var_888, 1 * 8);
        uint64_t cgen_var_889;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_889, 1);
        countingStream->write((uint64_t*)&cgen_var_889, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_890 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_890);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_891 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_891);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayModePropertiesKHR(countingStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayModePropertiesKHR = OP_vkGetDisplayModePropertiesKHR;
    stream->write(&opcode_vkGetDisplayModePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayModePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_892;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_892, 1);
    stream->write((uint64_t*)&cgen_var_892, 1 * 8);
    uint64_t cgen_var_893;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_893, 1);
    stream->write((uint64_t*)&cgen_var_893, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_894 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_894);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_895 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_895);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayModePropertiesKHR(stream, (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetDisplayModePropertiesKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayModePropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayModePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayModePropertiesKHR(stream, (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayModePropertiesKHR(mImpl->resources(), (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetDisplayModePropertiesKHR returnUnmarshal");
    VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetDisplayModePropertiesKHR");;
    return vkGetDisplayModePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayModeKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDisplayModeKHR* pMode)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDisplayModeKHR encode");
    mImpl->log("start vkCreateDisplayModeKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    VkDisplayModeCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_physicalDevice = physicalDevice;
    local_display = display;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDisplayModeCreateInfoKHR*)pool->alloc(sizeof(const VkDisplayModeCreateInfoKHR));
        deepcopy_VkDisplayModeCreateInfoKHR(pool, pCreateInfo, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDisplayModeCreateInfoKHR(mImpl->resources(), (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_898;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_898, 1);
        countingStream->write((uint64_t*)&cgen_var_898, 1 * 8);
        uint64_t cgen_var_899;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_899, 1);
        countingStream->write((uint64_t*)&cgen_var_899, 1 * 8);
        marshal_VkDisplayModeCreateInfoKHR(countingStream, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_900 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_900);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_901;
        countingStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(pMode, &cgen_var_901, 1);
        countingStream->write((uint64_t*)&cgen_var_901, 8);
    }
    uint32_t packetSize_vkCreateDisplayModeKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDisplayModeKHR = OP_vkCreateDisplayModeKHR;
    stream->write(&opcode_vkCreateDisplayModeKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDisplayModeKHR, sizeof(uint32_t));
    uint64_t cgen_var_902;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_902, 1);
    stream->write((uint64_t*)&cgen_var_902, 1 * 8);
    uint64_t cgen_var_903;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_903, 1);
    stream->write((uint64_t*)&cgen_var_903, 1 * 8);
    marshal_VkDisplayModeCreateInfoKHR(stream, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_904 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_904);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_905;
    stream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(pMode, &cgen_var_905, 1);
    stream->write((uint64_t*)&cgen_var_905, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDisplayModeKHR readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_906;
    stream->read((uint64_t*)&cgen_var_906, 8);
    stream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_906, (VkDisplayModeKHR*)pMode, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateDisplayModeKHR returnUnmarshal");
    VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateDisplayModeKHR");;
    return vkCreateDisplayModeKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayModeKHR mode,
    uint32_t planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneCapabilitiesKHR encode");
    mImpl->log("start vkGetDisplayPlaneCapabilitiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayModeKHR local_mode;
    uint32_t local_planeIndex;
    local_physicalDevice = physicalDevice;
    local_mode = mode;
    local_planeIndex = planeIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_907;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_907, 1);
        countingStream->write((uint64_t*)&cgen_var_907, 1 * 8);
        uint64_t cgen_var_908;
        countingStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&local_mode, &cgen_var_908, 1);
        countingStream->write((uint64_t*)&cgen_var_908, 1 * 8);
        countingStream->write((uint32_t*)&local_planeIndex, sizeof(uint32_t));
        marshal_VkDisplayPlaneCapabilitiesKHR(countingStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneCapabilitiesKHR = OP_vkGetDisplayPlaneCapabilitiesKHR;
    stream->write(&opcode_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_909;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_909, 1);
    stream->write((uint64_t*)&cgen_var_909, 1 * 8);
    uint64_t cgen_var_910;
    stream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&local_mode, &cgen_var_910, 1);
    stream->write((uint64_t*)&cgen_var_910, 1 * 8);
    stream->write((uint32_t*)&local_planeIndex, sizeof(uint32_t));
    marshal_VkDisplayPlaneCapabilitiesKHR(stream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneCapabilitiesKHR readParams");
    unmarshal_VkDisplayPlaneCapabilitiesKHR(stream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    if (pCapabilities)
    {
        transform_fromhost_VkDisplayPlaneCapabilitiesKHR(mImpl->resources(), (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    }
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneCapabilitiesKHR returnUnmarshal");
    VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetDisplayPlaneCapabilitiesKHR");;
    return vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayPlaneSurfaceKHR(
    VkInstance instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDisplayPlaneSurfaceKHR encode");
    mImpl->log("start vkCreateDisplayPlaneSurfaceKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDisplaySurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDisplaySurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkDisplaySurfaceCreateInfoKHR));
        deepcopy_VkDisplaySurfaceCreateInfoKHR(pool, pCreateInfo, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDisplaySurfaceCreateInfoKHR(mImpl->resources(), (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_911;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_911, 1);
        countingStream->write((uint64_t*)&cgen_var_911, 1 * 8);
        marshal_VkDisplaySurfaceCreateInfoKHR(countingStream, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_912 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_912);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_913;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_913, 1);
        countingStream->write((uint64_t*)&cgen_var_913, 8);
    }
    uint32_t packetSize_vkCreateDisplayPlaneSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDisplayPlaneSurfaceKHR = OP_vkCreateDisplayPlaneSurfaceKHR;
    stream->write(&opcode_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_914;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_914, 1);
    stream->write((uint64_t*)&cgen_var_914, 1 * 8);
    marshal_VkDisplaySurfaceCreateInfoKHR(stream, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_915 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_915);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_916;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_916, 1);
    stream->write((uint64_t*)&cgen_var_916, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDisplayPlaneSurfaceKHR readParams");
    uint64_t cgen_var_917;
    stream->read((uint64_t*)&cgen_var_917, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_917, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateDisplayPlaneSurfaceKHR returnUnmarshal");
    VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateDisplayPlaneSurfaceKHR");;
    return vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display_swapchain
VkResult VkEncoder::vkCreateSharedSwapchainsKHR(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateSharedSwapchainsKHR encode");
    mImpl->log("start vkCreateSharedSwapchainsKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_swapchainCount;
    VkSwapchainCreateInfoKHR* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_swapchainCount = swapchainCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkSwapchainCreateInfoKHR*)pool->alloc(((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            deepcopy_VkSwapchainCreateInfoKHR(pool, pCreateInfos + i, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            transform_tohost_VkSwapchainCreateInfoKHR(mImpl->resources(), (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_918;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_918, 1);
        countingStream->write((uint64_t*)&cgen_var_918, 1 * 8);
        countingStream->write((uint32_t*)&local_swapchainCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            marshal_VkSwapchainCreateInfoKHR(countingStream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_919 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_919);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        if (((swapchainCount)))
        {
            uint64_t* cgen_var_920;
            countingStream->alloc((void**)&cgen_var_920, ((swapchainCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_920, ((swapchainCount)));
            countingStream->write((uint64_t*)cgen_var_920, ((swapchainCount)) * 8);
        }
    }
    uint32_t packetSize_vkCreateSharedSwapchainsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSharedSwapchainsKHR = OP_vkCreateSharedSwapchainsKHR;
    stream->write(&opcode_vkCreateSharedSwapchainsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSharedSwapchainsKHR, sizeof(uint32_t));
    uint64_t cgen_var_921;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_921, 1);
    stream->write((uint64_t*)&cgen_var_921, 1 * 8);
    stream->write((uint32_t*)&local_swapchainCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        marshal_VkSwapchainCreateInfoKHR(stream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_922 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_922);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (((swapchainCount)))
    {
        uint64_t* cgen_var_923;
        stream->alloc((void**)&cgen_var_923, ((swapchainCount)) * 8);
        stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_923, ((swapchainCount)));
        stream->write((uint64_t*)cgen_var_923, ((swapchainCount)) * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateSharedSwapchainsKHR readParams");
    if (((swapchainCount)))
    {
        uint64_t* cgen_var_924;
        stream->alloc((void**)&cgen_var_924, ((swapchainCount)) * 8);
        stream->read((uint64_t*)cgen_var_924, ((swapchainCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_924, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
    }
    AEMU_SCOPED_TRACE("vkCreateSharedSwapchainsKHR returnUnmarshal");
    VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateSharedSwapchainsKHR");;
    return vkCreateSharedSwapchainsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_xlib_surface
VkResult VkEncoder::vkCreateXlibSurfaceKHR(
    VkInstance instance,
    const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateXlibSurfaceKHR encode");
    mImpl->log("start vkCreateXlibSurfaceKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkXlibSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkXlibSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkXlibSurfaceCreateInfoKHR));
        deepcopy_VkXlibSurfaceCreateInfoKHR(pool, pCreateInfo, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkXlibSurfaceCreateInfoKHR(mImpl->resources(), (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_925;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_925, 1);
        countingStream->write((uint64_t*)&cgen_var_925, 1 * 8);
        marshal_VkXlibSurfaceCreateInfoKHR(countingStream, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_926 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_926);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_927;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_927, 1);
        countingStream->write((uint64_t*)&cgen_var_927, 8);
    }
    uint32_t packetSize_vkCreateXlibSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateXlibSurfaceKHR = OP_vkCreateXlibSurfaceKHR;
    stream->write(&opcode_vkCreateXlibSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateXlibSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_928;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_928, 1);
    stream->write((uint64_t*)&cgen_var_928, 1 * 8);
    marshal_VkXlibSurfaceCreateInfoKHR(stream, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_929 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_929);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_930;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_930, 1);
    stream->write((uint64_t*)&cgen_var_930, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateXlibSurfaceKHR readParams");
    uint64_t cgen_var_931;
    stream->read((uint64_t*)&cgen_var_931, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_931, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateXlibSurfaceKHR returnUnmarshal");
    VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateXlibSurfaceKHR");;
    return vkCreateXlibSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    Display* dpy,
    VisualID visualID)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceXlibPresentationSupportKHR encode");
    mImpl->log("start vkGetPhysicalDeviceXlibPresentationSupportKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    VisualID local_visualID;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_visualID = visualID;
    countingStream->rewind();
    {
        uint64_t cgen_var_932;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_932, 1);
        countingStream->write((uint64_t*)&cgen_var_932, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((Display*)dpy, sizeof(Display));
        countingStream->write((VisualID*)&local_visualID, sizeof(VisualID));
    }
    uint32_t packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR = OP_vkGetPhysicalDeviceXlibPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_933;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_933, 1);
    stream->write((uint64_t*)&cgen_var_933, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((Display*)dpy, sizeof(Display));
    stream->write((VisualID*)&local_visualID, sizeof(VisualID));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceXlibPresentationSupportKHR readParams");
    stream->read((Display*)dpy, sizeof(Display));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceXlibPresentationSupportKHR returnUnmarshal");
    VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceXlibPresentationSupportKHR");;
    return vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_xcb_surface
VkResult VkEncoder::vkCreateXcbSurfaceKHR(
    VkInstance instance,
    const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateXcbSurfaceKHR encode");
    mImpl->log("start vkCreateXcbSurfaceKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkXcbSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkXcbSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkXcbSurfaceCreateInfoKHR));
        deepcopy_VkXcbSurfaceCreateInfoKHR(pool, pCreateInfo, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkXcbSurfaceCreateInfoKHR(mImpl->resources(), (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_934;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_934, 1);
        countingStream->write((uint64_t*)&cgen_var_934, 1 * 8);
        marshal_VkXcbSurfaceCreateInfoKHR(countingStream, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_935 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_935);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_936;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_936, 1);
        countingStream->write((uint64_t*)&cgen_var_936, 8);
    }
    uint32_t packetSize_vkCreateXcbSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateXcbSurfaceKHR = OP_vkCreateXcbSurfaceKHR;
    stream->write(&opcode_vkCreateXcbSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateXcbSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_937;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_937, 1);
    stream->write((uint64_t*)&cgen_var_937, 1 * 8);
    marshal_VkXcbSurfaceCreateInfoKHR(stream, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_938 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_938);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_939;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_939, 1);
    stream->write((uint64_t*)&cgen_var_939, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateXcbSurfaceKHR readParams");
    uint64_t cgen_var_940;
    stream->read((uint64_t*)&cgen_var_940, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_940, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateXcbSurfaceKHR returnUnmarshal");
    VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateXcbSurfaceKHR");;
    return vkCreateXcbSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    xcb_connection_t* connection,
    xcb_visualid_t visual_id)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceXcbPresentationSupportKHR encode");
    mImpl->log("start vkGetPhysicalDeviceXcbPresentationSupportKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    xcb_visualid_t local_visual_id;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_visual_id = visual_id;
    countingStream->rewind();
    {
        uint64_t cgen_var_941;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_941, 1);
        countingStream->write((uint64_t*)&cgen_var_941, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
        countingStream->write((xcb_visualid_t*)&local_visual_id, sizeof(xcb_visualid_t));
    }
    uint32_t packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR = OP_vkGetPhysicalDeviceXcbPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_942;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_942, 1);
    stream->write((uint64_t*)&cgen_var_942, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    stream->write((xcb_visualid_t*)&local_visual_id, sizeof(xcb_visualid_t));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceXcbPresentationSupportKHR readParams");
    stream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceXcbPresentationSupportKHR returnUnmarshal");
    VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceXcbPresentationSupportKHR");;
    return vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_wayland_surface
VkResult VkEncoder::vkCreateWaylandSurfaceKHR(
    VkInstance instance,
    const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateWaylandSurfaceKHR encode");
    mImpl->log("start vkCreateWaylandSurfaceKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkWaylandSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkWaylandSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkWaylandSurfaceCreateInfoKHR));
        deepcopy_VkWaylandSurfaceCreateInfoKHR(pool, pCreateInfo, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkWaylandSurfaceCreateInfoKHR(mImpl->resources(), (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_943;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_943, 1);
        countingStream->write((uint64_t*)&cgen_var_943, 1 * 8);
        marshal_VkWaylandSurfaceCreateInfoKHR(countingStream, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_944 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_944);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_945;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_945, 1);
        countingStream->write((uint64_t*)&cgen_var_945, 8);
    }
    uint32_t packetSize_vkCreateWaylandSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateWaylandSurfaceKHR = OP_vkCreateWaylandSurfaceKHR;
    stream->write(&opcode_vkCreateWaylandSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateWaylandSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_946;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_946, 1);
    stream->write((uint64_t*)&cgen_var_946, 1 * 8);
    marshal_VkWaylandSurfaceCreateInfoKHR(stream, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_947 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_947);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_948;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_948, 1);
    stream->write((uint64_t*)&cgen_var_948, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateWaylandSurfaceKHR readParams");
    uint64_t cgen_var_949;
    stream->read((uint64_t*)&cgen_var_949, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_949, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateWaylandSurfaceKHR returnUnmarshal");
    VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateWaylandSurfaceKHR");;
    return vkCreateWaylandSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    wl_display* display)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceWaylandPresentationSupportKHR encode");
    mImpl->log("start vkGetPhysicalDeviceWaylandPresentationSupportKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_950;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_950, 1);
        countingStream->write((uint64_t*)&cgen_var_950, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((wl_display*)display, sizeof(wl_display));
    }
    uint32_t packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR = OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_951;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_951, 1);
    stream->write((uint64_t*)&cgen_var_951, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((wl_display*)display, sizeof(wl_display));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceWaylandPresentationSupportKHR readParams");
    stream->read((wl_display*)display, sizeof(wl_display));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceWaylandPresentationSupportKHR returnUnmarshal");
    VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceWaylandPresentationSupportKHR");;
    return vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_mir_surface
VkResult VkEncoder::vkCreateMirSurfaceKHR(
    VkInstance instance,
    const VkMirSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateMirSurfaceKHR encode");
    mImpl->log("start vkCreateMirSurfaceKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkMirSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkMirSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkMirSurfaceCreateInfoKHR));
        deepcopy_VkMirSurfaceCreateInfoKHR(pool, pCreateInfo, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkMirSurfaceCreateInfoKHR(mImpl->resources(), (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_952;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_952, 1);
        countingStream->write((uint64_t*)&cgen_var_952, 1 * 8);
        marshal_VkMirSurfaceCreateInfoKHR(countingStream, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_953 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_953);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_954;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_954, 1);
        countingStream->write((uint64_t*)&cgen_var_954, 8);
    }
    uint32_t packetSize_vkCreateMirSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateMirSurfaceKHR = OP_vkCreateMirSurfaceKHR;
    stream->write(&opcode_vkCreateMirSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateMirSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_955;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_955, 1);
    stream->write((uint64_t*)&cgen_var_955, 1 * 8);
    marshal_VkMirSurfaceCreateInfoKHR(stream, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_956 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_956);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_957;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_957, 1);
    stream->write((uint64_t*)&cgen_var_957, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateMirSurfaceKHR readParams");
    uint64_t cgen_var_958;
    stream->read((uint64_t*)&cgen_var_958, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_958, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateMirSurfaceKHR returnUnmarshal");
    VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateMirSurfaceKHR");;
    return vkCreateMirSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    MirConnection* connection)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMirPresentationSupportKHR encode");
    mImpl->log("start vkGetPhysicalDeviceMirPresentationSupportKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_959;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_959, 1);
        countingStream->write((uint64_t*)&cgen_var_959, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((MirConnection*)connection, sizeof(MirConnection));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMirPresentationSupportKHR = OP_vkGetPhysicalDeviceMirPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceMirPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_960;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_960, 1);
    stream->write((uint64_t*)&cgen_var_960, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((MirConnection*)connection, sizeof(MirConnection));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMirPresentationSupportKHR readParams");
    stream->read((MirConnection*)connection, sizeof(MirConnection));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMirPresentationSupportKHR returnUnmarshal");
    VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceMirPresentationSupportKHR");;
    return vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_android_surface
VkResult VkEncoder::vkCreateAndroidSurfaceKHR(
    VkInstance instance,
    const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateAndroidSurfaceKHR encode");
    mImpl->log("start vkCreateAndroidSurfaceKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkAndroidSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkAndroidSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkAndroidSurfaceCreateInfoKHR));
        deepcopy_VkAndroidSurfaceCreateInfoKHR(pool, pCreateInfo, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkAndroidSurfaceCreateInfoKHR(mImpl->resources(), (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_961;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_961, 1);
        countingStream->write((uint64_t*)&cgen_var_961, 1 * 8);
        marshal_VkAndroidSurfaceCreateInfoKHR(countingStream, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_962 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_962);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_963;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_963, 1);
        countingStream->write((uint64_t*)&cgen_var_963, 8);
    }
    uint32_t packetSize_vkCreateAndroidSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateAndroidSurfaceKHR = OP_vkCreateAndroidSurfaceKHR;
    stream->write(&opcode_vkCreateAndroidSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateAndroidSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_964;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_964, 1);
    stream->write((uint64_t*)&cgen_var_964, 1 * 8);
    marshal_VkAndroidSurfaceCreateInfoKHR(stream, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_965 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_965);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_966;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_966, 1);
    stream->write((uint64_t*)&cgen_var_966, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateAndroidSurfaceKHR readParams");
    uint64_t cgen_var_967;
    stream->read((uint64_t*)&cgen_var_967, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_967, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateAndroidSurfaceKHR returnUnmarshal");
    VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateAndroidSurfaceKHR");;
    return vkCreateAndroidSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_surface
VkResult VkEncoder::vkCreateWin32SurfaceKHR(
    VkInstance instance,
    const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateWin32SurfaceKHR encode");
    mImpl->log("start vkCreateWin32SurfaceKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkWin32SurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkWin32SurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkWin32SurfaceCreateInfoKHR));
        deepcopy_VkWin32SurfaceCreateInfoKHR(pool, pCreateInfo, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkWin32SurfaceCreateInfoKHR(mImpl->resources(), (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_968;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_968, 1);
        countingStream->write((uint64_t*)&cgen_var_968, 1 * 8);
        marshal_VkWin32SurfaceCreateInfoKHR(countingStream, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_969 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_969);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_970;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_970, 1);
        countingStream->write((uint64_t*)&cgen_var_970, 8);
    }
    uint32_t packetSize_vkCreateWin32SurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateWin32SurfaceKHR = OP_vkCreateWin32SurfaceKHR;
    stream->write(&opcode_vkCreateWin32SurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateWin32SurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_971;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_971, 1);
    stream->write((uint64_t*)&cgen_var_971, 1 * 8);
    marshal_VkWin32SurfaceCreateInfoKHR(stream, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_972 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_972);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_973;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_973, 1);
    stream->write((uint64_t*)&cgen_var_973, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateWin32SurfaceKHR readParams");
    uint64_t cgen_var_974;
    stream->read((uint64_t*)&cgen_var_974, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_974, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateWin32SurfaceKHR returnUnmarshal");
    VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateWin32SurfaceKHR");;
    return vkCreateWin32SurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceWin32PresentationSupportKHR encode");
    mImpl->log("start vkGetPhysicalDeviceWin32PresentationSupportKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_975;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_975, 1);
        countingStream->write((uint64_t*)&cgen_var_975, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR = OP_vkGetPhysicalDeviceWin32PresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_976;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_976, 1);
    stream->write((uint64_t*)&cgen_var_976, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceWin32PresentationSupportKHR readParams");
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceWin32PresentationSupportKHR returnUnmarshal");
    VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceWin32PresentationSupportKHR");;
    return vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkEncoder::vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceFeatures2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_977;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_977, 1);
        countingStream->write((uint64_t*)&cgen_var_977, 1 * 8);
        marshal_VkPhysicalDeviceFeatures2(countingStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures2KHR = OP_vkGetPhysicalDeviceFeatures2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t));
    uint64_t cgen_var_978;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_978, 1);
    stream->write((uint64_t*)&cgen_var_978, 1 * 8);
    marshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2KHR readParams");
    unmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures2(mImpl->resources(), (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2KHR returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceFeatures2KHR");;
}

void VkEncoder::vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_979;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_979, 1);
        countingStream->write((uint64_t*)&cgen_var_979, 1 * 8);
        marshal_VkPhysicalDeviceProperties2(countingStream, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceProperties2KHR = OP_vkGetPhysicalDeviceProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_980;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_980, 1);
    stream->write((uint64_t*)&cgen_var_980, 1 * 8);
    marshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2KHR readParams");
    unmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties2(mImpl->resources(), (VkPhysicalDeviceProperties2*)(pProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2KHR returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceProperties2KHR");;
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceFormatProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    countingStream->rewind();
    {
        uint64_t cgen_var_981;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_981, 1);
        countingStream->write((uint64_t*)&cgen_var_981, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        marshal_VkFormatProperties2(countingStream, (VkFormatProperties2*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2KHR = OP_vkGetPhysicalDeviceFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_982;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_982, 1);
    stream->write((uint64_t*)&cgen_var_982, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    marshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2KHR readParams");
    unmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties2(mImpl->resources(), (VkFormatProperties2*)(pFormatProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2KHR returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceFormatProperties2KHR");;
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceImageFormatProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceImageFormatInfo2* local_pImageFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pImageFormatInfo = nullptr;
    if (pImageFormatInfo)
    {
        local_pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceImageFormatInfo2));
        deepcopy_VkPhysicalDeviceImageFormatInfo2(pool, pImageFormatInfo, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    if (local_pImageFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceImageFormatInfo2(mImpl->resources(), (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_983;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_983, 1);
        countingStream->write((uint64_t*)&cgen_var_983, 1 * 8);
        marshal_VkPhysicalDeviceImageFormatInfo2(countingStream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
        marshal_VkImageFormatProperties2(countingStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2KHR = OP_vkGetPhysicalDeviceImageFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_984;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_984, 1);
    stream->write((uint64_t*)&cgen_var_984, 1 * 8);
    marshal_VkPhysicalDeviceImageFormatInfo2(stream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    marshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2KHR readParams");
    unmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties2(mImpl->resources(), (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2KHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceImageFormatProperties2KHR");;
    return vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceQueueFamilyProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_985;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_985, 1);
        countingStream->write((uint64_t*)&cgen_var_985, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_986 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
        countingStream->putBe64(cgen_var_986);
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_987 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
        countingStream->putBe64(cgen_var_987);
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties2(countingStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR = OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_988;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_988, 1);
    stream->write((uint64_t*)&cgen_var_988, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_989 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    stream->putBe64(cgen_var_989);
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_990 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    stream->putBe64(cgen_var_990);
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2KHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties2(mImpl->resources(), (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2KHR returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceQueueFamilyProperties2KHR");;
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceMemoryProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_993;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_993, 1);
        countingStream->write((uint64_t*)&cgen_var_993, 1 * 8);
        marshal_VkPhysicalDeviceMemoryProperties2(countingStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2KHR = OP_vkGetPhysicalDeviceMemoryProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_994;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_994, 1);
    stream->write((uint64_t*)&cgen_var_994, 1 * 8);
    marshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2KHR readParams");
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties2(mImpl->resources(), (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2KHR returnUnmarshal");
    encoderLock.unlock();
    mImpl->resources()->on_vkGetPhysicalDeviceMemoryProperties2KHR(this, physicalDevice, pMemoryProperties);
    encoderLock.lock();
    mImpl->log("finish vkGetPhysicalDeviceMemoryProperties2KHR");;
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSparseImageFormatInfo2* local_pFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pFormatInfo = nullptr;
    if (pFormatInfo)
    {
        local_pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
        deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(pool, pFormatInfo, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    if (local_pFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(mImpl->resources(), (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_995;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_995, 1);
        countingStream->write((uint64_t*)&cgen_var_995, 1 * 8);
        marshal_VkPhysicalDeviceSparseImageFormatInfo2(countingStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_996 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_996);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_997 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_997);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties2(countingStream, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_998;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_998, 1);
    stream->write((uint64_t*)&cgen_var_998, 1 * 8);
    marshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_999 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_999);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1000 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_1000);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2KHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties2* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties2(mImpl->resources(), (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2KHR returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceSparseImageFormatProperties2KHR");;
}

#endif
#ifdef VK_KHR_device_group
void VkEncoder::vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeaturesKHR encode");
    mImpl->log("start vkGetDeviceGroupPeerMemoryFeaturesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_heapIndex;
    uint32_t local_localDeviceIndex;
    uint32_t local_remoteDeviceIndex;
    local_device = device;
    local_heapIndex = heapIndex;
    local_localDeviceIndex = localDeviceIndex;
    local_remoteDeviceIndex = remoteDeviceIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_1003;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1003, 1);
        countingStream->write((uint64_t*)&cgen_var_1003, 1 * 8);
        countingStream->write((uint32_t*)&local_heapIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
        countingStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR = OP_vkGetDeviceGroupPeerMemoryFeaturesKHR;
    stream->write(&opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1004;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1004, 1);
    stream->write((uint64_t*)&cgen_var_1004, 1 * 8);
    stream->write((uint32_t*)&local_heapIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
    stream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeaturesKHR readParams");
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeaturesKHR returnUnmarshal");
    mImpl->log("finish vkGetDeviceGroupPeerMemoryFeaturesKHR");;
}

void VkEncoder::vkCmdSetDeviceMaskKHR(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMaskKHR encode");
    mImpl->log("start vkCmdSetDeviceMaskKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_deviceMask;
    local_commandBuffer = commandBuffer;
    local_deviceMask = deviceMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_1005;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1005, 1);
        countingStream->write((uint64_t*)&cgen_var_1005, 1 * 8);
        countingStream->write((uint32_t*)&local_deviceMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetDeviceMaskKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDeviceMaskKHR = OP_vkCmdSetDeviceMaskKHR;
    stream->write(&opcode_vkCmdSetDeviceMaskKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDeviceMaskKHR, sizeof(uint32_t));
    uint64_t cgen_var_1006;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1006, 1);
    stream->write((uint64_t*)&cgen_var_1006, 1 * 8);
    stream->write((uint32_t*)&local_deviceMask, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMaskKHR readParams");
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMaskKHR returnUnmarshal");
    mImpl->log("finish vkCmdSetDeviceMaskKHR");;
}

void VkEncoder::vkCmdDispatchBaseKHR(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDispatchBaseKHR encode");
    mImpl->log("start vkCmdDispatchBaseKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_baseGroupX;
    uint32_t local_baseGroupY;
    uint32_t local_baseGroupZ;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_baseGroupX = baseGroupX;
    local_baseGroupY = baseGroupY;
    local_baseGroupZ = baseGroupZ;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    countingStream->rewind();
    {
        uint64_t cgen_var_1007;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1007, 1);
        countingStream->write((uint64_t*)&cgen_var_1007, 1 * 8);
        countingStream->write((uint32_t*)&local_baseGroupX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_baseGroupY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatchBaseKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchBaseKHR = OP_vkCmdDispatchBaseKHR;
    stream->write(&opcode_vkCmdDispatchBaseKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchBaseKHR, sizeof(uint32_t));
    uint64_t cgen_var_1008;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1008, 1);
    stream->write((uint64_t*)&cgen_var_1008, 1 * 8);
    stream->write((uint32_t*)&local_baseGroupX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_baseGroupY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDispatchBaseKHR readParams");
    AEMU_SCOPED_TRACE("vkCmdDispatchBaseKHR returnUnmarshal");
    mImpl->log("finish vkCmdDispatchBaseKHR");;
}

#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
void VkEncoder::vkTrimCommandPoolKHR(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkTrimCommandPoolKHR encode");
    mImpl->log("start vkTrimCommandPoolKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolTrimFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_1009;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1009, 1);
        countingStream->write((uint64_t*)&cgen_var_1009, 1 * 8);
        uint64_t cgen_var_1010;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_1010, 1);
        countingStream->write((uint64_t*)&cgen_var_1010, 1 * 8);
        countingStream->write((VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    }
    uint32_t packetSize_vkTrimCommandPoolKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkTrimCommandPoolKHR = OP_vkTrimCommandPoolKHR;
    stream->write(&opcode_vkTrimCommandPoolKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkTrimCommandPoolKHR, sizeof(uint32_t));
    uint64_t cgen_var_1011;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1011, 1);
    stream->write((uint64_t*)&cgen_var_1011, 1 * 8);
    uint64_t cgen_var_1012;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_1012, 1);
    stream->write((uint64_t*)&cgen_var_1012, 1 * 8);
    stream->write((VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    AEMU_SCOPED_TRACE("vkTrimCommandPoolKHR readParams");
    AEMU_SCOPED_TRACE("vkTrimCommandPoolKHR returnUnmarshal");
    mImpl->log("finish vkTrimCommandPoolKHR");;
}

#endif
#ifdef VK_KHR_device_group_creation
VkResult VkEncoder::vkEnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroupsKHR encode");
    mImpl->log("start vkEnumeratePhysicalDeviceGroupsKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    local_instance = instance;
    countingStream->rewind();
    {
        uint64_t cgen_var_1013;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1013, 1);
        countingStream->write((uint64_t*)&cgen_var_1013, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1014 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
        countingStream->putBe64(cgen_var_1014);
        if (pPhysicalDeviceGroupCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1015 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
        countingStream->putBe64(cgen_var_1015);
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                marshal_VkPhysicalDeviceGroupProperties(countingStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroupsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDeviceGroupsKHR = OP_vkEnumeratePhysicalDeviceGroupsKHR;
    stream->write(&opcode_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t));
    uint64_t cgen_var_1016;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1016, 1);
    stream->write((uint64_t*)&cgen_var_1016, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1017 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
    stream->putBe64(cgen_var_1017);
    if (pPhysicalDeviceGroupCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1018 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
    stream->putBe64(cgen_var_1018);
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            marshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroupsKHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceGroupCount;
    check_pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    check_pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            unmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            transform_fromhost_VkPhysicalDeviceGroupProperties(mImpl->resources(), (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroupsKHR returnUnmarshal");
    VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkEnumeratePhysicalDeviceGroupsKHR");;
    return vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferPropertiesKHR encode");
    mImpl->log("start vkGetPhysicalDeviceExternalBufferPropertiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalBufferInfo* local_pExternalBufferInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalBufferInfo = nullptr;
    if (pExternalBufferInfo)
    {
        local_pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalBufferInfo));
        deepcopy_VkPhysicalDeviceExternalBufferInfo(pool, pExternalBufferInfo, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    if (local_pExternalBufferInfo)
    {
        mImpl->resources()->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(local_pExternalBufferInfo, 1);
        transform_tohost_VkPhysicalDeviceExternalBufferInfo(mImpl->resources(), (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1021;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1021, 1);
        countingStream->write((uint64_t*)&cgen_var_1021, 1 * 8);
        marshal_VkPhysicalDeviceExternalBufferInfo(countingStream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
        marshal_VkExternalBufferProperties(countingStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR = OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1022;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1022, 1);
    stream->write((uint64_t*)&cgen_var_1022, 1 * 8);
    marshal_VkPhysicalDeviceExternalBufferInfo(stream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    marshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferPropertiesKHR readParams");
    unmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    if (pExternalBufferProperties)
    {
        mImpl->resources()->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
        transform_fromhost_VkExternalBufferProperties(mImpl->resources(), (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferPropertiesKHR returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceExternalBufferPropertiesKHR");;
}

#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleKHR(
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleKHR encode");
    mImpl->log("start vkGetMemoryWin32HandleKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkMemoryGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkMemoryGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkMemoryGetWin32HandleInfoKHR));
        deepcopy_VkMemoryGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkMemoryGetWin32HandleInfoKHR(mImpl->resources(), (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1023;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1023, 1);
        countingStream->write((uint64_t*)&cgen_var_1023, 1 * 8);
        marshal_VkMemoryGetWin32HandleInfoKHR(countingStream, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetMemoryWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandleKHR = OP_vkGetMemoryWin32HandleKHR;
    stream->write(&opcode_vkGetMemoryWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1024;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1024, 1);
    stream->write((uint64_t*)&cgen_var_1024, 1 * 8);
    marshal_VkMemoryGetWin32HandleInfoKHR(stream, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleKHR readParams");
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleKHR returnUnmarshal");
    VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetMemoryWin32HandleKHR");;
    return vkGetMemoryWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandlePropertiesKHR encode");
    mImpl->log("start vkGetMemoryWin32HandlePropertiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    HANDLE local_handle;
    local_device = device;
    local_handleType = handleType;
    local_handle = handle;
    countingStream->rewind();
    {
        uint64_t cgen_var_1025;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1025, 1);
        countingStream->write((uint64_t*)&cgen_var_1025, 1 * 8);
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        countingStream->write((HANDLE*)&local_handle, sizeof(HANDLE));
        marshal_VkMemoryWin32HandlePropertiesKHR(countingStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    }
    uint32_t packetSize_vkGetMemoryWin32HandlePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandlePropertiesKHR = OP_vkGetMemoryWin32HandlePropertiesKHR;
    stream->write(&opcode_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1026;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1026, 1);
    stream->write((uint64_t*)&cgen_var_1026, 1 * 8);
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    stream->write((HANDLE*)&local_handle, sizeof(HANDLE));
    marshal_VkMemoryWin32HandlePropertiesKHR(stream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandlePropertiesKHR readParams");
    unmarshal_VkMemoryWin32HandlePropertiesKHR(stream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    if (pMemoryWin32HandleProperties)
    {
        transform_fromhost_VkMemoryWin32HandlePropertiesKHR(mImpl->resources(), (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    }
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandlePropertiesKHR returnUnmarshal");
    VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetMemoryWin32HandlePropertiesKHR");;
    return vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_fd
VkResult VkEncoder::vkGetMemoryFdKHR(
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetMemoryFdKHR encode");
    mImpl->log("start vkGetMemoryFdKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkMemoryGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkMemoryGetFdInfoKHR*)pool->alloc(sizeof(const VkMemoryGetFdInfoKHR));
        deepcopy_VkMemoryGetFdInfoKHR(pool, pGetFdInfo, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkMemoryGetFdInfoKHR(mImpl->resources(), (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1027;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1027, 1);
        countingStream->write((uint64_t*)&cgen_var_1027, 1 * 8);
        marshal_VkMemoryGetFdInfoKHR(countingStream, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetMemoryFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryFdKHR = OP_vkGetMemoryFdKHR;
    stream->write(&opcode_vkGetMemoryFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1028;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1028, 1);
    stream->write((uint64_t*)&cgen_var_1028, 1 * 8);
    marshal_VkMemoryGetFdInfoKHR(stream, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    AEMU_SCOPED_TRACE("vkGetMemoryFdKHR readParams");
    stream->read((int*)pFd, sizeof(int));
    AEMU_SCOPED_TRACE("vkGetMemoryFdKHR returnUnmarshal");
    VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetMemoryFdKHR");;
    return vkGetMemoryFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryFdPropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetMemoryFdPropertiesKHR encode");
    mImpl->log("start vkGetMemoryFdPropertiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    int local_fd;
    local_device = device;
    local_handleType = handleType;
    local_fd = fd;
    countingStream->rewind();
    {
        uint64_t cgen_var_1029;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1029, 1);
        countingStream->write((uint64_t*)&cgen_var_1029, 1 * 8);
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        countingStream->write((int*)&local_fd, sizeof(int));
        marshal_VkMemoryFdPropertiesKHR(countingStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    }
    uint32_t packetSize_vkGetMemoryFdPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryFdPropertiesKHR = OP_vkGetMemoryFdPropertiesKHR;
    stream->write(&opcode_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1030;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1030, 1);
    stream->write((uint64_t*)&cgen_var_1030, 1 * 8);
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    stream->write((int*)&local_fd, sizeof(int));
    marshal_VkMemoryFdPropertiesKHR(stream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    AEMU_SCOPED_TRACE("vkGetMemoryFdPropertiesKHR readParams");
    unmarshal_VkMemoryFdPropertiesKHR(stream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    if (pMemoryFdProperties)
    {
        transform_fromhost_VkMemoryFdPropertiesKHR(mImpl->resources(), (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    }
    AEMU_SCOPED_TRACE("vkGetMemoryFdPropertiesKHR returnUnmarshal");
    VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetMemoryFdPropertiesKHR");;
    return vkGetMemoryFdPropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR encode");
    mImpl->log("start vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalSemaphoreInfo* local_pExternalSemaphoreInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalSemaphoreInfo = nullptr;
    if (pExternalSemaphoreInfo)
    {
        local_pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
        deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(pool, pExternalSemaphoreInfo, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    if (local_pExternalSemaphoreInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(mImpl->resources(), (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1031;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1031, 1);
        countingStream->write((uint64_t*)&cgen_var_1031, 1 * 8);
        marshal_VkPhysicalDeviceExternalSemaphoreInfo(countingStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
        marshal_VkExternalSemaphoreProperties(countingStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1032;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1032, 1);
    stream->write((uint64_t*)&cgen_var_1032, 1 * 8);
    marshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    marshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR readParams");
    unmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    if (pExternalSemaphoreProperties)
    {
        transform_fromhost_VkExternalSemaphoreProperties(mImpl->resources(), (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");;
}

#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
VkResult VkEncoder::vkImportSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkImportSemaphoreWin32HandleKHR encode");
    mImpl->log("start vkImportSemaphoreWin32HandleKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImportSemaphoreWin32HandleInfoKHR* local_pImportSemaphoreWin32HandleInfo;
    local_device = device;
    local_pImportSemaphoreWin32HandleInfo = nullptr;
    if (pImportSemaphoreWin32HandleInfo)
    {
        local_pImportSemaphoreWin32HandleInfo = (VkImportSemaphoreWin32HandleInfoKHR*)pool->alloc(sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
        deepcopy_VkImportSemaphoreWin32HandleInfoKHR(pool, pImportSemaphoreWin32HandleInfo, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    if (local_pImportSemaphoreWin32HandleInfo)
    {
        transform_tohost_VkImportSemaphoreWin32HandleInfoKHR(mImpl->resources(), (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1033;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1033, 1);
        countingStream->write((uint64_t*)&cgen_var_1033, 1 * 8);
        marshal_VkImportSemaphoreWin32HandleInfoKHR(countingStream, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    uint32_t packetSize_vkImportSemaphoreWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportSemaphoreWin32HandleKHR = OP_vkImportSemaphoreWin32HandleKHR;
    stream->write(&opcode_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1034;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1034, 1);
    stream->write((uint64_t*)&cgen_var_1034, 1 * 8);
    marshal_VkImportSemaphoreWin32HandleInfoKHR(stream, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    AEMU_SCOPED_TRACE("vkImportSemaphoreWin32HandleKHR readParams");
    AEMU_SCOPED_TRACE("vkImportSemaphoreWin32HandleKHR returnUnmarshal");
    VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkImportSemaphoreWin32HandleKHR");;
    return vkImportSemaphoreWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetSemaphoreWin32HandleKHR encode");
    mImpl->log("start vkGetSemaphoreWin32HandleKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSemaphoreGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkSemaphoreGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
        deepcopy_VkSemaphoreGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkSemaphoreGetWin32HandleInfoKHR(mImpl->resources(), (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1035;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1035, 1);
        countingStream->write((uint64_t*)&cgen_var_1035, 1 * 8);
        marshal_VkSemaphoreGetWin32HandleInfoKHR(countingStream, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetSemaphoreWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSemaphoreWin32HandleKHR = OP_vkGetSemaphoreWin32HandleKHR;
    stream->write(&opcode_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1036;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1036, 1);
    stream->write((uint64_t*)&cgen_var_1036, 1 * 8);
    marshal_VkSemaphoreGetWin32HandleInfoKHR(stream, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    AEMU_SCOPED_TRACE("vkGetSemaphoreWin32HandleKHR readParams");
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    AEMU_SCOPED_TRACE("vkGetSemaphoreWin32HandleKHR returnUnmarshal");
    VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetSemaphoreWin32HandleKHR");;
    return vkGetSemaphoreWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_semaphore_fd
VkResult VkEncoder::vkImportSemaphoreFdKHR(
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkImportSemaphoreFdKHR encode");
    mImpl->log("start vkImportSemaphoreFdKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImportSemaphoreFdInfoKHR* local_pImportSemaphoreFdInfo;
    local_device = device;
    local_pImportSemaphoreFdInfo = nullptr;
    if (pImportSemaphoreFdInfo)
    {
        local_pImportSemaphoreFdInfo = (VkImportSemaphoreFdInfoKHR*)pool->alloc(sizeof(const VkImportSemaphoreFdInfoKHR));
        deepcopy_VkImportSemaphoreFdInfoKHR(pool, pImportSemaphoreFdInfo, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    if (local_pImportSemaphoreFdInfo)
    {
        transform_tohost_VkImportSemaphoreFdInfoKHR(mImpl->resources(), (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1037;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1037, 1);
        countingStream->write((uint64_t*)&cgen_var_1037, 1 * 8);
        marshal_VkImportSemaphoreFdInfoKHR(countingStream, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    uint32_t packetSize_vkImportSemaphoreFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportSemaphoreFdKHR = OP_vkImportSemaphoreFdKHR;
    stream->write(&opcode_vkImportSemaphoreFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportSemaphoreFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1038;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1038, 1);
    stream->write((uint64_t*)&cgen_var_1038, 1 * 8);
    marshal_VkImportSemaphoreFdInfoKHR(stream, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    AEMU_SCOPED_TRACE("vkImportSemaphoreFdKHR readParams");
    AEMU_SCOPED_TRACE("vkImportSemaphoreFdKHR returnUnmarshal");
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkImportSemaphoreFdKHR");;
    return vkImportSemaphoreFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreFdKHR(
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetSemaphoreFdKHR encode");
    mImpl->log("start vkGetSemaphoreFdKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSemaphoreGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkSemaphoreGetFdInfoKHR*)pool->alloc(sizeof(const VkSemaphoreGetFdInfoKHR));
        deepcopy_VkSemaphoreGetFdInfoKHR(pool, pGetFdInfo, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkSemaphoreGetFdInfoKHR(mImpl->resources(), (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1039;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1039, 1);
        countingStream->write((uint64_t*)&cgen_var_1039, 1 * 8);
        marshal_VkSemaphoreGetFdInfoKHR(countingStream, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetSemaphoreFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSemaphoreFdKHR = OP_vkGetSemaphoreFdKHR;
    stream->write(&opcode_vkGetSemaphoreFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSemaphoreFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1040;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1040, 1);
    stream->write((uint64_t*)&cgen_var_1040, 1 * 8);
    marshal_VkSemaphoreGetFdInfoKHR(stream, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    AEMU_SCOPED_TRACE("vkGetSemaphoreFdKHR readParams");
    stream->read((int*)pFd, sizeof(int));
    AEMU_SCOPED_TRACE("vkGetSemaphoreFdKHR returnUnmarshal");
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetSemaphoreFdKHR");;
    return vkGetSemaphoreFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_push_descriptor
void VkEncoder::vkCmdPushDescriptorSetKHR(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t set,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdPushDescriptorSetKHR encode");
    mImpl->log("start vkCmdPushDescriptorSetKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipelineLayout local_layout;
    uint32_t local_set;
    uint32_t local_descriptorWriteCount;
    VkWriteDescriptorSet* local_pDescriptorWrites;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_layout = layout;
    local_set = set;
    local_descriptorWriteCount = descriptorWriteCount;
    local_pDescriptorWrites = nullptr;
    if (pDescriptorWrites)
    {
        local_pDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, pDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    if (local_pDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(mImpl->resources(), (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1041;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1041, 1);
        countingStream->write((uint64_t*)&cgen_var_1041, 1 * 8);
        countingStream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
        uint64_t cgen_var_1042;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_1042, 1);
        countingStream->write((uint64_t*)&cgen_var_1042, 1 * 8);
        countingStream->write((uint32_t*)&local_set, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            marshal_VkWriteDescriptorSet(countingStream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushDescriptorSetKHR = OP_vkCmdPushDescriptorSetKHR;
    stream->write(&opcode_vkCmdPushDescriptorSetKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushDescriptorSetKHR, sizeof(uint32_t));
    uint64_t cgen_var_1043;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1043, 1);
    stream->write((uint64_t*)&cgen_var_1043, 1 * 8);
    stream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_1044;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_1044, 1);
    stream->write((uint64_t*)&cgen_var_1044, 1 * 8);
    stream->write((uint32_t*)&local_set, sizeof(uint32_t));
    stream->write((uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        marshal_VkWriteDescriptorSet(stream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
    }
    AEMU_SCOPED_TRACE("vkCmdPushDescriptorSetKHR readParams");
    AEMU_SCOPED_TRACE("vkCmdPushDescriptorSetKHR returnUnmarshal");
    mImpl->log("finish vkCmdPushDescriptorSetKHR");;
}

void VkEncoder::vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer commandBuffer,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    VkPipelineLayout layout,
    uint32_t set,
    const void* pData)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdPushDescriptorSetWithTemplateKHR encode");
    mImpl->log("start vkCmdPushDescriptorSetWithTemplateKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkPipelineLayout local_layout;
    uint32_t local_set;
    void* local_pData;
    local_commandBuffer = commandBuffer;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_layout = layout;
    local_set = set;
    local_pData = nullptr;
    if (pData)
    {
        local_pData = (void*)pool->dupArray(pData, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1045;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1045, 1);
        countingStream->write((uint64_t*)&cgen_var_1045, 1 * 8);
        uint64_t cgen_var_1046;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1046, 1);
        countingStream->write((uint64_t*)&cgen_var_1046, 1 * 8);
        uint64_t cgen_var_1047;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_1047, 1);
        countingStream->write((uint64_t*)&cgen_var_1047, 1 * 8);
        countingStream->write((uint32_t*)&local_set, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_1048 = (uint64_t)(uintptr_t)local_pData;
        countingStream->putBe64(cgen_var_1048);
        if (local_pData)
        {
            countingStream->write((void*)local_pData, sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetWithTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushDescriptorSetWithTemplateKHR = OP_vkCmdPushDescriptorSetWithTemplateKHR;
    stream->write(&opcode_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    uint64_t cgen_var_1049;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1049, 1);
    stream->write((uint64_t*)&cgen_var_1049, 1 * 8);
    uint64_t cgen_var_1050;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1050, 1);
    stream->write((uint64_t*)&cgen_var_1050, 1 * 8);
    uint64_t cgen_var_1051;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_1051, 1);
    stream->write((uint64_t*)&cgen_var_1051, 1 * 8);
    stream->write((uint32_t*)&local_set, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1052 = (uint64_t)(uintptr_t)local_pData;
    stream->putBe64(cgen_var_1052);
    if (local_pData)
    {
        stream->write((void*)local_pData, sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkCmdPushDescriptorSetWithTemplateKHR readParams");
    AEMU_SCOPED_TRACE("vkCmdPushDescriptorSetWithTemplateKHR returnUnmarshal");
    mImpl->log("finish vkCmdPushDescriptorSetWithTemplateKHR");;
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
VkResult VkEncoder::vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplateKHR encode");
    mImpl->log("start vkCreateDescriptorUpdateTemplateKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorUpdateTemplateCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo*)pool->alloc(sizeof(const VkDescriptorUpdateTemplateCreateInfo));
        deepcopy_VkDescriptorUpdateTemplateCreateInfo(pool, pCreateInfo, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorUpdateTemplateCreateInfo(mImpl->resources(), (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1053;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1053, 1);
        countingStream->write((uint64_t*)&cgen_var_1053, 1 * 8);
        marshal_VkDescriptorUpdateTemplateCreateInfo(countingStream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1054 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1054);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1055;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_1055, 1);
        countingStream->write((uint64_t*)&cgen_var_1055, 8);
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorUpdateTemplateKHR = OP_vkCreateDescriptorUpdateTemplateKHR;
    stream->write(&opcode_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    uint64_t cgen_var_1056;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1056, 1);
    stream->write((uint64_t*)&cgen_var_1056, 1 * 8);
    marshal_VkDescriptorUpdateTemplateCreateInfo(stream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1057 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1057);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1058;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_1058, 1);
    stream->write((uint64_t*)&cgen_var_1058, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplateKHR readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1059;
    stream->read((uint64_t*)&cgen_var_1059, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_1059, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplateKHR returnUnmarshal");
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    encoderLock.unlock();
    mImpl->resources()->on_vkCreateDescriptorUpdateTemplateKHR(this, vkCreateDescriptorUpdateTemplateKHR_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    encoderLock.lock();
    mImpl->log("finish vkCreateDescriptorUpdateTemplateKHR");;
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplateKHR encode");
    mImpl->log("start vkDestroyDescriptorUpdateTemplateKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1060;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1060, 1);
        countingStream->write((uint64_t*)&cgen_var_1060, 1 * 8);
        uint64_t cgen_var_1061;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1061, 1);
        countingStream->write((uint64_t*)&cgen_var_1061, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1062 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1062);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorUpdateTemplateKHR = OP_vkDestroyDescriptorUpdateTemplateKHR;
    stream->write(&opcode_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    uint64_t cgen_var_1063;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1063, 1);
    stream->write((uint64_t*)&cgen_var_1063, 1 * 8);
    uint64_t cgen_var_1064;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1064, 1);
    stream->write((uint64_t*)&cgen_var_1064, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1065 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1065);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplateKHR readParams");
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplateKHR returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate);
    mImpl->log("finish vkDestroyDescriptorUpdateTemplateKHR");;
}

void VkEncoder::vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateKHR encode");
    mImpl->log("start vkUpdateDescriptorSetWithTemplateKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    void* local_pData;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pData = nullptr;
    if (pData)
    {
        local_pData = (void*)pool->dupArray(pData, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1066;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1066, 1);
        countingStream->write((uint64_t*)&cgen_var_1066, 1 * 8);
        uint64_t cgen_var_1067;
        countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_1067, 1);
        countingStream->write((uint64_t*)&cgen_var_1067, 1 * 8);
        uint64_t cgen_var_1068;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1068, 1);
        countingStream->write((uint64_t*)&cgen_var_1068, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1069 = (uint64_t)(uintptr_t)local_pData;
        countingStream->putBe64(cgen_var_1069);
        if (local_pData)
        {
            countingStream->write((void*)local_pData, sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSetWithTemplateKHR = OP_vkUpdateDescriptorSetWithTemplateKHR;
    stream->write(&opcode_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    uint64_t cgen_var_1070;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1070, 1);
    stream->write((uint64_t*)&cgen_var_1070, 1 * 8);
    uint64_t cgen_var_1071;
    stream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_1071, 1);
    stream->write((uint64_t*)&cgen_var_1071, 1 * 8);
    uint64_t cgen_var_1072;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1072, 1);
    stream->write((uint64_t*)&cgen_var_1072, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1073 = (uint64_t)(uintptr_t)local_pData;
    stream->putBe64(cgen_var_1073);
    if (local_pData)
    {
        stream->write((void*)local_pData, sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateKHR readParams");
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateKHR returnUnmarshal");
    mImpl->log("finish vkUpdateDescriptorSetWithTemplateKHR");;
}

#endif
#ifdef VK_KHR_create_renderpass2
VkResult VkEncoder::vkCreateRenderPass2KHR(
    VkDevice device,
    const VkRenderPassCreateInfo2KHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateRenderPass2KHR encode");
    mImpl->log("start vkCreateRenderPass2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkRenderPassCreateInfo2KHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo2KHR*)pool->alloc(sizeof(const VkRenderPassCreateInfo2KHR));
        deepcopy_VkRenderPassCreateInfo2KHR(pool, pCreateInfo, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo2KHR(mImpl->resources(), (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1074;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1074, 1);
        countingStream->write((uint64_t*)&cgen_var_1074, 1 * 8);
        marshal_VkRenderPassCreateInfo2KHR(countingStream, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1075 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1075);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1076;
        countingStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_1076, 1);
        countingStream->write((uint64_t*)&cgen_var_1076, 8);
    }
    uint32_t packetSize_vkCreateRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateRenderPass2KHR = OP_vkCreateRenderPass2KHR;
    stream->write(&opcode_vkCreateRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateRenderPass2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1077;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1077, 1);
    stream->write((uint64_t*)&cgen_var_1077, 1 * 8);
    marshal_VkRenderPassCreateInfo2KHR(stream, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1078 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1078);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1079;
    stream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_1079, 1);
    stream->write((uint64_t*)&cgen_var_1079, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateRenderPass2KHR readParams");
    uint64_t cgen_var_1080;
    stream->read((uint64_t*)&cgen_var_1080, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_1080, (VkRenderPass*)pRenderPass, 1);
    AEMU_SCOPED_TRACE("vkCreateRenderPass2KHR returnUnmarshal");
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateRenderPass2KHR");;
    return vkCreateRenderPass2KHR_VkResult_return;
}

void VkEncoder::vkCmdBeginRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2KHR encode");
    mImpl->log("start vkCmdBeginRenderPass2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassBeginInfoKHR* local_pSubpassBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfoKHR*)pool->alloc(sizeof(const VkSubpassBeginInfoKHR));
        deepcopy_VkSubpassBeginInfoKHR(pool, pSubpassBeginInfo, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(mImpl->resources(), (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfoKHR(mImpl->resources(), (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1081;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1081, 1);
        countingStream->write((uint64_t*)&cgen_var_1081, 1 * 8);
        marshal_VkRenderPassBeginInfo(countingStream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
        marshal_VkSubpassBeginInfoKHR(countingStream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    uint32_t packetSize_vkCmdBeginRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginRenderPass2KHR = OP_vkCmdBeginRenderPass2KHR;
    stream->write(&opcode_vkCmdBeginRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginRenderPass2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1082;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1082, 1);
    stream->write((uint64_t*)&cgen_var_1082, 1 * 8);
    marshal_VkRenderPassBeginInfo(stream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    marshal_VkSubpassBeginInfoKHR(stream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2KHR readParams");
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2KHR returnUnmarshal");
    mImpl->log("finish vkCmdBeginRenderPass2KHR");;
}

void VkEncoder::vkCmdNextSubpass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2KHR encode");
    mImpl->log("start vkCmdNextSubpass2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkSubpassBeginInfoKHR* local_pSubpassBeginInfo;
    VkSubpassEndInfoKHR* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfoKHR*)pool->alloc(sizeof(const VkSubpassBeginInfoKHR));
        deepcopy_VkSubpassBeginInfoKHR(pool, pSubpassBeginInfo, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfoKHR*)pool->alloc(sizeof(const VkSubpassEndInfoKHR));
        deepcopy_VkSubpassEndInfoKHR(pool, pSubpassEndInfo, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfoKHR(mImpl->resources(), (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfoKHR(mImpl->resources(), (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1083;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1083, 1);
        countingStream->write((uint64_t*)&cgen_var_1083, 1 * 8);
        marshal_VkSubpassBeginInfoKHR(countingStream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
        marshal_VkSubpassEndInfoKHR(countingStream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    uint32_t packetSize_vkCmdNextSubpass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdNextSubpass2KHR = OP_vkCmdNextSubpass2KHR;
    stream->write(&opcode_vkCmdNextSubpass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdNextSubpass2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1084;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1084, 1);
    stream->write((uint64_t*)&cgen_var_1084, 1 * 8);
    marshal_VkSubpassBeginInfoKHR(stream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    marshal_VkSubpassEndInfoKHR(stream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2KHR readParams");
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2KHR returnUnmarshal");
    mImpl->log("finish vkCmdNextSubpass2KHR");;
}

void VkEncoder::vkCmdEndRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2KHR encode");
    mImpl->log("start vkCmdEndRenderPass2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkSubpassEndInfoKHR* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfoKHR*)pool->alloc(sizeof(const VkSubpassEndInfoKHR));
        deepcopy_VkSubpassEndInfoKHR(pool, pSubpassEndInfo, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfoKHR(mImpl->resources(), (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1085;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1085, 1);
        countingStream->write((uint64_t*)&cgen_var_1085, 1 * 8);
        marshal_VkSubpassEndInfoKHR(countingStream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    uint32_t packetSize_vkCmdEndRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndRenderPass2KHR = OP_vkCmdEndRenderPass2KHR;
    stream->write(&opcode_vkCmdEndRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndRenderPass2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1086;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1086, 1);
    stream->write((uint64_t*)&cgen_var_1086, 1 * 8);
    marshal_VkSubpassEndInfoKHR(stream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2KHR readParams");
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2KHR returnUnmarshal");
    mImpl->log("finish vkCmdEndRenderPass2KHR");;
}

#endif
#ifdef VK_KHR_shared_presentable_image
VkResult VkEncoder::vkGetSwapchainStatusKHR(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetSwapchainStatusKHR encode");
    mImpl->log("start vkGetSwapchainStatusKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    countingStream->rewind();
    {
        uint64_t cgen_var_1087;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1087, 1);
        countingStream->write((uint64_t*)&cgen_var_1087, 1 * 8);
        uint64_t cgen_var_1088;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1088, 1);
        countingStream->write((uint64_t*)&cgen_var_1088, 1 * 8);
    }
    uint32_t packetSize_vkGetSwapchainStatusKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainStatusKHR = OP_vkGetSwapchainStatusKHR;
    stream->write(&opcode_vkGetSwapchainStatusKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainStatusKHR, sizeof(uint32_t));
    uint64_t cgen_var_1089;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1089, 1);
    stream->write((uint64_t*)&cgen_var_1089, 1 * 8);
    uint64_t cgen_var_1090;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1090, 1);
    stream->write((uint64_t*)&cgen_var_1090, 1 * 8);
    AEMU_SCOPED_TRACE("vkGetSwapchainStatusKHR readParams");
    AEMU_SCOPED_TRACE("vkGetSwapchainStatusKHR returnUnmarshal");
    VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetSwapchainStatusKHR");;
    return vkGetSwapchainStatusKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFencePropertiesKHR encode");
    mImpl->log("start vkGetPhysicalDeviceExternalFencePropertiesKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalFenceInfo* local_pExternalFenceInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalFenceInfo = nullptr;
    if (pExternalFenceInfo)
    {
        local_pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalFenceInfo));
        deepcopy_VkPhysicalDeviceExternalFenceInfo(pool, pExternalFenceInfo, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    if (local_pExternalFenceInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalFenceInfo(mImpl->resources(), (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1091;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1091, 1);
        countingStream->write((uint64_t*)&cgen_var_1091, 1 * 8);
        marshal_VkPhysicalDeviceExternalFenceInfo(countingStream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
        marshal_VkExternalFenceProperties(countingStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR = OP_vkGetPhysicalDeviceExternalFencePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1092;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1092, 1);
    stream->write((uint64_t*)&cgen_var_1092, 1 * 8);
    marshal_VkPhysicalDeviceExternalFenceInfo(stream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    marshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFencePropertiesKHR readParams");
    unmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    if (pExternalFenceProperties)
    {
        transform_fromhost_VkExternalFenceProperties(mImpl->resources(), (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFencePropertiesKHR returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceExternalFencePropertiesKHR");;
}

#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
VkResult VkEncoder::vkImportFenceWin32HandleKHR(
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkImportFenceWin32HandleKHR encode");
    mImpl->log("start vkImportFenceWin32HandleKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImportFenceWin32HandleInfoKHR* local_pImportFenceWin32HandleInfo;
    local_device = device;
    local_pImportFenceWin32HandleInfo = nullptr;
    if (pImportFenceWin32HandleInfo)
    {
        local_pImportFenceWin32HandleInfo = (VkImportFenceWin32HandleInfoKHR*)pool->alloc(sizeof(const VkImportFenceWin32HandleInfoKHR));
        deepcopy_VkImportFenceWin32HandleInfoKHR(pool, pImportFenceWin32HandleInfo, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    if (local_pImportFenceWin32HandleInfo)
    {
        transform_tohost_VkImportFenceWin32HandleInfoKHR(mImpl->resources(), (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1093;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1093, 1);
        countingStream->write((uint64_t*)&cgen_var_1093, 1 * 8);
        marshal_VkImportFenceWin32HandleInfoKHR(countingStream, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    uint32_t packetSize_vkImportFenceWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportFenceWin32HandleKHR = OP_vkImportFenceWin32HandleKHR;
    stream->write(&opcode_vkImportFenceWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportFenceWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1094;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1094, 1);
    stream->write((uint64_t*)&cgen_var_1094, 1 * 8);
    marshal_VkImportFenceWin32HandleInfoKHR(stream, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    AEMU_SCOPED_TRACE("vkImportFenceWin32HandleKHR readParams");
    AEMU_SCOPED_TRACE("vkImportFenceWin32HandleKHR returnUnmarshal");
    VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkImportFenceWin32HandleKHR");;
    return vkImportFenceWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceWin32HandleKHR(
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetFenceWin32HandleKHR encode");
    mImpl->log("start vkGetFenceWin32HandleKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFenceGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkFenceGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkFenceGetWin32HandleInfoKHR));
        deepcopy_VkFenceGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkFenceGetWin32HandleInfoKHR(mImpl->resources(), (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1095;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1095, 1);
        countingStream->write((uint64_t*)&cgen_var_1095, 1 * 8);
        marshal_VkFenceGetWin32HandleInfoKHR(countingStream, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetFenceWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceWin32HandleKHR = OP_vkGetFenceWin32HandleKHR;
    stream->write(&opcode_vkGetFenceWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1096;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1096, 1);
    stream->write((uint64_t*)&cgen_var_1096, 1 * 8);
    marshal_VkFenceGetWin32HandleInfoKHR(stream, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    AEMU_SCOPED_TRACE("vkGetFenceWin32HandleKHR readParams");
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    AEMU_SCOPED_TRACE("vkGetFenceWin32HandleKHR returnUnmarshal");
    VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetFenceWin32HandleKHR");;
    return vkGetFenceWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_fd
VkResult VkEncoder::vkImportFenceFdKHR(
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkImportFenceFdKHR encode");
    mImpl->log("start vkImportFenceFdKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImportFenceFdInfoKHR* local_pImportFenceFdInfo;
    local_device = device;
    local_pImportFenceFdInfo = nullptr;
    if (pImportFenceFdInfo)
    {
        local_pImportFenceFdInfo = (VkImportFenceFdInfoKHR*)pool->alloc(sizeof(const VkImportFenceFdInfoKHR));
        deepcopy_VkImportFenceFdInfoKHR(pool, pImportFenceFdInfo, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    if (local_pImportFenceFdInfo)
    {
        transform_tohost_VkImportFenceFdInfoKHR(mImpl->resources(), (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1097;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1097, 1);
        countingStream->write((uint64_t*)&cgen_var_1097, 1 * 8);
        marshal_VkImportFenceFdInfoKHR(countingStream, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    uint32_t packetSize_vkImportFenceFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportFenceFdKHR = OP_vkImportFenceFdKHR;
    stream->write(&opcode_vkImportFenceFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportFenceFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1098;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1098, 1);
    stream->write((uint64_t*)&cgen_var_1098, 1 * 8);
    marshal_VkImportFenceFdInfoKHR(stream, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    AEMU_SCOPED_TRACE("vkImportFenceFdKHR readParams");
    AEMU_SCOPED_TRACE("vkImportFenceFdKHR returnUnmarshal");
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkImportFenceFdKHR");;
    return vkImportFenceFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceFdKHR(
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetFenceFdKHR encode");
    mImpl->log("start vkGetFenceFdKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFenceGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkFenceGetFdInfoKHR*)pool->alloc(sizeof(const VkFenceGetFdInfoKHR));
        deepcopy_VkFenceGetFdInfoKHR(pool, pGetFdInfo, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkFenceGetFdInfoKHR(mImpl->resources(), (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1099;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1099, 1);
        countingStream->write((uint64_t*)&cgen_var_1099, 1 * 8);
        marshal_VkFenceGetFdInfoKHR(countingStream, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetFenceFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceFdKHR = OP_vkGetFenceFdKHR;
    stream->write(&opcode_vkGetFenceFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1100;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1100, 1);
    stream->write((uint64_t*)&cgen_var_1100, 1 * 8);
    marshal_VkFenceGetFdInfoKHR(stream, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    AEMU_SCOPED_TRACE("vkGetFenceFdKHR readParams");
    stream->read((int*)pFd, sizeof(int));
    AEMU_SCOPED_TRACE("vkGetFenceFdKHR returnUnmarshal");
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetFenceFdKHR");;
    return vkGetFenceFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilities2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(mImpl->resources(), (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1101;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1101, 1);
        countingStream->write((uint64_t*)&cgen_var_1101, 1 * 8);
        marshal_VkPhysicalDeviceSurfaceInfo2KHR(countingStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
        marshal_VkSurfaceCapabilities2KHR(countingStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR = OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1102;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1102, 1);
    stream->write((uint64_t*)&cgen_var_1102, 1 * 8);
    marshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    marshal_VkSurfaceCapabilities2KHR(stream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilities2KHR readParams");
    unmarshal_VkSurfaceCapabilities2KHR(stream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilities2KHR(mImpl->resources(), (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilities2KHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceSurfaceCapabilities2KHR");;
    return vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormat2KHR* pSurfaceFormats)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceFormats2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceSurfaceFormats2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(mImpl->resources(), (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1103;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1103, 1);
        countingStream->write((uint64_t*)&cgen_var_1103, 1 * 8);
        marshal_VkPhysicalDeviceSurfaceInfo2KHR(countingStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1104 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
        countingStream->putBe64(cgen_var_1104);
        if (pSurfaceFormatCount)
        {
            countingStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1105 = (uint64_t)(uintptr_t)pSurfaceFormats;
        countingStream->putBe64(cgen_var_1105);
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                marshal_VkSurfaceFormat2KHR(countingStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormats2KHR = OP_vkGetPhysicalDeviceSurfaceFormats2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1106;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1106, 1);
    stream->write((uint64_t*)&cgen_var_1106, 1 * 8);
    marshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1107 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
    stream->putBe64(cgen_var_1107);
    if (pSurfaceFormatCount)
    {
        stream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1108 = (uint64_t)(uintptr_t)pSurfaceFormats;
    stream->putBe64(cgen_var_1108);
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            marshal_VkSurfaceFormat2KHR(stream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceFormats2KHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pSurfaceFormatCount;
    check_pSurfaceFormatCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSurfaceFormat2KHR* check_pSurfaceFormats;
    check_pSurfaceFormats = (VkSurfaceFormat2KHR*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            unmarshal_VkSurfaceFormat2KHR(stream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            transform_fromhost_VkSurfaceFormat2KHR(mImpl->resources(), (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceFormats2KHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceSurfaceFormats2KHR");;
    return vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
VkResult VkEncoder::vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayProperties2KHR* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayProperties2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceDisplayProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_1111;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1111, 1);
        countingStream->write((uint64_t*)&cgen_var_1111, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1112 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_1112);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1113 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_1113);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayProperties2KHR(countingStream, (VkDisplayProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayProperties2KHR = OP_vkGetPhysicalDeviceDisplayProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1114;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1114, 1);
    stream->write((uint64_t*)&cgen_var_1114, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1115 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_1115);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1116 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_1116);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayProperties2KHR(stream, (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayProperties2KHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayProperties2KHR(stream, (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayProperties2KHR(mImpl->resources(), (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayProperties2KHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceDisplayProperties2KHR");;
    return vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlaneProperties2KHR* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPlaneProperties2KHR encode");
    mImpl->log("start vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_1119;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1119, 1);
        countingStream->write((uint64_t*)&cgen_var_1119, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1120 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_1120);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1121 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_1121);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPlaneProperties2KHR(countingStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1122;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1122, 1);
    stream->write((uint64_t*)&cgen_var_1122, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1123 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_1123);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1124 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_1124);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPlaneProperties2KHR(stream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPlaneProperties2KHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPlaneProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayPlaneProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPlaneProperties2KHR(stream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPlaneProperties2KHR(mImpl->resources(), (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPlaneProperties2KHR returnUnmarshal");
    VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceDisplayPlaneProperties2KHR");;
    return vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModeProperties2KHR* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDisplayModeProperties2KHR encode");
    mImpl->log("start vkGetDisplayModeProperties2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    countingStream->rewind();
    {
        uint64_t cgen_var_1127;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1127, 1);
        countingStream->write((uint64_t*)&cgen_var_1127, 1 * 8);
        uint64_t cgen_var_1128;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1128, 1);
        countingStream->write((uint64_t*)&cgen_var_1128, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1129 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_1129);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1130 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_1130);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayModeProperties2KHR(countingStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModeProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayModeProperties2KHR = OP_vkGetDisplayModeProperties2KHR;
    stream->write(&opcode_vkGetDisplayModeProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayModeProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1131;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1131, 1);
    stream->write((uint64_t*)&cgen_var_1131, 1 * 8);
    uint64_t cgen_var_1132;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1132, 1);
    stream->write((uint64_t*)&cgen_var_1132, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1133 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_1133);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1134 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_1134);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayModeProperties2KHR(stream, (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetDisplayModeProperties2KHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayModeProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayModeProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayModeProperties2KHR(stream, (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayModeProperties2KHR(mImpl->resources(), (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetDisplayModeProperties2KHR returnUnmarshal");
    VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetDisplayModeProperties2KHR");;
    return vkGetDisplayModeProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR* pCapabilities)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneCapabilities2KHR encode");
    mImpl->log("start vkGetDisplayPlaneCapabilities2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayPlaneInfo2KHR* local_pDisplayPlaneInfo;
    local_physicalDevice = physicalDevice;
    local_pDisplayPlaneInfo = nullptr;
    if (pDisplayPlaneInfo)
    {
        local_pDisplayPlaneInfo = (VkDisplayPlaneInfo2KHR*)pool->alloc(sizeof(const VkDisplayPlaneInfo2KHR));
        deepcopy_VkDisplayPlaneInfo2KHR(pool, pDisplayPlaneInfo, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    }
    if (local_pDisplayPlaneInfo)
    {
        transform_tohost_VkDisplayPlaneInfo2KHR(mImpl->resources(), (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1137;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1137, 1);
        countingStream->write((uint64_t*)&cgen_var_1137, 1 * 8);
        marshal_VkDisplayPlaneInfo2KHR(countingStream, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
        marshal_VkDisplayPlaneCapabilities2KHR(countingStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilities2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneCapabilities2KHR = OP_vkGetDisplayPlaneCapabilities2KHR;
    stream->write(&opcode_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1138;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1138, 1);
    stream->write((uint64_t*)&cgen_var_1138, 1 * 8);
    marshal_VkDisplayPlaneInfo2KHR(stream, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    marshal_VkDisplayPlaneCapabilities2KHR(stream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneCapabilities2KHR readParams");
    unmarshal_VkDisplayPlaneCapabilities2KHR(stream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    if (pCapabilities)
    {
        transform_fromhost_VkDisplayPlaneCapabilities2KHR(mImpl->resources(), (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    }
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneCapabilities2KHR returnUnmarshal");
    VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetDisplayPlaneCapabilities2KHR");;
    return vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
void VkEncoder::vkGetImageMemoryRequirements2KHR(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2KHR encode");
    mImpl->log("start vkGetImageMemoryRequirements2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageMemoryRequirementsInfo2));
        deepcopy_VkImageMemoryRequirementsInfo2(pool, pInfo, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageMemoryRequirementsInfo2(mImpl->resources(), (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1139;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1139, 1);
        countingStream->write((uint64_t*)&cgen_var_1139, 1 * 8);
        marshal_VkImageMemoryRequirementsInfo2(countingStream, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements2KHR = OP_vkGetImageMemoryRequirements2KHR;
    stream->write(&opcode_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1140;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1140, 1);
    stream->write((uint64_t*)&cgen_var_1140, 1 * 8);
    marshal_VkImageMemoryRequirementsInfo2(stream, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2KHR readParams");
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(mImpl->resources(), (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2KHR returnUnmarshal");
    mImpl->log("finish vkGetImageMemoryRequirements2KHR");;
}

void VkEncoder::vkGetBufferMemoryRequirements2KHR(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2KHR encode");
    mImpl->log("start vkGetBufferMemoryRequirements2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkBufferMemoryRequirementsInfo2));
        deepcopy_VkBufferMemoryRequirementsInfo2(pool, pInfo, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferMemoryRequirementsInfo2(mImpl->resources(), (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1141;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1141, 1);
        countingStream->write((uint64_t*)&cgen_var_1141, 1 * 8);
        marshal_VkBufferMemoryRequirementsInfo2(countingStream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements2KHR = OP_vkGetBufferMemoryRequirements2KHR;
    stream->write(&opcode_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1142;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1142, 1);
    stream->write((uint64_t*)&cgen_var_1142, 1 * 8);
    marshal_VkBufferMemoryRequirementsInfo2(stream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2KHR readParams");
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(mImpl->resources(), (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2KHR returnUnmarshal");
    mImpl->log("finish vkGetBufferMemoryRequirements2KHR");;
}

void VkEncoder::vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2KHR encode");
    mImpl->log("start vkGetImageSparseMemoryRequirements2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageSparseMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageSparseMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageSparseMemoryRequirementsInfo2));
        deepcopy_VkImageSparseMemoryRequirementsInfo2(pool, pInfo, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageSparseMemoryRequirementsInfo2(mImpl->resources(), (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1143;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1143, 1);
        countingStream->write((uint64_t*)&cgen_var_1143, 1 * 8);
        marshal_VkImageSparseMemoryRequirementsInfo2(countingStream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1144 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
        countingStream->putBe64(cgen_var_1144);
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1145 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
        countingStream->putBe64(cgen_var_1145);
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements2(countingStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements2KHR = OP_vkGetImageSparseMemoryRequirements2KHR;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1146;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1146, 1);
    stream->write((uint64_t*)&cgen_var_1146, 1 * 8);
    marshal_VkImageSparseMemoryRequirementsInfo2(stream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1147 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    stream->putBe64(cgen_var_1147);
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1148 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    stream->putBe64(cgen_var_1148);
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2KHR readParams");
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements2(mImpl->resources(), (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2KHR returnUnmarshal");
    mImpl->log("finish vkGetImageSparseMemoryRequirements2KHR");;
}

#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
VkResult VkEncoder::vkCreateSamplerYcbcrConversionKHR(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversionKHR encode");
    mImpl->log("start vkCreateSamplerYcbcrConversionKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerYcbcrConversionCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerYcbcrConversionCreateInfo*)pool->alloc(sizeof(const VkSamplerYcbcrConversionCreateInfo));
        deepcopy_VkSamplerYcbcrConversionCreateInfo(pool, pCreateInfo, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerYcbcrConversionCreateInfo(mImpl->resources(), (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1151;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1151, 1);
        countingStream->write((uint64_t*)&cgen_var_1151, 1 * 8);
        marshal_VkSamplerYcbcrConversionCreateInfo(countingStream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1152 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1152);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1153;
        countingStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_1153, 1);
        countingStream->write((uint64_t*)&cgen_var_1153, 8);
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversionKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSamplerYcbcrConversionKHR = OP_vkCreateSamplerYcbcrConversionKHR;
    stream->write(&opcode_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t));
    uint64_t cgen_var_1154;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1154, 1);
    stream->write((uint64_t*)&cgen_var_1154, 1 * 8);
    marshal_VkSamplerYcbcrConversionCreateInfo(stream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1155 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1155);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1156;
    stream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_1156, 1);
    stream->write((uint64_t*)&cgen_var_1156, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversionKHR readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1157;
    stream->read((uint64_t*)&cgen_var_1157, 8);
    stream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_1157, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversionKHR returnUnmarshal");
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateSamplerYcbcrConversionKHR");;
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversionKHR(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversionKHR encode");
    mImpl->log("start vkDestroySamplerYcbcrConversionKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerYcbcrConversion local_ycbcrConversion;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_ycbcrConversion = ycbcrConversion;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1158;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1158, 1);
        countingStream->write((uint64_t*)&cgen_var_1158, 1 * 8);
        uint64_t cgen_var_1159;
        countingStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&local_ycbcrConversion, &cgen_var_1159, 1);
        countingStream->write((uint64_t*)&cgen_var_1159, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1160 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1160);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversionKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySamplerYcbcrConversionKHR = OP_vkDestroySamplerYcbcrConversionKHR;
    stream->write(&opcode_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t));
    uint64_t cgen_var_1161;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1161, 1);
    stream->write((uint64_t*)&cgen_var_1161, 1 * 8);
    uint64_t cgen_var_1162;
    stream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&local_ycbcrConversion, &cgen_var_1162, 1);
    stream->write((uint64_t*)&cgen_var_1162, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1163 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1163);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversionKHR readParams");
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversionKHR returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&ycbcrConversion);
    mImpl->log("finish vkDestroySamplerYcbcrConversionKHR");;
}

#endif
#ifdef VK_KHR_bind_memory2
VkResult VkEncoder::vkBindBufferMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkBindBufferMemory2KHR encode");
    mImpl->log("start vkBindBufferMemory2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindBufferMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindBufferMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindBufferMemoryInfo(pool, pBindInfos + i, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindBufferMemoryInfo(mImpl->resources(), (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1164;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1164, 1);
        countingStream->write((uint64_t*)&cgen_var_1164, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindBufferMemoryInfo(countingStream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindBufferMemory2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory2KHR = OP_vkBindBufferMemory2KHR;
    stream->write(&opcode_vkBindBufferMemory2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1165;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1165, 1);
    stream->write((uint64_t*)&cgen_var_1165, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindBufferMemoryInfo(stream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
    }
    AEMU_SCOPED_TRACE("vkBindBufferMemory2KHR readParams");
    AEMU_SCOPED_TRACE("vkBindBufferMemory2KHR returnUnmarshal");
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkBindBufferMemory2KHR");;
    return vkBindBufferMemory2KHR_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkBindImageMemory2KHR encode");
    mImpl->log("start vkBindImageMemory2KHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindImageMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindImageMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindImageMemoryInfo(pool, pBindInfos + i, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindImageMemoryInfo(mImpl->resources(), (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1166;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1166, 1);
        countingStream->write((uint64_t*)&cgen_var_1166, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindImageMemoryInfo(countingStream, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindImageMemory2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory2KHR = OP_vkBindImageMemory2KHR;
    stream->write(&opcode_vkBindImageMemory2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1167;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1167, 1);
    stream->write((uint64_t*)&cgen_var_1167, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindImageMemoryInfo(stream, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
    }
    AEMU_SCOPED_TRACE("vkBindImageMemory2KHR readParams");
    AEMU_SCOPED_TRACE("vkBindImageMemory2KHR returnUnmarshal");
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkBindImageMemory2KHR");;
    return vkBindImageMemory2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance3
void VkEncoder::vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupportKHR encode");
    mImpl->log("start vkGetDescriptorSetLayoutSupportKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(mImpl->resources(), (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1168;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1168, 1);
        countingStream->write((uint64_t*)&cgen_var_1168, 1 * 8);
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
        marshal_VkDescriptorSetLayoutSupport(countingStream, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDescriptorSetLayoutSupportKHR = OP_vkGetDescriptorSetLayoutSupportKHR;
    stream->write(&opcode_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_1169;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1169, 1);
    stream->write((uint64_t*)&cgen_var_1169, 1 * 8);
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    marshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupportKHR readParams");
    unmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    if (pSupport)
    {
        transform_fromhost_VkDescriptorSetLayoutSupport(mImpl->resources(), (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupportKHR returnUnmarshal");
    mImpl->log("finish vkGetDescriptorSetLayoutSupportKHR");;
}

#endif
#ifdef VK_KHR_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCountKHR encode");
    mImpl->log("start vkCmdDrawIndirectCountKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_1170;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1170, 1);
        countingStream->write((uint64_t*)&cgen_var_1170, 1 * 8);
        uint64_t cgen_var_1171;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1171, 1);
        countingStream->write((uint64_t*)&cgen_var_1171, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        uint64_t cgen_var_1172;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1172, 1);
        countingStream->write((uint64_t*)&cgen_var_1172, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirectCountKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirectCountKHR = OP_vkCmdDrawIndirectCountKHR;
    stream->write(&opcode_vkCmdDrawIndirectCountKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirectCountKHR, sizeof(uint32_t));
    uint64_t cgen_var_1173;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1173, 1);
    stream->write((uint64_t*)&cgen_var_1173, 1 * 8);
    uint64_t cgen_var_1174;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1174, 1);
    stream->write((uint64_t*)&cgen_var_1174, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    uint64_t cgen_var_1175;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1175, 1);
    stream->write((uint64_t*)&cgen_var_1175, 1 * 8);
    stream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCountKHR readParams");
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCountKHR returnUnmarshal");
    mImpl->log("finish vkCmdDrawIndirectCountKHR");;
}

void VkEncoder::vkCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCountKHR encode");
    mImpl->log("start vkCmdDrawIndexedIndirectCountKHR");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_1176;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1176, 1);
        countingStream->write((uint64_t*)&cgen_var_1176, 1 * 8);
        uint64_t cgen_var_1177;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1177, 1);
        countingStream->write((uint64_t*)&cgen_var_1177, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        uint64_t cgen_var_1178;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1178, 1);
        countingStream->write((uint64_t*)&cgen_var_1178, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirectCountKHR = OP_vkCmdDrawIndexedIndirectCountKHR;
    stream->write(&opcode_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t));
    uint64_t cgen_var_1179;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1179, 1);
    stream->write((uint64_t*)&cgen_var_1179, 1 * 8);
    uint64_t cgen_var_1180;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1180, 1);
    stream->write((uint64_t*)&cgen_var_1180, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    uint64_t cgen_var_1181;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1181, 1);
    stream->write((uint64_t*)&cgen_var_1181, 1 * 8);
    stream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCountKHR readParams");
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCountKHR returnUnmarshal");
    mImpl->log("finish vkCmdDrawIndexedIndirectCountKHR");;
}

#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_ANDROID_native_buffer
VkResult VkEncoder::vkGetSwapchainGrallocUsageANDROID(
    VkDevice device,
    VkFormat format,
    VkImageUsageFlags imageUsage,
    int* grallocUsage)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsageANDROID encode");
    mImpl->log("start vkGetSwapchainGrallocUsageANDROID");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFormat local_format;
    VkImageUsageFlags local_imageUsage;
    local_device = device;
    local_format = format;
    local_imageUsage = imageUsage;
    countingStream->rewind();
    {
        uint64_t cgen_var_1182;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1182, 1);
        countingStream->write((uint64_t*)&cgen_var_1182, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        countingStream->write((VkImageUsageFlags*)&local_imageUsage, sizeof(VkImageUsageFlags));
        countingStream->write((int*)grallocUsage, sizeof(int));
    }
    uint32_t packetSize_vkGetSwapchainGrallocUsageANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainGrallocUsageANDROID = OP_vkGetSwapchainGrallocUsageANDROID;
    stream->write(&opcode_vkGetSwapchainGrallocUsageANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainGrallocUsageANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1183;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1183, 1);
    stream->write((uint64_t*)&cgen_var_1183, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    stream->write((VkImageUsageFlags*)&local_imageUsage, sizeof(VkImageUsageFlags));
    stream->write((int*)grallocUsage, sizeof(int));
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsageANDROID readParams");
    stream->read((int*)grallocUsage, sizeof(int));
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsageANDROID returnUnmarshal");
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetSwapchainGrallocUsageANDROID");;
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}

VkResult VkEncoder::vkAcquireImageANDROID(
    VkDevice device,
    VkImage image,
    int nativeFenceFd,
    VkSemaphore semaphore,
    VkFence fence)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkAcquireImageANDROID encode");
    mImpl->log("start vkAcquireImageANDROID");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    int local_nativeFenceFd;
    VkSemaphore local_semaphore;
    VkFence local_fence;
    local_device = device;
    local_image = image;
    local_nativeFenceFd = nativeFenceFd;
    local_semaphore = semaphore;
    local_fence = fence;
    mImpl->resources()->unwrap_vkAcquireImageANDROID_nativeFenceFd(nativeFenceFd, &local_nativeFenceFd);
    countingStream->rewind();
    {
        uint64_t cgen_var_1184;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1184, 1);
        countingStream->write((uint64_t*)&cgen_var_1184, 1 * 8);
        uint64_t cgen_var_1185;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1185, 1);
        countingStream->write((uint64_t*)&cgen_var_1185, 1 * 8);
        countingStream->write((int*)&local_nativeFenceFd, sizeof(int));
        uint64_t cgen_var_1186;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_1186, 1);
        countingStream->write((uint64_t*)&cgen_var_1186, 1 * 8);
        uint64_t cgen_var_1187;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_1187, 1);
        countingStream->write((uint64_t*)&cgen_var_1187, 1 * 8);
    }
    uint32_t packetSize_vkAcquireImageANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireImageANDROID = OP_vkAcquireImageANDROID;
    stream->write(&opcode_vkAcquireImageANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireImageANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1188;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1188, 1);
    stream->write((uint64_t*)&cgen_var_1188, 1 * 8);
    uint64_t cgen_var_1189;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1189, 1);
    stream->write((uint64_t*)&cgen_var_1189, 1 * 8);
    stream->write((int*)&local_nativeFenceFd, sizeof(int));
    uint64_t cgen_var_1190;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_1190, 1);
    stream->write((uint64_t*)&cgen_var_1190, 1 * 8);
    uint64_t cgen_var_1191;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_1191, 1);
    stream->write((uint64_t*)&cgen_var_1191, 1 * 8);
    AEMU_SCOPED_TRACE("vkAcquireImageANDROID readParams");
    AEMU_SCOPED_TRACE("vkAcquireImageANDROID returnUnmarshal");
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkAcquireImageANDROID");;
    return vkAcquireImageANDROID_VkResult_return;
}

VkResult VkEncoder::vkQueueSignalReleaseImageANDROID(
    VkQueue queue,
    uint32_t waitSemaphoreCount,
    const VkSemaphore* pWaitSemaphores,
    VkImage image,
    int* pNativeFenceFd)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkQueueSignalReleaseImageANDROID encode");
    mImpl->log("start vkQueueSignalReleaseImageANDROID");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    uint32_t local_waitSemaphoreCount;
    VkSemaphore* local_pWaitSemaphores;
    VkImage local_image;
    local_queue = queue;
    local_waitSemaphoreCount = waitSemaphoreCount;
    local_pWaitSemaphores = nullptr;
    if (pWaitSemaphores)
    {
        local_pWaitSemaphores = (VkSemaphore*)pool->dupArray(pWaitSemaphores, ((waitSemaphoreCount)) * sizeof(const VkSemaphore));
    }
    local_image = image;
    countingStream->rewind();
    {
        uint64_t cgen_var_1192;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1192, 1);
        countingStream->write((uint64_t*)&cgen_var_1192, 1 * 8);
        countingStream->write((uint32_t*)&local_waitSemaphoreCount, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_1193 = (uint64_t)(uintptr_t)local_pWaitSemaphores;
        countingStream->putBe64(cgen_var_1193);
        if (local_pWaitSemaphores)
        {
            if (((waitSemaphoreCount)))
            {
                uint64_t* cgen_var_1194;
                countingStream->alloc((void**)&cgen_var_1194, ((waitSemaphoreCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkSemaphore_u64(local_pWaitSemaphores, cgen_var_1194, ((waitSemaphoreCount)));
                countingStream->write((uint64_t*)cgen_var_1194, ((waitSemaphoreCount)) * 8);
            }
        }
        uint64_t cgen_var_1195;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1195, 1);
        countingStream->write((uint64_t*)&cgen_var_1195, 1 * 8);
        countingStream->write((int*)pNativeFenceFd, sizeof(int));
    }
    uint32_t packetSize_vkQueueSignalReleaseImageANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueSignalReleaseImageANDROID = OP_vkQueueSignalReleaseImageANDROID;
    stream->write(&opcode_vkQueueSignalReleaseImageANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueSignalReleaseImageANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1196;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1196, 1);
    stream->write((uint64_t*)&cgen_var_1196, 1 * 8);
    stream->write((uint32_t*)&local_waitSemaphoreCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1197 = (uint64_t)(uintptr_t)local_pWaitSemaphores;
    stream->putBe64(cgen_var_1197);
    if (local_pWaitSemaphores)
    {
        if (((waitSemaphoreCount)))
        {
            uint64_t* cgen_var_1198;
            stream->alloc((void**)&cgen_var_1198, ((waitSemaphoreCount)) * 8);
            stream->handleMapping()->mapHandles_VkSemaphore_u64(local_pWaitSemaphores, cgen_var_1198, ((waitSemaphoreCount)));
            stream->write((uint64_t*)cgen_var_1198, ((waitSemaphoreCount)) * 8);
        }
    }
    uint64_t cgen_var_1199;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1199, 1);
    stream->write((uint64_t*)&cgen_var_1199, 1 * 8);
    stream->write((int*)pNativeFenceFd, sizeof(int));
    AEMU_SCOPED_TRACE("vkQueueSignalReleaseImageANDROID readParams");
    stream->read((int*)pNativeFenceFd, sizeof(int));
    AEMU_SCOPED_TRACE("vkQueueSignalReleaseImageANDROID returnUnmarshal");
    VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkQueueSignalReleaseImageANDROID");;
    return vkQueueSignalReleaseImageANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_debug_report
VkResult VkEncoder::vkCreateDebugReportCallbackEXT(
    VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDebugReportCallbackEXT encode");
    mImpl->log("start vkCreateDebugReportCallbackEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugReportCallbackCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDebugReportCallbackCreateInfoEXT*)pool->alloc(sizeof(const VkDebugReportCallbackCreateInfoEXT));
        deepcopy_VkDebugReportCallbackCreateInfoEXT(pool, pCreateInfo, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDebugReportCallbackCreateInfoEXT(mImpl->resources(), (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1200;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1200, 1);
        countingStream->write((uint64_t*)&cgen_var_1200, 1 * 8);
        marshal_VkDebugReportCallbackCreateInfoEXT(countingStream, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1201 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1201);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1202;
        countingStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(pCallback, &cgen_var_1202, 1);
        countingStream->write((uint64_t*)&cgen_var_1202, 8);
    }
    uint32_t packetSize_vkCreateDebugReportCallbackEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDebugReportCallbackEXT = OP_vkCreateDebugReportCallbackEXT;
    stream->write(&opcode_vkCreateDebugReportCallbackEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDebugReportCallbackEXT, sizeof(uint32_t));
    uint64_t cgen_var_1203;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1203, 1);
    stream->write((uint64_t*)&cgen_var_1203, 1 * 8);
    marshal_VkDebugReportCallbackCreateInfoEXT(stream, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1204 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1204);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1205;
    stream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(pCallback, &cgen_var_1205, 1);
    stream->write((uint64_t*)&cgen_var_1205, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDebugReportCallbackEXT readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1206;
    stream->read((uint64_t*)&cgen_var_1206, 8);
    stream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_1206, (VkDebugReportCallbackEXT*)pCallback, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateDebugReportCallbackEXT returnUnmarshal");
    VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateDebugReportCallbackEXT");;
    return vkCreateDebugReportCallbackEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugReportCallbackEXT(
    VkInstance instance,
    VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyDebugReportCallbackEXT encode");
    mImpl->log("start vkDestroyDebugReportCallbackEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugReportCallbackEXT local_callback;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_callback = callback;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1207;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1207, 1);
        countingStream->write((uint64_t*)&cgen_var_1207, 1 * 8);
        uint64_t cgen_var_1208;
        countingStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(&local_callback, &cgen_var_1208, 1);
        countingStream->write((uint64_t*)&cgen_var_1208, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1209 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1209);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDebugReportCallbackEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDebugReportCallbackEXT = OP_vkDestroyDebugReportCallbackEXT;
    stream->write(&opcode_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t));
    uint64_t cgen_var_1210;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1210, 1);
    stream->write((uint64_t*)&cgen_var_1210, 1 * 8);
    uint64_t cgen_var_1211;
    stream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(&local_callback, &cgen_var_1211, 1);
    stream->write((uint64_t*)&cgen_var_1211, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1212 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1212);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyDebugReportCallbackEXT readParams");
    AEMU_SCOPED_TRACE("vkDestroyDebugReportCallbackEXT returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkDebugReportCallbackEXT((VkDebugReportCallbackEXT*)&callback);
    mImpl->log("finish vkDestroyDebugReportCallbackEXT");;
}

void VkEncoder::vkDebugReportMessageEXT(
    VkInstance instance,
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDebugReportMessageEXT encode");
    mImpl->log("start vkDebugReportMessageEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugReportFlagsEXT local_flags;
    VkDebugReportObjectTypeEXT local_objectType;
    uint64_t local_object;
    size_t local_location;
    int32_t local_messageCode;
    char* local_pLayerPrefix;
    char* local_pMessage;
    local_instance = instance;
    local_flags = flags;
    local_objectType = objectType;
    local_object = object;
    local_location = location;
    local_messageCode = messageCode;
    local_pLayerPrefix = nullptr;
    if (pLayerPrefix)
    {
        local_pLayerPrefix = pool->strDup(pLayerPrefix);
    }
    local_pMessage = nullptr;
    if (pMessage)
    {
        local_pMessage = pool->strDup(pMessage);
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1213;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1213, 1);
        countingStream->write((uint64_t*)&cgen_var_1213, 1 * 8);
        countingStream->write((VkDebugReportFlagsEXT*)&local_flags, sizeof(VkDebugReportFlagsEXT));
        countingStream->write((VkDebugReportObjectTypeEXT*)&local_objectType, sizeof(VkDebugReportObjectTypeEXT));
        countingStream->write((uint64_t*)&local_object, sizeof(uint64_t));
        uint64_t cgen_var_1214 = (uint64_t)local_location;
        countingStream->putBe64(cgen_var_1214);
        countingStream->write((int32_t*)&local_messageCode, sizeof(int32_t));
        countingStream->putString(local_pLayerPrefix);
        countingStream->putString(local_pMessage);
    }
    uint32_t packetSize_vkDebugReportMessageEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugReportMessageEXT = OP_vkDebugReportMessageEXT;
    stream->write(&opcode_vkDebugReportMessageEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugReportMessageEXT, sizeof(uint32_t));
    uint64_t cgen_var_1215;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1215, 1);
    stream->write((uint64_t*)&cgen_var_1215, 1 * 8);
    stream->write((VkDebugReportFlagsEXT*)&local_flags, sizeof(VkDebugReportFlagsEXT));
    stream->write((VkDebugReportObjectTypeEXT*)&local_objectType, sizeof(VkDebugReportObjectTypeEXT));
    stream->write((uint64_t*)&local_object, sizeof(uint64_t));
    uint64_t cgen_var_1216 = (uint64_t)local_location;
    stream->putBe64(cgen_var_1216);
    stream->write((int32_t*)&local_messageCode, sizeof(int32_t));
    stream->putString(local_pLayerPrefix);
    stream->putString(local_pMessage);
    AEMU_SCOPED_TRACE("vkDebugReportMessageEXT readParams");
    AEMU_SCOPED_TRACE("vkDebugReportMessageEXT returnUnmarshal");
    mImpl->log("finish vkDebugReportMessageEXT");;
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
VkResult VkEncoder::vkDebugMarkerSetObjectTagEXT(
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectTagEXT encode");
    mImpl->log("start vkDebugMarkerSetObjectTagEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDebugMarkerObjectTagInfoEXT* local_pTagInfo;
    local_device = device;
    local_pTagInfo = nullptr;
    if (pTagInfo)
    {
        local_pTagInfo = (VkDebugMarkerObjectTagInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerObjectTagInfoEXT));
        deepcopy_VkDebugMarkerObjectTagInfoEXT(pool, pTagInfo, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    if (local_pTagInfo)
    {
        transform_tohost_VkDebugMarkerObjectTagInfoEXT(mImpl->resources(), (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1217;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1217, 1);
        countingStream->write((uint64_t*)&cgen_var_1217, 1 * 8);
        marshal_VkDebugMarkerObjectTagInfoEXT(countingStream, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    uint32_t packetSize_vkDebugMarkerSetObjectTagEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugMarkerSetObjectTagEXT = OP_vkDebugMarkerSetObjectTagEXT;
    stream->write(&opcode_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t));
    uint64_t cgen_var_1218;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1218, 1);
    stream->write((uint64_t*)&cgen_var_1218, 1 * 8);
    marshal_VkDebugMarkerObjectTagInfoEXT(stream, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectTagEXT readParams");
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectTagEXT returnUnmarshal");
    VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkDebugMarkerSetObjectTagEXT");;
    return vkDebugMarkerSetObjectTagEXT_VkResult_return;
}

VkResult VkEncoder::vkDebugMarkerSetObjectNameEXT(
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectNameEXT encode");
    mImpl->log("start vkDebugMarkerSetObjectNameEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDebugMarkerObjectNameInfoEXT* local_pNameInfo;
    local_device = device;
    local_pNameInfo = nullptr;
    if (pNameInfo)
    {
        local_pNameInfo = (VkDebugMarkerObjectNameInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerObjectNameInfoEXT));
        deepcopy_VkDebugMarkerObjectNameInfoEXT(pool, pNameInfo, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    if (local_pNameInfo)
    {
        transform_tohost_VkDebugMarkerObjectNameInfoEXT(mImpl->resources(), (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1219;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1219, 1);
        countingStream->write((uint64_t*)&cgen_var_1219, 1 * 8);
        marshal_VkDebugMarkerObjectNameInfoEXT(countingStream, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    uint32_t packetSize_vkDebugMarkerSetObjectNameEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugMarkerSetObjectNameEXT = OP_vkDebugMarkerSetObjectNameEXT;
    stream->write(&opcode_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t));
    uint64_t cgen_var_1220;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1220, 1);
    stream->write((uint64_t*)&cgen_var_1220, 1 * 8);
    marshal_VkDebugMarkerObjectNameInfoEXT(stream, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectNameEXT readParams");
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectNameEXT returnUnmarshal");
    VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkDebugMarkerSetObjectNameEXT");;
    return vkDebugMarkerSetObjectNameEXT_VkResult_return;
}

void VkEncoder::vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerBeginEXT encode");
    mImpl->log("start vkCmdDebugMarkerBeginEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDebugMarkerMarkerInfoEXT* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkDebugMarkerMarkerInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerMarkerInfoEXT));
        deepcopy_VkDebugMarkerMarkerInfoEXT(pool, pMarkerInfo, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkDebugMarkerMarkerInfoEXT(mImpl->resources(), (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1221;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1221, 1);
        countingStream->write((uint64_t*)&cgen_var_1221, 1 * 8);
        marshal_VkDebugMarkerMarkerInfoEXT(countingStream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    uint32_t packetSize_vkCmdDebugMarkerBeginEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerBeginEXT = OP_vkCmdDebugMarkerBeginEXT;
    stream->write(&opcode_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t));
    uint64_t cgen_var_1222;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1222, 1);
    stream->write((uint64_t*)&cgen_var_1222, 1 * 8);
    marshal_VkDebugMarkerMarkerInfoEXT(stream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerBeginEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerBeginEXT returnUnmarshal");
    mImpl->log("finish vkCmdDebugMarkerBeginEXT");;
}

void VkEncoder::vkCmdDebugMarkerEndEXT(
    VkCommandBuffer commandBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerEndEXT encode");
    mImpl->log("start vkCmdDebugMarkerEndEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1223;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1223, 1);
        countingStream->write((uint64_t*)&cgen_var_1223, 1 * 8);
    }
    uint32_t packetSize_vkCmdDebugMarkerEndEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerEndEXT = OP_vkCmdDebugMarkerEndEXT;
    stream->write(&opcode_vkCmdDebugMarkerEndEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerEndEXT, sizeof(uint32_t));
    uint64_t cgen_var_1224;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1224, 1);
    stream->write((uint64_t*)&cgen_var_1224, 1 * 8);
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerEndEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerEndEXT returnUnmarshal");
    mImpl->log("finish vkCmdDebugMarkerEndEXT");;
}

void VkEncoder::vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerInsertEXT encode");
    mImpl->log("start vkCmdDebugMarkerInsertEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDebugMarkerMarkerInfoEXT* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkDebugMarkerMarkerInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerMarkerInfoEXT));
        deepcopy_VkDebugMarkerMarkerInfoEXT(pool, pMarkerInfo, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkDebugMarkerMarkerInfoEXT(mImpl->resources(), (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1225;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1225, 1);
        countingStream->write((uint64_t*)&cgen_var_1225, 1 * 8);
        marshal_VkDebugMarkerMarkerInfoEXT(countingStream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    uint32_t packetSize_vkCmdDebugMarkerInsertEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerInsertEXT = OP_vkCmdDebugMarkerInsertEXT;
    stream->write(&opcode_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t));
    uint64_t cgen_var_1226;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1226, 1);
    stream->write((uint64_t*)&cgen_var_1226, 1 * 8);
    marshal_VkDebugMarkerMarkerInfoEXT(stream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerInsertEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerInsertEXT returnUnmarshal");
    mImpl->log("finish vkCmdDebugMarkerInsertEXT");;
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCountAMD encode");
    mImpl->log("start vkCmdDrawIndirectCountAMD");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_1227;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1227, 1);
        countingStream->write((uint64_t*)&cgen_var_1227, 1 * 8);
        uint64_t cgen_var_1228;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1228, 1);
        countingStream->write((uint64_t*)&cgen_var_1228, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        uint64_t cgen_var_1229;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1229, 1);
        countingStream->write((uint64_t*)&cgen_var_1229, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirectCountAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirectCountAMD = OP_vkCmdDrawIndirectCountAMD;
    stream->write(&opcode_vkCmdDrawIndirectCountAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirectCountAMD, sizeof(uint32_t));
    uint64_t cgen_var_1230;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1230, 1);
    stream->write((uint64_t*)&cgen_var_1230, 1 * 8);
    uint64_t cgen_var_1231;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1231, 1);
    stream->write((uint64_t*)&cgen_var_1231, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    uint64_t cgen_var_1232;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1232, 1);
    stream->write((uint64_t*)&cgen_var_1232, 1 * 8);
    stream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCountAMD readParams");
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCountAMD returnUnmarshal");
    mImpl->log("finish vkCmdDrawIndirectCountAMD");;
}

void VkEncoder::vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCountAMD encode");
    mImpl->log("start vkCmdDrawIndexedIndirectCountAMD");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_1233;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1233, 1);
        countingStream->write((uint64_t*)&cgen_var_1233, 1 * 8);
        uint64_t cgen_var_1234;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1234, 1);
        countingStream->write((uint64_t*)&cgen_var_1234, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        uint64_t cgen_var_1235;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1235, 1);
        countingStream->write((uint64_t*)&cgen_var_1235, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirectCountAMD = OP_vkCmdDrawIndexedIndirectCountAMD;
    stream->write(&opcode_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t));
    uint64_t cgen_var_1236;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1236, 1);
    stream->write((uint64_t*)&cgen_var_1236, 1 * 8);
    uint64_t cgen_var_1237;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1237, 1);
    stream->write((uint64_t*)&cgen_var_1237, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    uint64_t cgen_var_1238;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1238, 1);
    stream->write((uint64_t*)&cgen_var_1238, 1 * 8);
    stream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCountAMD readParams");
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCountAMD returnUnmarshal");
    mImpl->log("finish vkCmdDrawIndexedIndirectCountAMD");;
}

#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
VkResult VkEncoder::vkGetShaderInfoAMD(
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetShaderInfoAMD encode");
    mImpl->log("start vkGetShaderInfoAMD");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipeline local_pipeline;
    VkShaderStageFlagBits local_shaderStage;
    VkShaderInfoTypeAMD local_infoType;
    local_device = device;
    local_pipeline = pipeline;
    local_shaderStage = shaderStage;
    local_infoType = infoType;
    countingStream->rewind();
    {
        uint64_t cgen_var_1239;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1239, 1);
        countingStream->write((uint64_t*)&cgen_var_1239, 1 * 8);
        uint64_t cgen_var_1240;
        countingStream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_1240, 1);
        countingStream->write((uint64_t*)&cgen_var_1240, 1 * 8);
        countingStream->write((VkShaderStageFlagBits*)&local_shaderStage, sizeof(VkShaderStageFlagBits));
        countingStream->write((VkShaderInfoTypeAMD*)&local_infoType, sizeof(VkShaderInfoTypeAMD));
        // WARNING PTR CHECK
        uint64_t cgen_var_1241 = (uint64_t)(uintptr_t)pInfoSize;
        countingStream->putBe64(cgen_var_1241);
        if (pInfoSize)
        {
            uint64_t cgen_var_1242 = (uint64_t)(*pInfoSize);
            countingStream->putBe64(cgen_var_1242);
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1243 = (uint64_t)(uintptr_t)pInfo;
        countingStream->putBe64(cgen_var_1243);
        if (pInfo)
        {
            countingStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetShaderInfoAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetShaderInfoAMD = OP_vkGetShaderInfoAMD;
    stream->write(&opcode_vkGetShaderInfoAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkGetShaderInfoAMD, sizeof(uint32_t));
    uint64_t cgen_var_1244;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1244, 1);
    stream->write((uint64_t*)&cgen_var_1244, 1 * 8);
    uint64_t cgen_var_1245;
    stream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_1245, 1);
    stream->write((uint64_t*)&cgen_var_1245, 1 * 8);
    stream->write((VkShaderStageFlagBits*)&local_shaderStage, sizeof(VkShaderStageFlagBits));
    stream->write((VkShaderInfoTypeAMD*)&local_infoType, sizeof(VkShaderInfoTypeAMD));
    // WARNING PTR CHECK
    uint64_t cgen_var_1246 = (uint64_t)(uintptr_t)pInfoSize;
    stream->putBe64(cgen_var_1246);
    if (pInfoSize)
    {
        uint64_t cgen_var_1247 = (uint64_t)(*pInfoSize);
        stream->putBe64(cgen_var_1247);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1248 = (uint64_t)(uintptr_t)pInfo;
    stream->putBe64(cgen_var_1248);
    if (pInfo)
    {
        stream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkGetShaderInfoAMD readParams");
    // WARNING PTR CHECK
    size_t* check_pInfoSize;
    check_pInfoSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pInfoSize)
    {
        if (!(check_pInfoSize))
        {
            fprintf(stderr, "fatal: pInfoSize inconsistent between guest and host\n");
        }
        (*pInfoSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pInfo;
    check_pInfo = (void*)(uintptr_t)stream->getBe64();
    if (pInfo)
    {
        if (!(check_pInfo))
        {
            fprintf(stderr, "fatal: pInfo inconsistent between guest and host\n");
        }
        stream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkGetShaderInfoAMD returnUnmarshal");
    VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
    stream->read(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetShaderInfoAMD");;
    return vkGetShaderInfoAMD_VkResult_return;
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
VkResult VkEncoder::vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalImageFormatPropertiesNV encode");
    mImpl->log("start vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkImageTiling local_tiling;
    VkImageUsageFlags local_usage;
    VkImageCreateFlags local_flags;
    VkExternalMemoryHandleTypeFlagsNV local_externalHandleType;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_tiling = tiling;
    local_usage = usage;
    local_flags = flags;
    local_externalHandleType = externalHandleType;
    countingStream->rewind();
    {
        uint64_t cgen_var_1252;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1252, 1);
        countingStream->write((uint64_t*)&cgen_var_1252, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&local_type, sizeof(VkImageType));
        countingStream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
        countingStream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
        countingStream->write((VkExternalMemoryHandleTypeFlagsNV*)&local_externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
        marshal_VkExternalImageFormatPropertiesNV(countingStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
    stream->write(&opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t));
    uint64_t cgen_var_1253;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1253, 1);
    stream->write((uint64_t*)&cgen_var_1253, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    stream->write((VkImageType*)&local_type, sizeof(VkImageType));
    stream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    stream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
    stream->write((VkExternalMemoryHandleTypeFlagsNV*)&local_externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    marshal_VkExternalImageFormatPropertiesNV(stream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalImageFormatPropertiesNV readParams");
    unmarshal_VkExternalImageFormatPropertiesNV(stream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    if (pExternalImageFormatProperties)
    {
        transform_fromhost_VkExternalImageFormatPropertiesNV(mImpl->resources(), (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalImageFormatPropertiesNV returnUnmarshal");
    VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceExternalImageFormatPropertiesNV");;
    return vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
}

#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleNV(
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleNV encode");
    mImpl->log("start vkGetMemoryWin32HandleNV");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkExternalMemoryHandleTypeFlagsNV local_handleType;
    local_device = device;
    local_memory = memory;
    local_handleType = handleType;
    mImpl->resources()->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_1254;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1254, 1);
        countingStream->write((uint64_t*)&cgen_var_1254, 1 * 8);
        uint64_t cgen_var_1255;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1255, 1);
        countingStream->write((uint64_t*)&cgen_var_1255, 1 * 8);
        countingStream->write((VkExternalMemoryHandleTypeFlagsNV*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetMemoryWin32HandleNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandleNV = OP_vkGetMemoryWin32HandleNV;
    stream->write(&opcode_vkGetMemoryWin32HandleNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandleNV, sizeof(uint32_t));
    uint64_t cgen_var_1256;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1256, 1);
    stream->write((uint64_t*)&cgen_var_1256, 1 * 8);
    uint64_t cgen_var_1257;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1257, 1);
    stream->write((uint64_t*)&cgen_var_1257, 1 * 8);
    stream->write((VkExternalMemoryHandleTypeFlagsNV*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleNV readParams");
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleNV returnUnmarshal");
    VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetMemoryWin32HandleNV");;
    return vkGetMemoryWin32HandleNV_VkResult_return;
}

#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
VkResult VkEncoder::vkCreateViSurfaceNN(
    VkInstance instance,
    const VkViSurfaceCreateInfoNN* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateViSurfaceNN encode");
    mImpl->log("start vkCreateViSurfaceNN");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkViSurfaceCreateInfoNN* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkViSurfaceCreateInfoNN*)pool->alloc(sizeof(const VkViSurfaceCreateInfoNN));
        deepcopy_VkViSurfaceCreateInfoNN(pool, pCreateInfo, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkViSurfaceCreateInfoNN(mImpl->resources(), (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1258;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1258, 1);
        countingStream->write((uint64_t*)&cgen_var_1258, 1 * 8);
        marshal_VkViSurfaceCreateInfoNN(countingStream, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1259 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1259);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1260;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1260, 1);
        countingStream->write((uint64_t*)&cgen_var_1260, 8);
    }
    uint32_t packetSize_vkCreateViSurfaceNN = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateViSurfaceNN = OP_vkCreateViSurfaceNN;
    stream->write(&opcode_vkCreateViSurfaceNN, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateViSurfaceNN, sizeof(uint32_t));
    uint64_t cgen_var_1261;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1261, 1);
    stream->write((uint64_t*)&cgen_var_1261, 1 * 8);
    marshal_VkViSurfaceCreateInfoNN(stream, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1262 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1262);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1263;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1263, 1);
    stream->write((uint64_t*)&cgen_var_1263, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateViSurfaceNN readParams");
    uint64_t cgen_var_1264;
    stream->read((uint64_t*)&cgen_var_1264, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1264, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateViSurfaceNN returnUnmarshal");
    VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
    stream->read(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateViSurfaceNN");;
    return vkCreateViSurfaceNN_VkResult_return;
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void VkEncoder::vkCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBeginConditionalRenderingEXT encode");
    mImpl->log("start vkCmdBeginConditionalRenderingEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkConditionalRenderingBeginInfoEXT* local_pConditionalRenderingBegin;
    local_commandBuffer = commandBuffer;
    local_pConditionalRenderingBegin = nullptr;
    if (pConditionalRenderingBegin)
    {
        local_pConditionalRenderingBegin = (VkConditionalRenderingBeginInfoEXT*)pool->alloc(sizeof(const VkConditionalRenderingBeginInfoEXT));
        deepcopy_VkConditionalRenderingBeginInfoEXT(pool, pConditionalRenderingBegin, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    if (local_pConditionalRenderingBegin)
    {
        transform_tohost_VkConditionalRenderingBeginInfoEXT(mImpl->resources(), (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1265;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1265, 1);
        countingStream->write((uint64_t*)&cgen_var_1265, 1 * 8);
        marshal_VkConditionalRenderingBeginInfoEXT(countingStream, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    uint32_t packetSize_vkCmdBeginConditionalRenderingEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginConditionalRenderingEXT = OP_vkCmdBeginConditionalRenderingEXT;
    stream->write(&opcode_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t));
    uint64_t cgen_var_1266;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1266, 1);
    stream->write((uint64_t*)&cgen_var_1266, 1 * 8);
    marshal_VkConditionalRenderingBeginInfoEXT(stream, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    AEMU_SCOPED_TRACE("vkCmdBeginConditionalRenderingEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdBeginConditionalRenderingEXT returnUnmarshal");
    mImpl->log("finish vkCmdBeginConditionalRenderingEXT");;
}

void VkEncoder::vkCmdEndConditionalRenderingEXT(
    VkCommandBuffer commandBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdEndConditionalRenderingEXT encode");
    mImpl->log("start vkCmdEndConditionalRenderingEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1267;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1267, 1);
        countingStream->write((uint64_t*)&cgen_var_1267, 1 * 8);
    }
    uint32_t packetSize_vkCmdEndConditionalRenderingEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndConditionalRenderingEXT = OP_vkCmdEndConditionalRenderingEXT;
    stream->write(&opcode_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t));
    uint64_t cgen_var_1268;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1268, 1);
    stream->write((uint64_t*)&cgen_var_1268, 1 * 8);
    AEMU_SCOPED_TRACE("vkCmdEndConditionalRenderingEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdEndConditionalRenderingEXT returnUnmarshal");
    mImpl->log("finish vkCmdEndConditionalRenderingEXT");;
}

#endif
#ifdef VK_NVX_device_generated_commands
void VkEncoder::vkCmdProcessCommandsNVX(
    VkCommandBuffer commandBuffer,
    const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdProcessCommandsNVX encode");
    mImpl->log("start vkCmdProcessCommandsNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCmdProcessCommandsInfoNVX* local_pProcessCommandsInfo;
    local_commandBuffer = commandBuffer;
    local_pProcessCommandsInfo = nullptr;
    if (pProcessCommandsInfo)
    {
        local_pProcessCommandsInfo = (VkCmdProcessCommandsInfoNVX*)pool->alloc(sizeof(const VkCmdProcessCommandsInfoNVX));
        deepcopy_VkCmdProcessCommandsInfoNVX(pool, pProcessCommandsInfo, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    }
    if (local_pProcessCommandsInfo)
    {
        transform_tohost_VkCmdProcessCommandsInfoNVX(mImpl->resources(), (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1269;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1269, 1);
        countingStream->write((uint64_t*)&cgen_var_1269, 1 * 8);
        marshal_VkCmdProcessCommandsInfoNVX(countingStream, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    }
    uint32_t packetSize_vkCmdProcessCommandsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdProcessCommandsNVX = OP_vkCmdProcessCommandsNVX;
    stream->write(&opcode_vkCmdProcessCommandsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdProcessCommandsNVX, sizeof(uint32_t));
    uint64_t cgen_var_1270;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1270, 1);
    stream->write((uint64_t*)&cgen_var_1270, 1 * 8);
    marshal_VkCmdProcessCommandsInfoNVX(stream, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    AEMU_SCOPED_TRACE("vkCmdProcessCommandsNVX readParams");
    AEMU_SCOPED_TRACE("vkCmdProcessCommandsNVX returnUnmarshal");
    mImpl->log("finish vkCmdProcessCommandsNVX");;
}

void VkEncoder::vkCmdReserveSpaceForCommandsNVX(
    VkCommandBuffer commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdReserveSpaceForCommandsNVX encode");
    mImpl->log("start vkCmdReserveSpaceForCommandsNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCmdReserveSpaceForCommandsInfoNVX* local_pReserveSpaceInfo;
    local_commandBuffer = commandBuffer;
    local_pReserveSpaceInfo = nullptr;
    if (pReserveSpaceInfo)
    {
        local_pReserveSpaceInfo = (VkCmdReserveSpaceForCommandsInfoNVX*)pool->alloc(sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
        deepcopy_VkCmdReserveSpaceForCommandsInfoNVX(pool, pReserveSpaceInfo, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    }
    if (local_pReserveSpaceInfo)
    {
        transform_tohost_VkCmdReserveSpaceForCommandsInfoNVX(mImpl->resources(), (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1271;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1271, 1);
        countingStream->write((uint64_t*)&cgen_var_1271, 1 * 8);
        marshal_VkCmdReserveSpaceForCommandsInfoNVX(countingStream, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    }
    uint32_t packetSize_vkCmdReserveSpaceForCommandsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdReserveSpaceForCommandsNVX = OP_vkCmdReserveSpaceForCommandsNVX;
    stream->write(&opcode_vkCmdReserveSpaceForCommandsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdReserveSpaceForCommandsNVX, sizeof(uint32_t));
    uint64_t cgen_var_1272;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1272, 1);
    stream->write((uint64_t*)&cgen_var_1272, 1 * 8);
    marshal_VkCmdReserveSpaceForCommandsInfoNVX(stream, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    AEMU_SCOPED_TRACE("vkCmdReserveSpaceForCommandsNVX readParams");
    AEMU_SCOPED_TRACE("vkCmdReserveSpaceForCommandsNVX returnUnmarshal");
    mImpl->log("finish vkCmdReserveSpaceForCommandsNVX");;
}

VkResult VkEncoder::vkCreateIndirectCommandsLayoutNVX(
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateIndirectCommandsLayoutNVX encode");
    mImpl->log("start vkCreateIndirectCommandsLayoutNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkIndirectCommandsLayoutCreateInfoNVX* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkIndirectCommandsLayoutCreateInfoNVX*)pool->alloc(sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
        deepcopy_VkIndirectCommandsLayoutCreateInfoNVX(pool, pCreateInfo, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkIndirectCommandsLayoutCreateInfoNVX(mImpl->resources(), (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1273;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1273, 1);
        countingStream->write((uint64_t*)&cgen_var_1273, 1 * 8);
        marshal_VkIndirectCommandsLayoutCreateInfoNVX(countingStream, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1274 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1274);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1275;
        countingStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(pIndirectCommandsLayout, &cgen_var_1275, 1);
        countingStream->write((uint64_t*)&cgen_var_1275, 8);
    }
    uint32_t packetSize_vkCreateIndirectCommandsLayoutNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateIndirectCommandsLayoutNVX = OP_vkCreateIndirectCommandsLayoutNVX;
    stream->write(&opcode_vkCreateIndirectCommandsLayoutNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateIndirectCommandsLayoutNVX, sizeof(uint32_t));
    uint64_t cgen_var_1276;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1276, 1);
    stream->write((uint64_t*)&cgen_var_1276, 1 * 8);
    marshal_VkIndirectCommandsLayoutCreateInfoNVX(stream, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1277 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1277);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1278;
    stream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(pIndirectCommandsLayout, &cgen_var_1278, 1);
    stream->write((uint64_t*)&cgen_var_1278, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateIndirectCommandsLayoutNVX readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1279;
    stream->read((uint64_t*)&cgen_var_1279, 8);
    stream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_1279, (VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateIndirectCommandsLayoutNVX returnUnmarshal");
    VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateIndirectCommandsLayoutNVX");;
    return vkCreateIndirectCommandsLayoutNVX_VkResult_return;
}

void VkEncoder::vkDestroyIndirectCommandsLayoutNVX(
    VkDevice device,
    VkIndirectCommandsLayoutNVX indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyIndirectCommandsLayoutNVX encode");
    mImpl->log("start vkDestroyIndirectCommandsLayoutNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkIndirectCommandsLayoutNVX local_indirectCommandsLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_indirectCommandsLayout = indirectCommandsLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1280;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1280, 1);
        countingStream->write((uint64_t*)&cgen_var_1280, 1 * 8);
        uint64_t cgen_var_1281;
        countingStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(&local_indirectCommandsLayout, &cgen_var_1281, 1);
        countingStream->write((uint64_t*)&cgen_var_1281, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1282 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1282);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyIndirectCommandsLayoutNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyIndirectCommandsLayoutNVX = OP_vkDestroyIndirectCommandsLayoutNVX;
    stream->write(&opcode_vkDestroyIndirectCommandsLayoutNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyIndirectCommandsLayoutNVX, sizeof(uint32_t));
    uint64_t cgen_var_1283;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1283, 1);
    stream->write((uint64_t*)&cgen_var_1283, 1 * 8);
    uint64_t cgen_var_1284;
    stream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(&local_indirectCommandsLayout, &cgen_var_1284, 1);
    stream->write((uint64_t*)&cgen_var_1284, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1285 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1285);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyIndirectCommandsLayoutNVX readParams");
    AEMU_SCOPED_TRACE("vkDestroyIndirectCommandsLayoutNVX returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkIndirectCommandsLayoutNVX((VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout);
    mImpl->log("finish vkDestroyIndirectCommandsLayoutNVX");;
}

VkResult VkEncoder::vkCreateObjectTableNVX(
    VkDevice device,
    const VkObjectTableCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkObjectTableNVX* pObjectTable)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateObjectTableNVX encode");
    mImpl->log("start vkCreateObjectTableNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkObjectTableCreateInfoNVX* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkObjectTableCreateInfoNVX*)pool->alloc(sizeof(const VkObjectTableCreateInfoNVX));
        deepcopy_VkObjectTableCreateInfoNVX(pool, pCreateInfo, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkObjectTableCreateInfoNVX(mImpl->resources(), (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1286;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1286, 1);
        countingStream->write((uint64_t*)&cgen_var_1286, 1 * 8);
        marshal_VkObjectTableCreateInfoNVX(countingStream, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1287 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1287);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1288;
        countingStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(pObjectTable, &cgen_var_1288, 1);
        countingStream->write((uint64_t*)&cgen_var_1288, 8);
    }
    uint32_t packetSize_vkCreateObjectTableNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateObjectTableNVX = OP_vkCreateObjectTableNVX;
    stream->write(&opcode_vkCreateObjectTableNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateObjectTableNVX, sizeof(uint32_t));
    uint64_t cgen_var_1289;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1289, 1);
    stream->write((uint64_t*)&cgen_var_1289, 1 * 8);
    marshal_VkObjectTableCreateInfoNVX(stream, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1290 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1290);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1291;
    stream->handleMapping()->mapHandles_VkObjectTableNVX_u64(pObjectTable, &cgen_var_1291, 1);
    stream->write((uint64_t*)&cgen_var_1291, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateObjectTableNVX readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1292;
    stream->read((uint64_t*)&cgen_var_1292, 8);
    stream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_1292, (VkObjectTableNVX*)pObjectTable, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateObjectTableNVX returnUnmarshal");
    VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
    stream->read(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateObjectTableNVX");;
    return vkCreateObjectTableNVX_VkResult_return;
}

void VkEncoder::vkDestroyObjectTableNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyObjectTableNVX encode");
    mImpl->log("start vkDestroyObjectTableNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_objectTable = objectTable;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1293;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1293, 1);
        countingStream->write((uint64_t*)&cgen_var_1293, 1 * 8);
        uint64_t cgen_var_1294;
        countingStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1294, 1);
        countingStream->write((uint64_t*)&cgen_var_1294, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1295 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1295);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyObjectTableNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyObjectTableNVX = OP_vkDestroyObjectTableNVX;
    stream->write(&opcode_vkDestroyObjectTableNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyObjectTableNVX, sizeof(uint32_t));
    uint64_t cgen_var_1296;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1296, 1);
    stream->write((uint64_t*)&cgen_var_1296, 1 * 8);
    uint64_t cgen_var_1297;
    stream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1297, 1);
    stream->write((uint64_t*)&cgen_var_1297, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1298 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1298);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyObjectTableNVX readParams");
    AEMU_SCOPED_TRACE("vkDestroyObjectTableNVX returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkObjectTableNVX((VkObjectTableNVX*)&objectTable);
    mImpl->log("finish vkDestroyObjectTableNVX");;
}

VkResult VkEncoder::vkRegisterObjectsNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectTableEntryNVX* const* ppObjectTableEntries,
    const uint32_t* pObjectIndices)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkRegisterObjectsNVX encode");
    mImpl->log("start vkRegisterObjectsNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    uint32_t local_objectCount;
    VkObjectTableEntryNVX** local_ppObjectTableEntries;
    uint32_t* local_pObjectIndices;
    local_device = device;
    local_objectTable = objectTable;
    local_objectCount = objectCount;
    (void)ppObjectTableEntries;
    local_pObjectIndices = nullptr;
    if (pObjectIndices)
    {
        local_pObjectIndices = (uint32_t*)pool->dupArray(pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    }
    (void)local_ppObjectTableEntries;
    countingStream->rewind();
    {
        uint64_t cgen_var_1299;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1299, 1);
        countingStream->write((uint64_t*)&cgen_var_1299, 1 * 8);
        uint64_t cgen_var_1300;
        countingStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1300, 1);
        countingStream->write((uint64_t*)&cgen_var_1300, 1 * 8);
        countingStream->write((uint32_t*)&local_objectCount, sizeof(uint32_t));
        (void)local_ppObjectTableEntries;
        countingStream->write((uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    }
    uint32_t packetSize_vkRegisterObjectsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterObjectsNVX = OP_vkRegisterObjectsNVX;
    stream->write(&opcode_vkRegisterObjectsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterObjectsNVX, sizeof(uint32_t));
    uint64_t cgen_var_1301;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1301, 1);
    stream->write((uint64_t*)&cgen_var_1301, 1 * 8);
    uint64_t cgen_var_1302;
    stream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1302, 1);
    stream->write((uint64_t*)&cgen_var_1302, 1 * 8);
    stream->write((uint32_t*)&local_objectCount, sizeof(uint32_t));
    (void)local_ppObjectTableEntries;
    stream->write((uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkRegisterObjectsNVX readParams");
    AEMU_SCOPED_TRACE("vkRegisterObjectsNVX returnUnmarshal");
    VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkRegisterObjectsNVX");;
    return vkRegisterObjectsNVX_VkResult_return;
}

VkResult VkEncoder::vkUnregisterObjectsNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectEntryTypeNVX* pObjectEntryTypes,
    const uint32_t* pObjectIndices)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkUnregisterObjectsNVX encode");
    mImpl->log("start vkUnregisterObjectsNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    uint32_t local_objectCount;
    VkObjectEntryTypeNVX* local_pObjectEntryTypes;
    uint32_t* local_pObjectIndices;
    local_device = device;
    local_objectTable = objectTable;
    local_objectCount = objectCount;
    local_pObjectEntryTypes = nullptr;
    if (pObjectEntryTypes)
    {
        local_pObjectEntryTypes = (VkObjectEntryTypeNVX*)pool->dupArray(pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
    }
    local_pObjectIndices = nullptr;
    if (pObjectIndices)
    {
        local_pObjectIndices = (uint32_t*)pool->dupArray(pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1303;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1303, 1);
        countingStream->write((uint64_t*)&cgen_var_1303, 1 * 8);
        uint64_t cgen_var_1304;
        countingStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1304, 1);
        countingStream->write((uint64_t*)&cgen_var_1304, 1 * 8);
        countingStream->write((uint32_t*)&local_objectCount, sizeof(uint32_t));
        countingStream->write((VkObjectEntryTypeNVX*)local_pObjectEntryTypes, ((objectCount)) * sizeof(VkObjectEntryTypeNVX));
        countingStream->write((uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    }
    uint32_t packetSize_vkUnregisterObjectsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUnregisterObjectsNVX = OP_vkUnregisterObjectsNVX;
    stream->write(&opcode_vkUnregisterObjectsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkUnregisterObjectsNVX, sizeof(uint32_t));
    uint64_t cgen_var_1305;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1305, 1);
    stream->write((uint64_t*)&cgen_var_1305, 1 * 8);
    uint64_t cgen_var_1306;
    stream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1306, 1);
    stream->write((uint64_t*)&cgen_var_1306, 1 * 8);
    stream->write((uint32_t*)&local_objectCount, sizeof(uint32_t));
    stream->write((VkObjectEntryTypeNVX*)local_pObjectEntryTypes, ((objectCount)) * sizeof(VkObjectEntryTypeNVX));
    stream->write((uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkUnregisterObjectsNVX readParams");
    AEMU_SCOPED_TRACE("vkUnregisterObjectsNVX returnUnmarshal");
    VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
    stream->read(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkUnregisterObjectsNVX");;
    return vkUnregisterObjectsNVX_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX* pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX* pLimits)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX encode");
    mImpl->log("start vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_1307;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1307, 1);
        countingStream->write((uint64_t*)&cgen_var_1307, 1 * 8);
        marshal_VkDeviceGeneratedCommandsFeaturesNVX(countingStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
        marshal_VkDeviceGeneratedCommandsLimitsNVX(countingStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    }
    uint32_t packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX;
    stream->write(&opcode_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, sizeof(uint32_t));
    uint64_t cgen_var_1308;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1308, 1);
    stream->write((uint64_t*)&cgen_var_1308, 1 * 8);
    marshal_VkDeviceGeneratedCommandsFeaturesNVX(stream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    marshal_VkDeviceGeneratedCommandsLimitsNVX(stream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX readParams");
    unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(stream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkDeviceGeneratedCommandsFeaturesNVX(mImpl->resources(), (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    }
    unmarshal_VkDeviceGeneratedCommandsLimitsNVX(stream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    if (pLimits)
    {
        transform_fromhost_VkDeviceGeneratedCommandsLimitsNVX(mImpl->resources(), (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX");;
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void VkEncoder::vkCmdSetViewportWScalingNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetViewportWScalingNV encode");
    mImpl->log("start vkCmdSetViewportWScalingNV");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkViewportWScalingNV* local_pViewportWScalings;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pViewportWScalings = nullptr;
    if (pViewportWScalings)
    {
        local_pViewportWScalings = (VkViewportWScalingNV*)pool->alloc(((viewportCount)) * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewportWScalingNV(pool, pViewportWScalings + i, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    if (local_pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewportWScalingNV(mImpl->resources(), (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1309;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1309, 1);
        countingStream->write((uint64_t*)&cgen_var_1309, 1 * 8);
        countingStream->write((uint32_t*)&local_firstViewport, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_viewportCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            marshal_VkViewportWScalingNV(countingStream, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    uint32_t packetSize_vkCmdSetViewportWScalingNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetViewportWScalingNV = OP_vkCmdSetViewportWScalingNV;
    stream->write(&opcode_vkCmdSetViewportWScalingNV, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetViewportWScalingNV, sizeof(uint32_t));
    uint64_t cgen_var_1310;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1310, 1);
    stream->write((uint64_t*)&cgen_var_1310, 1 * 8);
    stream->write((uint32_t*)&local_firstViewport, sizeof(uint32_t));
    stream->write((uint32_t*)&local_viewportCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        marshal_VkViewportWScalingNV(stream, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
    }
    AEMU_SCOPED_TRACE("vkCmdSetViewportWScalingNV readParams");
    AEMU_SCOPED_TRACE("vkCmdSetViewportWScalingNV returnUnmarshal");
    mImpl->log("finish vkCmdSetViewportWScalingNV");;
}

#endif
#ifdef VK_EXT_direct_mode_display
VkResult VkEncoder::vkReleaseDisplayEXT(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkReleaseDisplayEXT encode");
    mImpl->log("start vkReleaseDisplayEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    countingStream->rewind();
    {
        uint64_t cgen_var_1311;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1311, 1);
        countingStream->write((uint64_t*)&cgen_var_1311, 1 * 8);
        uint64_t cgen_var_1312;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1312, 1);
        countingStream->write((uint64_t*)&cgen_var_1312, 1 * 8);
    }
    uint32_t packetSize_vkReleaseDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkReleaseDisplayEXT = OP_vkReleaseDisplayEXT;
    stream->write(&opcode_vkReleaseDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkReleaseDisplayEXT, sizeof(uint32_t));
    uint64_t cgen_var_1313;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1313, 1);
    stream->write((uint64_t*)&cgen_var_1313, 1 * 8);
    uint64_t cgen_var_1314;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1314, 1);
    stream->write((uint64_t*)&cgen_var_1314, 1 * 8);
    AEMU_SCOPED_TRACE("vkReleaseDisplayEXT readParams");
    AEMU_SCOPED_TRACE("vkReleaseDisplayEXT returnUnmarshal");
    VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkReleaseDisplayEXT");;
    return vkReleaseDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_acquire_xlib_display
VkResult VkEncoder::vkAcquireXlibDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    VkDisplayKHR display)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkAcquireXlibDisplayEXT encode");
    mImpl->log("start vkAcquireXlibDisplayEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    countingStream->rewind();
    {
        uint64_t cgen_var_1315;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1315, 1);
        countingStream->write((uint64_t*)&cgen_var_1315, 1 * 8);
        countingStream->write((Display*)dpy, sizeof(Display));
        uint64_t cgen_var_1316;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1316, 1);
        countingStream->write((uint64_t*)&cgen_var_1316, 1 * 8);
    }
    uint32_t packetSize_vkAcquireXlibDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireXlibDisplayEXT = OP_vkAcquireXlibDisplayEXT;
    stream->write(&opcode_vkAcquireXlibDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireXlibDisplayEXT, sizeof(uint32_t));
    uint64_t cgen_var_1317;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1317, 1);
    stream->write((uint64_t*)&cgen_var_1317, 1 * 8);
    stream->write((Display*)dpy, sizeof(Display));
    uint64_t cgen_var_1318;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1318, 1);
    stream->write((uint64_t*)&cgen_var_1318, 1 * 8);
    AEMU_SCOPED_TRACE("vkAcquireXlibDisplayEXT readParams");
    stream->read((Display*)dpy, sizeof(Display));
    AEMU_SCOPED_TRACE("vkAcquireXlibDisplayEXT returnUnmarshal");
    VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkAcquireXlibDisplayEXT");;
    return vkAcquireXlibDisplayEXT_VkResult_return;
}

VkResult VkEncoder::vkGetRandROutputDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    RROutput rrOutput,
    VkDisplayKHR* pDisplay)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetRandROutputDisplayEXT encode");
    mImpl->log("start vkGetRandROutputDisplayEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    RROutput local_rrOutput;
    local_physicalDevice = physicalDevice;
    local_rrOutput = rrOutput;
    countingStream->rewind();
    {
        uint64_t cgen_var_1319;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1319, 1);
        countingStream->write((uint64_t*)&cgen_var_1319, 1 * 8);
        countingStream->write((Display*)dpy, sizeof(Display));
        countingStream->write((RROutput*)&local_rrOutput, sizeof(RROutput));
        uint64_t cgen_var_1320;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_1320, 1);
        countingStream->write((uint64_t*)&cgen_var_1320, 8);
    }
    uint32_t packetSize_vkGetRandROutputDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRandROutputDisplayEXT = OP_vkGetRandROutputDisplayEXT;
    stream->write(&opcode_vkGetRandROutputDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRandROutputDisplayEXT, sizeof(uint32_t));
    uint64_t cgen_var_1321;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1321, 1);
    stream->write((uint64_t*)&cgen_var_1321, 1 * 8);
    stream->write((Display*)dpy, sizeof(Display));
    stream->write((RROutput*)&local_rrOutput, sizeof(RROutput));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1322;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_1322, 1);
    stream->write((uint64_t*)&cgen_var_1322, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkGetRandROutputDisplayEXT readParams");
    stream->read((Display*)dpy, sizeof(Display));
    uint64_t cgen_var_1323;
    stream->read((uint64_t*)&cgen_var_1323, 8);
    stream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_1323, (VkDisplayKHR*)pDisplay, 1);
    AEMU_SCOPED_TRACE("vkGetRandROutputDisplayEXT returnUnmarshal");
    VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetRandROutputDisplayEXT");;
    return vkGetRandROutputDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_surface_counter
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilities2EXT encode");
    mImpl->log("start vkGetPhysicalDeviceSurfaceCapabilities2EXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_1324;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1324, 1);
        countingStream->write((uint64_t*)&cgen_var_1324, 1 * 8);
        uint64_t cgen_var_1325;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_1325, 1);
        countingStream->write((uint64_t*)&cgen_var_1325, 1 * 8);
        marshal_VkSurfaceCapabilities2EXT(countingStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT = OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t));
    uint64_t cgen_var_1326;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1326, 1);
    stream->write((uint64_t*)&cgen_var_1326, 1 * 8);
    uint64_t cgen_var_1327;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_1327, 1);
    stream->write((uint64_t*)&cgen_var_1327, 1 * 8);
    marshal_VkSurfaceCapabilities2EXT(stream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilities2EXT readParams");
    unmarshal_VkSurfaceCapabilities2EXT(stream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilities2EXT(mImpl->resources(), (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilities2EXT returnUnmarshal");
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPhysicalDeviceSurfaceCapabilities2EXT");;
    return vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_control
VkResult VkEncoder::vkDisplayPowerControlEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDisplayPowerControlEXT encode");
    mImpl->log("start vkDisplayPowerControlEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDisplayKHR local_display;
    VkDisplayPowerInfoEXT* local_pDisplayPowerInfo;
    local_device = device;
    local_display = display;
    local_pDisplayPowerInfo = nullptr;
    if (pDisplayPowerInfo)
    {
        local_pDisplayPowerInfo = (VkDisplayPowerInfoEXT*)pool->alloc(sizeof(const VkDisplayPowerInfoEXT));
        deepcopy_VkDisplayPowerInfoEXT(pool, pDisplayPowerInfo, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    if (local_pDisplayPowerInfo)
    {
        transform_tohost_VkDisplayPowerInfoEXT(mImpl->resources(), (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1328;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1328, 1);
        countingStream->write((uint64_t*)&cgen_var_1328, 1 * 8);
        uint64_t cgen_var_1329;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1329, 1);
        countingStream->write((uint64_t*)&cgen_var_1329, 1 * 8);
        marshal_VkDisplayPowerInfoEXT(countingStream, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    uint32_t packetSize_vkDisplayPowerControlEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDisplayPowerControlEXT = OP_vkDisplayPowerControlEXT;
    stream->write(&opcode_vkDisplayPowerControlEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDisplayPowerControlEXT, sizeof(uint32_t));
    uint64_t cgen_var_1330;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1330, 1);
    stream->write((uint64_t*)&cgen_var_1330, 1 * 8);
    uint64_t cgen_var_1331;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1331, 1);
    stream->write((uint64_t*)&cgen_var_1331, 1 * 8);
    marshal_VkDisplayPowerInfoEXT(stream, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    AEMU_SCOPED_TRACE("vkDisplayPowerControlEXT readParams");
    AEMU_SCOPED_TRACE("vkDisplayPowerControlEXT returnUnmarshal");
    VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkDisplayPowerControlEXT");;
    return vkDisplayPowerControlEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDeviceEventEXT(
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkRegisterDeviceEventEXT encode");
    mImpl->log("start vkRegisterDeviceEventEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceEventInfoEXT* local_pDeviceEventInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pDeviceEventInfo = nullptr;
    if (pDeviceEventInfo)
    {
        local_pDeviceEventInfo = (VkDeviceEventInfoEXT*)pool->alloc(sizeof(const VkDeviceEventInfoEXT));
        deepcopy_VkDeviceEventInfoEXT(pool, pDeviceEventInfo, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pDeviceEventInfo)
    {
        transform_tohost_VkDeviceEventInfoEXT(mImpl->resources(), (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1332;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1332, 1);
        countingStream->write((uint64_t*)&cgen_var_1332, 1 * 8);
        marshal_VkDeviceEventInfoEXT(countingStream, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1333 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1333);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1334;
        countingStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_1334, 1);
        countingStream->write((uint64_t*)&cgen_var_1334, 8);
    }
    uint32_t packetSize_vkRegisterDeviceEventEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterDeviceEventEXT = OP_vkRegisterDeviceEventEXT;
    stream->write(&opcode_vkRegisterDeviceEventEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterDeviceEventEXT, sizeof(uint32_t));
    uint64_t cgen_var_1335;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1335, 1);
    stream->write((uint64_t*)&cgen_var_1335, 1 * 8);
    marshal_VkDeviceEventInfoEXT(stream, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1336 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1336);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1337;
    stream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_1337, 1);
    stream->write((uint64_t*)&cgen_var_1337, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkRegisterDeviceEventEXT readParams");
    uint64_t cgen_var_1338;
    stream->read((uint64_t*)&cgen_var_1338, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_1338, (VkFence*)pFence, 1);
    AEMU_SCOPED_TRACE("vkRegisterDeviceEventEXT returnUnmarshal");
    VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkRegisterDeviceEventEXT");;
    return vkRegisterDeviceEventEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDisplayEventEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkRegisterDisplayEventEXT encode");
    mImpl->log("start vkRegisterDisplayEventEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDisplayKHR local_display;
    VkDisplayEventInfoEXT* local_pDisplayEventInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_display = display;
    local_pDisplayEventInfo = nullptr;
    if (pDisplayEventInfo)
    {
        local_pDisplayEventInfo = (VkDisplayEventInfoEXT*)pool->alloc(sizeof(const VkDisplayEventInfoEXT));
        deepcopy_VkDisplayEventInfoEXT(pool, pDisplayEventInfo, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pDisplayEventInfo)
    {
        transform_tohost_VkDisplayEventInfoEXT(mImpl->resources(), (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1339;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1339, 1);
        countingStream->write((uint64_t*)&cgen_var_1339, 1 * 8);
        uint64_t cgen_var_1340;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1340, 1);
        countingStream->write((uint64_t*)&cgen_var_1340, 1 * 8);
        marshal_VkDisplayEventInfoEXT(countingStream, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1341 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1341);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1342;
        countingStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_1342, 1);
        countingStream->write((uint64_t*)&cgen_var_1342, 8);
    }
    uint32_t packetSize_vkRegisterDisplayEventEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterDisplayEventEXT = OP_vkRegisterDisplayEventEXT;
    stream->write(&opcode_vkRegisterDisplayEventEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterDisplayEventEXT, sizeof(uint32_t));
    uint64_t cgen_var_1343;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1343, 1);
    stream->write((uint64_t*)&cgen_var_1343, 1 * 8);
    uint64_t cgen_var_1344;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1344, 1);
    stream->write((uint64_t*)&cgen_var_1344, 1 * 8);
    marshal_VkDisplayEventInfoEXT(stream, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1345 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1345);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1346;
    stream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_1346, 1);
    stream->write((uint64_t*)&cgen_var_1346, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkRegisterDisplayEventEXT readParams");
    uint64_t cgen_var_1347;
    stream->read((uint64_t*)&cgen_var_1347, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_1347, (VkFence*)pFence, 1);
    AEMU_SCOPED_TRACE("vkRegisterDisplayEventEXT returnUnmarshal");
    VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkRegisterDisplayEventEXT");;
    return vkRegisterDisplayEventEXT_VkResult_return;
}

VkResult VkEncoder::vkGetSwapchainCounterEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetSwapchainCounterEXT encode");
    mImpl->log("start vkGetSwapchainCounterEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    VkSurfaceCounterFlagBitsEXT local_counter;
    local_device = device;
    local_swapchain = swapchain;
    local_counter = counter;
    countingStream->rewind();
    {
        uint64_t cgen_var_1348;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1348, 1);
        countingStream->write((uint64_t*)&cgen_var_1348, 1 * 8);
        uint64_t cgen_var_1349;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1349, 1);
        countingStream->write((uint64_t*)&cgen_var_1349, 1 * 8);
        countingStream->write((VkSurfaceCounterFlagBitsEXT*)&local_counter, sizeof(VkSurfaceCounterFlagBitsEXT));
        countingStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
    }
    uint32_t packetSize_vkGetSwapchainCounterEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainCounterEXT = OP_vkGetSwapchainCounterEXT;
    stream->write(&opcode_vkGetSwapchainCounterEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainCounterEXT, sizeof(uint32_t));
    uint64_t cgen_var_1350;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1350, 1);
    stream->write((uint64_t*)&cgen_var_1350, 1 * 8);
    uint64_t cgen_var_1351;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1351, 1);
    stream->write((uint64_t*)&cgen_var_1351, 1 * 8);
    stream->write((VkSurfaceCounterFlagBitsEXT*)&local_counter, sizeof(VkSurfaceCounterFlagBitsEXT));
    stream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
    AEMU_SCOPED_TRACE("vkGetSwapchainCounterEXT readParams");
    stream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
    AEMU_SCOPED_TRACE("vkGetSwapchainCounterEXT returnUnmarshal");
    VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetSwapchainCounterEXT");;
    return vkGetSwapchainCounterEXT_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_display_timing
VkResult VkEncoder::vkGetRefreshCycleDurationGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetRefreshCycleDurationGOOGLE encode");
    mImpl->log("start vkGetRefreshCycleDurationGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    countingStream->rewind();
    {
        uint64_t cgen_var_1352;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1352, 1);
        countingStream->write((uint64_t*)&cgen_var_1352, 1 * 8);
        uint64_t cgen_var_1353;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1353, 1);
        countingStream->write((uint64_t*)&cgen_var_1353, 1 * 8);
        marshal_VkRefreshCycleDurationGOOGLE(countingStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    }
    uint32_t packetSize_vkGetRefreshCycleDurationGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRefreshCycleDurationGOOGLE = OP_vkGetRefreshCycleDurationGOOGLE;
    stream->write(&opcode_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1354;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1354, 1);
    stream->write((uint64_t*)&cgen_var_1354, 1 * 8);
    uint64_t cgen_var_1355;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1355, 1);
    stream->write((uint64_t*)&cgen_var_1355, 1 * 8);
    marshal_VkRefreshCycleDurationGOOGLE(stream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    AEMU_SCOPED_TRACE("vkGetRefreshCycleDurationGOOGLE readParams");
    unmarshal_VkRefreshCycleDurationGOOGLE(stream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    if (pDisplayTimingProperties)
    {
        transform_fromhost_VkRefreshCycleDurationGOOGLE(mImpl->resources(), (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    }
    AEMU_SCOPED_TRACE("vkGetRefreshCycleDurationGOOGLE returnUnmarshal");
    VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetRefreshCycleDurationGOOGLE");;
    return vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkGetPastPresentationTimingGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPastPresentationTimingGOOGLE encode");
    mImpl->log("start vkGetPastPresentationTimingGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    countingStream->rewind();
    {
        uint64_t cgen_var_1356;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1356, 1);
        countingStream->write((uint64_t*)&cgen_var_1356, 1 * 8);
        uint64_t cgen_var_1357;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1357, 1);
        countingStream->write((uint64_t*)&cgen_var_1357, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1358 = (uint64_t)(uintptr_t)pPresentationTimingCount;
        countingStream->putBe64(cgen_var_1358);
        if (pPresentationTimingCount)
        {
            countingStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1359 = (uint64_t)(uintptr_t)pPresentationTimings;
        countingStream->putBe64(cgen_var_1359);
        if (pPresentationTimings)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
            {
                marshal_VkPastPresentationTimingGOOGLE(countingStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
            }
        }
    }
    uint32_t packetSize_vkGetPastPresentationTimingGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPastPresentationTimingGOOGLE = OP_vkGetPastPresentationTimingGOOGLE;
    stream->write(&opcode_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1360;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1360, 1);
    stream->write((uint64_t*)&cgen_var_1360, 1 * 8);
    uint64_t cgen_var_1361;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1361, 1);
    stream->write((uint64_t*)&cgen_var_1361, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1362 = (uint64_t)(uintptr_t)pPresentationTimingCount;
    stream->putBe64(cgen_var_1362);
    if (pPresentationTimingCount)
    {
        stream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1363 = (uint64_t)(uintptr_t)pPresentationTimings;
    stream->putBe64(cgen_var_1363);
    if (pPresentationTimings)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            marshal_VkPastPresentationTimingGOOGLE(stream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPastPresentationTimingGOOGLE readParams");
    // WARNING PTR CHECK
    uint32_t* check_pPresentationTimingCount;
    check_pPresentationTimingCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentationTimingCount)
    {
        if (!(check_pPresentationTimingCount))
        {
            fprintf(stderr, "fatal: pPresentationTimingCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPastPresentationTimingGOOGLE* check_pPresentationTimings;
    check_pPresentationTimings = (VkPastPresentationTimingGOOGLE*)(uintptr_t)stream->getBe64();
    if (pPresentationTimings)
    {
        if (!(check_pPresentationTimings))
        {
            fprintf(stderr, "fatal: pPresentationTimings inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            unmarshal_VkPastPresentationTimingGOOGLE(stream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    if (pPresentationTimings)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            transform_fromhost_VkPastPresentationTimingGOOGLE(mImpl->resources(), (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetPastPresentationTimingGOOGLE returnUnmarshal");
    VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetPastPresentationTimingGOOGLE");;
    return vkGetPastPresentationTimingGOOGLE_VkResult_return;
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
void VkEncoder::vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstDiscardRectangle,
    uint32_t discardRectangleCount,
    const VkRect2D* pDiscardRectangles)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetDiscardRectangleEXT encode");
    mImpl->log("start vkCmdSetDiscardRectangleEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstDiscardRectangle;
    uint32_t local_discardRectangleCount;
    VkRect2D* local_pDiscardRectangles;
    local_commandBuffer = commandBuffer;
    local_firstDiscardRectangle = firstDiscardRectangle;
    local_discardRectangleCount = discardRectangleCount;
    local_pDiscardRectangles = nullptr;
    if (pDiscardRectangles)
    {
        local_pDiscardRectangles = (VkRect2D*)pool->alloc(((discardRectangleCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            deepcopy_VkRect2D(pool, pDiscardRectangles + i, (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    if (local_pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            transform_tohost_VkRect2D(mImpl->resources(), (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1366;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1366, 1);
        countingStream->write((uint64_t*)&cgen_var_1366, 1 * 8);
        countingStream->write((uint32_t*)&local_firstDiscardRectangle, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_discardRectangleCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            marshal_VkRect2D(countingStream, (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    uint32_t packetSize_vkCmdSetDiscardRectangleEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDiscardRectangleEXT = OP_vkCmdSetDiscardRectangleEXT;
    stream->write(&opcode_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t));
    uint64_t cgen_var_1367;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1367, 1);
    stream->write((uint64_t*)&cgen_var_1367, 1 * 8);
    stream->write((uint32_t*)&local_firstDiscardRectangle, sizeof(uint32_t));
    stream->write((uint32_t*)&local_discardRectangleCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
    {
        marshal_VkRect2D(stream, (VkRect2D*)(local_pDiscardRectangles + i));
    }
    AEMU_SCOPED_TRACE("vkCmdSetDiscardRectangleEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdSetDiscardRectangleEXT returnUnmarshal");
    mImpl->log("finish vkCmdSetDiscardRectangleEXT");;
}

#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void VkEncoder::vkSetHdrMetadataEXT(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkSetHdrMetadataEXT encode");
    mImpl->log("start vkSetHdrMetadataEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_swapchainCount;
    VkSwapchainKHR* local_pSwapchains;
    VkHdrMetadataEXT* local_pMetadata;
    local_device = device;
    local_swapchainCount = swapchainCount;
    local_pSwapchains = nullptr;
    if (pSwapchains)
    {
        local_pSwapchains = (VkSwapchainKHR*)pool->dupArray(pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
    }
    local_pMetadata = nullptr;
    if (pMetadata)
    {
        local_pMetadata = (VkHdrMetadataEXT*)pool->alloc(((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            deepcopy_VkHdrMetadataEXT(pool, pMetadata + i, (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    if (local_pMetadata)
    {
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            transform_tohost_VkHdrMetadataEXT(mImpl->resources(), (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1368;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1368, 1);
        countingStream->write((uint64_t*)&cgen_var_1368, 1 * 8);
        countingStream->write((uint32_t*)&local_swapchainCount, sizeof(uint32_t));
        if (((swapchainCount)))
        {
            uint64_t* cgen_var_1369;
            countingStream->alloc((void**)&cgen_var_1369, ((swapchainCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(local_pSwapchains, cgen_var_1369, ((swapchainCount)));
            countingStream->write((uint64_t*)cgen_var_1369, ((swapchainCount)) * 8);
        }
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            marshal_VkHdrMetadataEXT(countingStream, (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    uint32_t packetSize_vkSetHdrMetadataEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetHdrMetadataEXT = OP_vkSetHdrMetadataEXT;
    stream->write(&opcode_vkSetHdrMetadataEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetHdrMetadataEXT, sizeof(uint32_t));
    uint64_t cgen_var_1370;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1370, 1);
    stream->write((uint64_t*)&cgen_var_1370, 1 * 8);
    stream->write((uint32_t*)&local_swapchainCount, sizeof(uint32_t));
    if (((swapchainCount)))
    {
        uint64_t* cgen_var_1371;
        stream->alloc((void**)&cgen_var_1371, ((swapchainCount)) * 8);
        stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(local_pSwapchains, cgen_var_1371, ((swapchainCount)));
        stream->write((uint64_t*)cgen_var_1371, ((swapchainCount)) * 8);
    }
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        marshal_VkHdrMetadataEXT(stream, (VkHdrMetadataEXT*)(local_pMetadata + i));
    }
    AEMU_SCOPED_TRACE("vkSetHdrMetadataEXT readParams");
    AEMU_SCOPED_TRACE("vkSetHdrMetadataEXT returnUnmarshal");
    mImpl->log("finish vkSetHdrMetadataEXT");;
}

#endif
#ifdef VK_MVK_ios_surface
VkResult VkEncoder::vkCreateIOSSurfaceMVK(
    VkInstance instance,
    const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateIOSSurfaceMVK encode");
    mImpl->log("start vkCreateIOSSurfaceMVK");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkIOSSurfaceCreateInfoMVK* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkIOSSurfaceCreateInfoMVK*)pool->alloc(sizeof(const VkIOSSurfaceCreateInfoMVK));
        deepcopy_VkIOSSurfaceCreateInfoMVK(pool, pCreateInfo, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkIOSSurfaceCreateInfoMVK(mImpl->resources(), (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1372;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1372, 1);
        countingStream->write((uint64_t*)&cgen_var_1372, 1 * 8);
        marshal_VkIOSSurfaceCreateInfoMVK(countingStream, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1373 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1373);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1374;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1374, 1);
        countingStream->write((uint64_t*)&cgen_var_1374, 8);
    }
    uint32_t packetSize_vkCreateIOSSurfaceMVK = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateIOSSurfaceMVK = OP_vkCreateIOSSurfaceMVK;
    stream->write(&opcode_vkCreateIOSSurfaceMVK, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateIOSSurfaceMVK, sizeof(uint32_t));
    uint64_t cgen_var_1375;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1375, 1);
    stream->write((uint64_t*)&cgen_var_1375, 1 * 8);
    marshal_VkIOSSurfaceCreateInfoMVK(stream, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1376 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1376);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1377;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1377, 1);
    stream->write((uint64_t*)&cgen_var_1377, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateIOSSurfaceMVK readParams");
    uint64_t cgen_var_1378;
    stream->read((uint64_t*)&cgen_var_1378, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1378, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateIOSSurfaceMVK returnUnmarshal");
    VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateIOSSurfaceMVK");;
    return vkCreateIOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_MVK_macos_surface
VkResult VkEncoder::vkCreateMacOSSurfaceMVK(
    VkInstance instance,
    const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateMacOSSurfaceMVK encode");
    mImpl->log("start vkCreateMacOSSurfaceMVK");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkMacOSSurfaceCreateInfoMVK* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkMacOSSurfaceCreateInfoMVK*)pool->alloc(sizeof(const VkMacOSSurfaceCreateInfoMVK));
        deepcopy_VkMacOSSurfaceCreateInfoMVK(pool, pCreateInfo, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkMacOSSurfaceCreateInfoMVK(mImpl->resources(), (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1379;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1379, 1);
        countingStream->write((uint64_t*)&cgen_var_1379, 1 * 8);
        marshal_VkMacOSSurfaceCreateInfoMVK(countingStream, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1380 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1380);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1381;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1381, 1);
        countingStream->write((uint64_t*)&cgen_var_1381, 8);
    }
    uint32_t packetSize_vkCreateMacOSSurfaceMVK = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateMacOSSurfaceMVK = OP_vkCreateMacOSSurfaceMVK;
    stream->write(&opcode_vkCreateMacOSSurfaceMVK, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateMacOSSurfaceMVK, sizeof(uint32_t));
    uint64_t cgen_var_1382;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1382, 1);
    stream->write((uint64_t*)&cgen_var_1382, 1 * 8);
    marshal_VkMacOSSurfaceCreateInfoMVK(stream, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1383 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1383);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1384;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1384, 1);
    stream->write((uint64_t*)&cgen_var_1384, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateMacOSSurfaceMVK readParams");
    uint64_t cgen_var_1385;
    stream->read((uint64_t*)&cgen_var_1385, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1385, (VkSurfaceKHR*)pSurface, 1);
    AEMU_SCOPED_TRACE("vkCreateMacOSSurfaceMVK returnUnmarshal");
    VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateMacOSSurfaceMVK");;
    return vkCreateMacOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
VkResult VkEncoder::vkSetDebugUtilsObjectNameEXT(
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectNameEXT encode");
    mImpl->log("start vkSetDebugUtilsObjectNameEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDebugUtilsObjectNameInfoEXT* local_pNameInfo;
    local_device = device;
    local_pNameInfo = nullptr;
    if (pNameInfo)
    {
        local_pNameInfo = (VkDebugUtilsObjectNameInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsObjectNameInfoEXT));
        deepcopy_VkDebugUtilsObjectNameInfoEXT(pool, pNameInfo, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    if (local_pNameInfo)
    {
        transform_tohost_VkDebugUtilsObjectNameInfoEXT(mImpl->resources(), (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1386;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1386, 1);
        countingStream->write((uint64_t*)&cgen_var_1386, 1 * 8);
        marshal_VkDebugUtilsObjectNameInfoEXT(countingStream, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    uint32_t packetSize_vkSetDebugUtilsObjectNameEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetDebugUtilsObjectNameEXT = OP_vkSetDebugUtilsObjectNameEXT;
    stream->write(&opcode_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t));
    uint64_t cgen_var_1387;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1387, 1);
    stream->write((uint64_t*)&cgen_var_1387, 1 * 8);
    marshal_VkDebugUtilsObjectNameInfoEXT(stream, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectNameEXT readParams");
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectNameEXT returnUnmarshal");
    VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkSetDebugUtilsObjectNameEXT");;
    return vkSetDebugUtilsObjectNameEXT_VkResult_return;
}

VkResult VkEncoder::vkSetDebugUtilsObjectTagEXT(
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectTagEXT encode");
    mImpl->log("start vkSetDebugUtilsObjectTagEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDebugUtilsObjectTagInfoEXT* local_pTagInfo;
    local_device = device;
    local_pTagInfo = nullptr;
    if (pTagInfo)
    {
        local_pTagInfo = (VkDebugUtilsObjectTagInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsObjectTagInfoEXT));
        deepcopy_VkDebugUtilsObjectTagInfoEXT(pool, pTagInfo, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    if (local_pTagInfo)
    {
        transform_tohost_VkDebugUtilsObjectTagInfoEXT(mImpl->resources(), (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1388;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1388, 1);
        countingStream->write((uint64_t*)&cgen_var_1388, 1 * 8);
        marshal_VkDebugUtilsObjectTagInfoEXT(countingStream, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    uint32_t packetSize_vkSetDebugUtilsObjectTagEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetDebugUtilsObjectTagEXT = OP_vkSetDebugUtilsObjectTagEXT;
    stream->write(&opcode_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t));
    uint64_t cgen_var_1389;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1389, 1);
    stream->write((uint64_t*)&cgen_var_1389, 1 * 8);
    marshal_VkDebugUtilsObjectTagInfoEXT(stream, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectTagEXT readParams");
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectTagEXT returnUnmarshal");
    VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkSetDebugUtilsObjectTagEXT");;
    return vkSetDebugUtilsObjectTagEXT_VkResult_return;
}

void VkEncoder::vkQueueBeginDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkQueueBeginDebugUtilsLabelEXT encode");
    mImpl->log("start vkQueueBeginDebugUtilsLabelEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_queue = queue;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(mImpl->resources(), (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1390;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1390, 1);
        countingStream->write((uint64_t*)&cgen_var_1390, 1 * 8);
        marshal_VkDebugUtilsLabelEXT(countingStream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    uint32_t packetSize_vkQueueBeginDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueBeginDebugUtilsLabelEXT = OP_vkQueueBeginDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1391;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1391, 1);
    stream->write((uint64_t*)&cgen_var_1391, 1 * 8);
    marshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    AEMU_SCOPED_TRACE("vkQueueBeginDebugUtilsLabelEXT readParams");
    AEMU_SCOPED_TRACE("vkQueueBeginDebugUtilsLabelEXT returnUnmarshal");
    mImpl->log("finish vkQueueBeginDebugUtilsLabelEXT");;
}

void VkEncoder::vkQueueEndDebugUtilsLabelEXT(
    VkQueue queue)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkQueueEndDebugUtilsLabelEXT encode");
    mImpl->log("start vkQueueEndDebugUtilsLabelEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    local_queue = queue;
    countingStream->rewind();
    {
        uint64_t cgen_var_1392;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1392, 1);
        countingStream->write((uint64_t*)&cgen_var_1392, 1 * 8);
    }
    uint32_t packetSize_vkQueueEndDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueEndDebugUtilsLabelEXT = OP_vkQueueEndDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1393;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1393, 1);
    stream->write((uint64_t*)&cgen_var_1393, 1 * 8);
    AEMU_SCOPED_TRACE("vkQueueEndDebugUtilsLabelEXT readParams");
    AEMU_SCOPED_TRACE("vkQueueEndDebugUtilsLabelEXT returnUnmarshal");
    mImpl->log("finish vkQueueEndDebugUtilsLabelEXT");;
}

void VkEncoder::vkQueueInsertDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkQueueInsertDebugUtilsLabelEXT encode");
    mImpl->log("start vkQueueInsertDebugUtilsLabelEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_queue = queue;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(mImpl->resources(), (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1394;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1394, 1);
        countingStream->write((uint64_t*)&cgen_var_1394, 1 * 8);
        marshal_VkDebugUtilsLabelEXT(countingStream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    uint32_t packetSize_vkQueueInsertDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueInsertDebugUtilsLabelEXT = OP_vkQueueInsertDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1395;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1395, 1);
    stream->write((uint64_t*)&cgen_var_1395, 1 * 8);
    marshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    AEMU_SCOPED_TRACE("vkQueueInsertDebugUtilsLabelEXT readParams");
    AEMU_SCOPED_TRACE("vkQueueInsertDebugUtilsLabelEXT returnUnmarshal");
    mImpl->log("finish vkQueueInsertDebugUtilsLabelEXT");;
}

void VkEncoder::vkCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdBeginDebugUtilsLabelEXT encode");
    mImpl->log("start vkCmdBeginDebugUtilsLabelEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_commandBuffer = commandBuffer;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(mImpl->resources(), (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1396;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1396, 1);
        countingStream->write((uint64_t*)&cgen_var_1396, 1 * 8);
        marshal_VkDebugUtilsLabelEXT(countingStream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    uint32_t packetSize_vkCmdBeginDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginDebugUtilsLabelEXT = OP_vkCmdBeginDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1397;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1397, 1);
    stream->write((uint64_t*)&cgen_var_1397, 1 * 8);
    marshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    AEMU_SCOPED_TRACE("vkCmdBeginDebugUtilsLabelEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdBeginDebugUtilsLabelEXT returnUnmarshal");
    mImpl->log("finish vkCmdBeginDebugUtilsLabelEXT");;
}

void VkEncoder::vkCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdEndDebugUtilsLabelEXT encode");
    mImpl->log("start vkCmdEndDebugUtilsLabelEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1398;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1398, 1);
        countingStream->write((uint64_t*)&cgen_var_1398, 1 * 8);
    }
    uint32_t packetSize_vkCmdEndDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndDebugUtilsLabelEXT = OP_vkCmdEndDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1399;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1399, 1);
    stream->write((uint64_t*)&cgen_var_1399, 1 * 8);
    AEMU_SCOPED_TRACE("vkCmdEndDebugUtilsLabelEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdEndDebugUtilsLabelEXT returnUnmarshal");
    mImpl->log("finish vkCmdEndDebugUtilsLabelEXT");;
}

void VkEncoder::vkCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdInsertDebugUtilsLabelEXT encode");
    mImpl->log("start vkCmdInsertDebugUtilsLabelEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_commandBuffer = commandBuffer;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(mImpl->resources(), (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1400;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1400, 1);
        countingStream->write((uint64_t*)&cgen_var_1400, 1 * 8);
        marshal_VkDebugUtilsLabelEXT(countingStream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    uint32_t packetSize_vkCmdInsertDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdInsertDebugUtilsLabelEXT = OP_vkCmdInsertDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1401;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1401, 1);
    stream->write((uint64_t*)&cgen_var_1401, 1 * 8);
    marshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    AEMU_SCOPED_TRACE("vkCmdInsertDebugUtilsLabelEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdInsertDebugUtilsLabelEXT returnUnmarshal");
    mImpl->log("finish vkCmdInsertDebugUtilsLabelEXT");;
}

VkResult VkEncoder::vkCreateDebugUtilsMessengerEXT(
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateDebugUtilsMessengerEXT encode");
    mImpl->log("start vkCreateDebugUtilsMessengerEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugUtilsMessengerCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDebugUtilsMessengerCreateInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
        deepcopy_VkDebugUtilsMessengerCreateInfoEXT(pool, pCreateInfo, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDebugUtilsMessengerCreateInfoEXT(mImpl->resources(), (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1402;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1402, 1);
        countingStream->write((uint64_t*)&cgen_var_1402, 1 * 8);
        marshal_VkDebugUtilsMessengerCreateInfoEXT(countingStream, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1403 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1403);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1404;
        countingStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(pMessenger, &cgen_var_1404, 1);
        countingStream->write((uint64_t*)&cgen_var_1404, 8);
    }
    uint32_t packetSize_vkCreateDebugUtilsMessengerEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDebugUtilsMessengerEXT = OP_vkCreateDebugUtilsMessengerEXT;
    stream->write(&opcode_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t));
    uint64_t cgen_var_1405;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1405, 1);
    stream->write((uint64_t*)&cgen_var_1405, 1 * 8);
    marshal_VkDebugUtilsMessengerCreateInfoEXT(stream, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1406 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1406);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1407;
    stream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(pMessenger, &cgen_var_1407, 1);
    stream->write((uint64_t*)&cgen_var_1407, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateDebugUtilsMessengerEXT readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1408;
    stream->read((uint64_t*)&cgen_var_1408, 8);
    stream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_1408, (VkDebugUtilsMessengerEXT*)pMessenger, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateDebugUtilsMessengerEXT returnUnmarshal");
    VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateDebugUtilsMessengerEXT");;
    return vkCreateDebugUtilsMessengerEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugUtilsMessengerEXT(
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyDebugUtilsMessengerEXT encode");
    mImpl->log("start vkDestroyDebugUtilsMessengerEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugUtilsMessengerEXT local_messenger;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_messenger = messenger;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1409;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1409, 1);
        countingStream->write((uint64_t*)&cgen_var_1409, 1 * 8);
        uint64_t cgen_var_1410;
        countingStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(&local_messenger, &cgen_var_1410, 1);
        countingStream->write((uint64_t*)&cgen_var_1410, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1411 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1411);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDebugUtilsMessengerEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDebugUtilsMessengerEXT = OP_vkDestroyDebugUtilsMessengerEXT;
    stream->write(&opcode_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t));
    uint64_t cgen_var_1412;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1412, 1);
    stream->write((uint64_t*)&cgen_var_1412, 1 * 8);
    uint64_t cgen_var_1413;
    stream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(&local_messenger, &cgen_var_1413, 1);
    stream->write((uint64_t*)&cgen_var_1413, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1414 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1414);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyDebugUtilsMessengerEXT readParams");
    AEMU_SCOPED_TRACE("vkDestroyDebugUtilsMessengerEXT returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkDebugUtilsMessengerEXT((VkDebugUtilsMessengerEXT*)&messenger);
    mImpl->log("finish vkDestroyDebugUtilsMessengerEXT");;
}

void VkEncoder::vkSubmitDebugUtilsMessageEXT(
    VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkSubmitDebugUtilsMessageEXT encode");
    mImpl->log("start vkSubmitDebugUtilsMessageEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugUtilsMessageSeverityFlagBitsEXT local_messageSeverity;
    VkDebugUtilsMessageTypeFlagsEXT local_messageTypes;
    VkDebugUtilsMessengerCallbackDataEXT* local_pCallbackData;
    local_instance = instance;
    local_messageSeverity = messageSeverity;
    local_messageTypes = messageTypes;
    local_pCallbackData = nullptr;
    if (pCallbackData)
    {
        local_pCallbackData = (VkDebugUtilsMessengerCallbackDataEXT*)pool->alloc(sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
        deepcopy_VkDebugUtilsMessengerCallbackDataEXT(pool, pCallbackData, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    if (local_pCallbackData)
    {
        transform_tohost_VkDebugUtilsMessengerCallbackDataEXT(mImpl->resources(), (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1415;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1415, 1);
        countingStream->write((uint64_t*)&cgen_var_1415, 1 * 8);
        countingStream->write((VkDebugUtilsMessageSeverityFlagBitsEXT*)&local_messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
        countingStream->write((VkDebugUtilsMessageTypeFlagsEXT*)&local_messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
        marshal_VkDebugUtilsMessengerCallbackDataEXT(countingStream, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    uint32_t packetSize_vkSubmitDebugUtilsMessageEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSubmitDebugUtilsMessageEXT = OP_vkSubmitDebugUtilsMessageEXT;
    stream->write(&opcode_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t));
    uint64_t cgen_var_1416;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1416, 1);
    stream->write((uint64_t*)&cgen_var_1416, 1 * 8);
    stream->write((VkDebugUtilsMessageSeverityFlagBitsEXT*)&local_messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
    stream->write((VkDebugUtilsMessageTypeFlagsEXT*)&local_messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    marshal_VkDebugUtilsMessengerCallbackDataEXT(stream, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    AEMU_SCOPED_TRACE("vkSubmitDebugUtilsMessageEXT readParams");
    AEMU_SCOPED_TRACE("vkSubmitDebugUtilsMessageEXT returnUnmarshal");
    mImpl->log("finish vkSubmitDebugUtilsMessageEXT");;
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
VkResult VkEncoder::vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetAndroidHardwareBufferPropertiesANDROID encode");
    mImpl->log("start vkGetAndroidHardwareBufferPropertiesANDROID");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    AHardwareBuffer* local_buffer;
    local_device = device;
    local_buffer = nullptr;
    if (buffer)
    {
        local_buffer = (AHardwareBuffer*)pool->dupArray(buffer, sizeof(const AHardwareBuffer));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1417;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1417, 1);
        countingStream->write((uint64_t*)&cgen_var_1417, 1 * 8);
        countingStream->write((AHardwareBuffer*)local_buffer, sizeof(AHardwareBuffer));
        marshal_VkAndroidHardwareBufferPropertiesANDROID(countingStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    }
    uint32_t packetSize_vkGetAndroidHardwareBufferPropertiesANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetAndroidHardwareBufferPropertiesANDROID = OP_vkGetAndroidHardwareBufferPropertiesANDROID;
    stream->write(&opcode_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1418;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1418, 1);
    stream->write((uint64_t*)&cgen_var_1418, 1 * 8);
    stream->write((AHardwareBuffer*)local_buffer, sizeof(AHardwareBuffer));
    marshal_VkAndroidHardwareBufferPropertiesANDROID(stream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    AEMU_SCOPED_TRACE("vkGetAndroidHardwareBufferPropertiesANDROID readParams");
    unmarshal_VkAndroidHardwareBufferPropertiesANDROID(stream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkAndroidHardwareBufferPropertiesANDROID(mImpl->resources(), (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    }
    AEMU_SCOPED_TRACE("vkGetAndroidHardwareBufferPropertiesANDROID returnUnmarshal");
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetAndroidHardwareBufferPropertiesANDROID");;
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetMemoryAndroidHardwareBufferANDROID encode");
    mImpl->log("start vkGetMemoryAndroidHardwareBufferANDROID");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkMemoryGetAndroidHardwareBufferInfoANDROID* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkMemoryGetAndroidHardwareBufferInfoANDROID*)pool->alloc(sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
        deepcopy_VkMemoryGetAndroidHardwareBufferInfoANDROID(pool, pInfo, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkMemoryGetAndroidHardwareBufferInfoANDROID(mImpl->resources(), (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1419;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1419, 1);
        countingStream->write((uint64_t*)&cgen_var_1419, 1 * 8);
        marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(countingStream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
        countingStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    }
    uint32_t packetSize_vkGetMemoryAndroidHardwareBufferANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryAndroidHardwareBufferANDROID = OP_vkGetMemoryAndroidHardwareBufferANDROID;
    stream->write(&opcode_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1420;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1420, 1);
    stream->write((uint64_t*)&cgen_var_1420, 1 * 8);
    marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(stream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    stream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    AEMU_SCOPED_TRACE("vkGetMemoryAndroidHardwareBufferANDROID readParams");
    stream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    AEMU_SCOPED_TRACE("vkGetMemoryAndroidHardwareBufferANDROID returnUnmarshal");
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetMemoryAndroidHardwareBufferANDROID");;
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void VkEncoder::vkCmdSetSampleLocationsEXT(
    VkCommandBuffer commandBuffer,
    const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetSampleLocationsEXT encode");
    mImpl->log("start vkCmdSetSampleLocationsEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkSampleLocationsInfoEXT* local_pSampleLocationsInfo;
    local_commandBuffer = commandBuffer;
    local_pSampleLocationsInfo = nullptr;
    if (pSampleLocationsInfo)
    {
        local_pSampleLocationsInfo = (VkSampleLocationsInfoEXT*)pool->alloc(sizeof(const VkSampleLocationsInfoEXT));
        deepcopy_VkSampleLocationsInfoEXT(pool, pSampleLocationsInfo, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    if (local_pSampleLocationsInfo)
    {
        transform_tohost_VkSampleLocationsInfoEXT(mImpl->resources(), (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1421;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1421, 1);
        countingStream->write((uint64_t*)&cgen_var_1421, 1 * 8);
        marshal_VkSampleLocationsInfoEXT(countingStream, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    uint32_t packetSize_vkCmdSetSampleLocationsEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetSampleLocationsEXT = OP_vkCmdSetSampleLocationsEXT;
    stream->write(&opcode_vkCmdSetSampleLocationsEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetSampleLocationsEXT, sizeof(uint32_t));
    uint64_t cgen_var_1422;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1422, 1);
    stream->write((uint64_t*)&cgen_var_1422, 1 * 8);
    marshal_VkSampleLocationsInfoEXT(stream, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    AEMU_SCOPED_TRACE("vkCmdSetSampleLocationsEXT readParams");
    AEMU_SCOPED_TRACE("vkCmdSetSampleLocationsEXT returnUnmarshal");
    mImpl->log("finish vkCmdSetSampleLocationsEXT");;
}

void VkEncoder::vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice physicalDevice,
    VkSampleCountFlagBits samples,
    VkMultisamplePropertiesEXT* pMultisampleProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMultisamplePropertiesEXT encode");
    mImpl->log("start vkGetPhysicalDeviceMultisamplePropertiesEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSampleCountFlagBits local_samples;
    local_physicalDevice = physicalDevice;
    local_samples = samples;
    countingStream->rewind();
    {
        uint64_t cgen_var_1423;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1423, 1);
        countingStream->write((uint64_t*)&cgen_var_1423, 1 * 8);
        countingStream->write((VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
        marshal_VkMultisamplePropertiesEXT(countingStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT = OP_vkGetPhysicalDeviceMultisamplePropertiesEXT;
    stream->write(&opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t));
    uint64_t cgen_var_1424;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1424, 1);
    stream->write((uint64_t*)&cgen_var_1424, 1 * 8);
    stream->write((VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
    marshal_VkMultisamplePropertiesEXT(stream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMultisamplePropertiesEXT readParams");
    unmarshal_VkMultisamplePropertiesEXT(stream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    if (pMultisampleProperties)
    {
        transform_fromhost_VkMultisamplePropertiesEXT(mImpl->resources(), (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    }
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMultisamplePropertiesEXT returnUnmarshal");
    mImpl->log("finish vkGetPhysicalDeviceMultisamplePropertiesEXT");;
}

#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
VkResult VkEncoder::vkCreateValidationCacheEXT(
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateValidationCacheEXT encode");
    mImpl->log("start vkCreateValidationCacheEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkValidationCacheCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkValidationCacheCreateInfoEXT*)pool->alloc(sizeof(const VkValidationCacheCreateInfoEXT));
        deepcopy_VkValidationCacheCreateInfoEXT(pool, pCreateInfo, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkValidationCacheCreateInfoEXT(mImpl->resources(), (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1425;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1425, 1);
        countingStream->write((uint64_t*)&cgen_var_1425, 1 * 8);
        marshal_VkValidationCacheCreateInfoEXT(countingStream, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1426 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1426);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1427;
        countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(pValidationCache, &cgen_var_1427, 1);
        countingStream->write((uint64_t*)&cgen_var_1427, 8);
    }
    uint32_t packetSize_vkCreateValidationCacheEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateValidationCacheEXT = OP_vkCreateValidationCacheEXT;
    stream->write(&opcode_vkCreateValidationCacheEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateValidationCacheEXT, sizeof(uint32_t));
    uint64_t cgen_var_1428;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1428, 1);
    stream->write((uint64_t*)&cgen_var_1428, 1 * 8);
    marshal_VkValidationCacheCreateInfoEXT(stream, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1429 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1429);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1430;
    stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(pValidationCache, &cgen_var_1430, 1);
    stream->write((uint64_t*)&cgen_var_1430, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    AEMU_SCOPED_TRACE("vkCreateValidationCacheEXT readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1431;
    stream->read((uint64_t*)&cgen_var_1431, 8);
    stream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_1431, (VkValidationCacheEXT*)pValidationCache, 1);
    stream->unsetHandleMapping();
    AEMU_SCOPED_TRACE("vkCreateValidationCacheEXT returnUnmarshal");
    VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateValidationCacheEXT");;
    return vkCreateValidationCacheEXT_VkResult_return;
}

void VkEncoder::vkDestroyValidationCacheEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkDestroyValidationCacheEXT encode");
    mImpl->log("start vkDestroyValidationCacheEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkValidationCacheEXT local_validationCache;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_validationCache = validationCache;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1432;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1432, 1);
        countingStream->write((uint64_t*)&cgen_var_1432, 1 * 8);
        uint64_t cgen_var_1433;
        countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_validationCache, &cgen_var_1433, 1);
        countingStream->write((uint64_t*)&cgen_var_1433, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1434 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1434);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyValidationCacheEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyValidationCacheEXT = OP_vkDestroyValidationCacheEXT;
    stream->write(&opcode_vkDestroyValidationCacheEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyValidationCacheEXT, sizeof(uint32_t));
    uint64_t cgen_var_1435;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1435, 1);
    stream->write((uint64_t*)&cgen_var_1435, 1 * 8);
    uint64_t cgen_var_1436;
    stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_validationCache, &cgen_var_1436, 1);
    stream->write((uint64_t*)&cgen_var_1436, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1437 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1437);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkDestroyValidationCacheEXT readParams");
    AEMU_SCOPED_TRACE("vkDestroyValidationCacheEXT returnUnmarshal");
    resources->destroyMapping()->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)&validationCache);
    mImpl->log("finish vkDestroyValidationCacheEXT");;
}

VkResult VkEncoder::vkMergeValidationCachesEXT(
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkMergeValidationCachesEXT encode");
    mImpl->log("start vkMergeValidationCachesEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkValidationCacheEXT local_dstCache;
    uint32_t local_srcCacheCount;
    VkValidationCacheEXT* local_pSrcCaches;
    local_device = device;
    local_dstCache = dstCache;
    local_srcCacheCount = srcCacheCount;
    local_pSrcCaches = nullptr;
    if (pSrcCaches)
    {
        local_pSrcCaches = (VkValidationCacheEXT*)pool->dupArray(pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1438;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1438, 1);
        countingStream->write((uint64_t*)&cgen_var_1438, 1 * 8);
        uint64_t cgen_var_1439;
        countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_dstCache, &cgen_var_1439, 1);
        countingStream->write((uint64_t*)&cgen_var_1439, 1 * 8);
        countingStream->write((uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
        if (((srcCacheCount)))
        {
            uint64_t* cgen_var_1440;
            countingStream->alloc((void**)&cgen_var_1440, ((srcCacheCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(local_pSrcCaches, cgen_var_1440, ((srcCacheCount)));
            countingStream->write((uint64_t*)cgen_var_1440, ((srcCacheCount)) * 8);
        }
    }
    uint32_t packetSize_vkMergeValidationCachesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMergeValidationCachesEXT = OP_vkMergeValidationCachesEXT;
    stream->write(&opcode_vkMergeValidationCachesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkMergeValidationCachesEXT, sizeof(uint32_t));
    uint64_t cgen_var_1441;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1441, 1);
    stream->write((uint64_t*)&cgen_var_1441, 1 * 8);
    uint64_t cgen_var_1442;
    stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_dstCache, &cgen_var_1442, 1);
    stream->write((uint64_t*)&cgen_var_1442, 1 * 8);
    stream->write((uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
    if (((srcCacheCount)))
    {
        uint64_t* cgen_var_1443;
        stream->alloc((void**)&cgen_var_1443, ((srcCacheCount)) * 8);
        stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(local_pSrcCaches, cgen_var_1443, ((srcCacheCount)));
        stream->write((uint64_t*)cgen_var_1443, ((srcCacheCount)) * 8);
    }
    AEMU_SCOPED_TRACE("vkMergeValidationCachesEXT readParams");
    AEMU_SCOPED_TRACE("vkMergeValidationCachesEXT returnUnmarshal");
    VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkMergeValidationCachesEXT");;
    return vkMergeValidationCachesEXT_VkResult_return;
}

VkResult VkEncoder::vkGetValidationCacheDataEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetValidationCacheDataEXT encode");
    mImpl->log("start vkGetValidationCacheDataEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkValidationCacheEXT local_validationCache;
    local_device = device;
    local_validationCache = validationCache;
    countingStream->rewind();
    {
        uint64_t cgen_var_1444;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1444, 1);
        countingStream->write((uint64_t*)&cgen_var_1444, 1 * 8);
        uint64_t cgen_var_1445;
        countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_validationCache, &cgen_var_1445, 1);
        countingStream->write((uint64_t*)&cgen_var_1445, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1446 = (uint64_t)(uintptr_t)pDataSize;
        countingStream->putBe64(cgen_var_1446);
        if (pDataSize)
        {
            uint64_t cgen_var_1447 = (uint64_t)(*pDataSize);
            countingStream->putBe64(cgen_var_1447);
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1448 = (uint64_t)(uintptr_t)pData;
        countingStream->putBe64(cgen_var_1448);
        if (pData)
        {
            countingStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetValidationCacheDataEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetValidationCacheDataEXT = OP_vkGetValidationCacheDataEXT;
    stream->write(&opcode_vkGetValidationCacheDataEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetValidationCacheDataEXT, sizeof(uint32_t));
    uint64_t cgen_var_1449;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1449, 1);
    stream->write((uint64_t*)&cgen_var_1449, 1 * 8);
    uint64_t cgen_var_1450;
    stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_validationCache, &cgen_var_1450, 1);
    stream->write((uint64_t*)&cgen_var_1450, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1451 = (uint64_t)(uintptr_t)pDataSize;
    stream->putBe64(cgen_var_1451);
    if (pDataSize)
    {
        uint64_t cgen_var_1452 = (uint64_t)(*pDataSize);
        stream->putBe64(cgen_var_1452);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1453 = (uint64_t)(uintptr_t)pData;
    stream->putBe64(cgen_var_1453);
    if (pData)
    {
        stream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkGetValidationCacheDataEXT readParams");
    // WARNING PTR CHECK
    size_t* check_pDataSize;
    check_pDataSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        (*pDataSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pData;
    check_pData = (void*)(uintptr_t)stream->getBe64();
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkGetValidationCacheDataEXT returnUnmarshal");
    VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetValidationCacheDataEXT");;
    return vkGetValidationCacheDataEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
VkResult VkEncoder::vkGetMemoryHostPointerPropertiesEXT(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetMemoryHostPointerPropertiesEXT encode");
    mImpl->log("start vkGetMemoryHostPointerPropertiesEXT");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    void* local_pHostPointer;
    local_device = device;
    local_handleType = handleType;
    local_pHostPointer = nullptr;
    if (pHostPointer)
    {
        local_pHostPointer = (void*)pool->dupArray(pHostPointer, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1457;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1457, 1);
        countingStream->write((uint64_t*)&cgen_var_1457, 1 * 8);
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        // WARNING PTR CHECK
        uint64_t cgen_var_1458 = (uint64_t)(uintptr_t)local_pHostPointer;
        countingStream->putBe64(cgen_var_1458);
        if (local_pHostPointer)
        {
            countingStream->write((void*)local_pHostPointer, sizeof(uint8_t));
        }
        marshal_VkMemoryHostPointerPropertiesEXT(countingStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    }
    uint32_t packetSize_vkGetMemoryHostPointerPropertiesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryHostPointerPropertiesEXT = OP_vkGetMemoryHostPointerPropertiesEXT;
    stream->write(&opcode_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t));
    uint64_t cgen_var_1459;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1459, 1);
    stream->write((uint64_t*)&cgen_var_1459, 1 * 8);
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    // WARNING PTR CHECK
    uint64_t cgen_var_1460 = (uint64_t)(uintptr_t)local_pHostPointer;
    stream->putBe64(cgen_var_1460);
    if (local_pHostPointer)
    {
        stream->write((void*)local_pHostPointer, sizeof(uint8_t));
    }
    marshal_VkMemoryHostPointerPropertiesEXT(stream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    AEMU_SCOPED_TRACE("vkGetMemoryHostPointerPropertiesEXT readParams");
    unmarshal_VkMemoryHostPointerPropertiesEXT(stream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    if (pMemoryHostPointerProperties)
    {
        transform_fromhost_VkMemoryHostPointerPropertiesEXT(mImpl->resources(), (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    }
    AEMU_SCOPED_TRACE("vkGetMemoryHostPointerPropertiesEXT returnUnmarshal");
    VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetMemoryHostPointerPropertiesEXT");;
    return vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}

#endif
#ifdef VK_AMD_buffer_marker
void VkEncoder::vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    uint32_t marker)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdWriteBufferMarkerAMD encode");
    mImpl->log("start vkCmdWriteBufferMarkerAMD");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlagBits local_pipelineStage;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    uint32_t local_marker;
    local_commandBuffer = commandBuffer;
    local_pipelineStage = pipelineStage;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_marker = marker;
    countingStream->rewind();
    {
        uint64_t cgen_var_1461;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1461, 1);
        countingStream->write((uint64_t*)&cgen_var_1461, 1 * 8);
        countingStream->write((VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
        uint64_t cgen_var_1462;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_1462, 1);
        countingStream->write((uint64_t*)&cgen_var_1462, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_marker, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdWriteBufferMarkerAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWriteBufferMarkerAMD = OP_vkCmdWriteBufferMarkerAMD;
    stream->write(&opcode_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t));
    uint64_t cgen_var_1463;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1463, 1);
    stream->write((uint64_t*)&cgen_var_1463, 1 * 8);
    stream->write((VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
    uint64_t cgen_var_1464;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_1464, 1);
    stream->write((uint64_t*)&cgen_var_1464, 1 * 8);
    stream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_marker, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCmdWriteBufferMarkerAMD readParams");
    AEMU_SCOPED_TRACE("vkCmdWriteBufferMarkerAMD returnUnmarshal");
    mImpl->log("finish vkCmdWriteBufferMarkerAMD");;
}

#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void VkEncoder::vkCmdSetCheckpointNV(
    VkCommandBuffer commandBuffer,
    const void* pCheckpointMarker)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCmdSetCheckpointNV encode");
    mImpl->log("start vkCmdSetCheckpointNV");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    void* local_pCheckpointMarker;
    local_commandBuffer = commandBuffer;
    local_pCheckpointMarker = nullptr;
    if (pCheckpointMarker)
    {
        local_pCheckpointMarker = (void*)pool->dupArray(pCheckpointMarker, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1465;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1465, 1);
        countingStream->write((uint64_t*)&cgen_var_1465, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1466 = (uint64_t)(uintptr_t)local_pCheckpointMarker;
        countingStream->putBe64(cgen_var_1466);
        if (local_pCheckpointMarker)
        {
            countingStream->write((void*)local_pCheckpointMarker, sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkCmdSetCheckpointNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetCheckpointNV = OP_vkCmdSetCheckpointNV;
    stream->write(&opcode_vkCmdSetCheckpointNV, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetCheckpointNV, sizeof(uint32_t));
    uint64_t cgen_var_1467;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1467, 1);
    stream->write((uint64_t*)&cgen_var_1467, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1468 = (uint64_t)(uintptr_t)local_pCheckpointMarker;
    stream->putBe64(cgen_var_1468);
    if (local_pCheckpointMarker)
    {
        stream->write((void*)local_pCheckpointMarker, sizeof(uint8_t));
    }
    AEMU_SCOPED_TRACE("vkCmdSetCheckpointNV readParams");
    AEMU_SCOPED_TRACE("vkCmdSetCheckpointNV returnUnmarshal");
    mImpl->log("finish vkCmdSetCheckpointNV");;
}

void VkEncoder::vkGetQueueCheckpointDataNV(
    VkQueue queue,
    uint32_t* pCheckpointDataCount,
    VkCheckpointDataNV* pCheckpointData)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetQueueCheckpointDataNV encode");
    mImpl->log("start vkGetQueueCheckpointDataNV");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    local_queue = queue;
    countingStream->rewind();
    {
        uint64_t cgen_var_1469;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1469, 1);
        countingStream->write((uint64_t*)&cgen_var_1469, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1470 = (uint64_t)(uintptr_t)pCheckpointDataCount;
        countingStream->putBe64(cgen_var_1470);
        if (pCheckpointDataCount)
        {
            countingStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1471 = (uint64_t)(uintptr_t)pCheckpointData;
        countingStream->putBe64(cgen_var_1471);
        if (pCheckpointData)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
            {
                marshal_VkCheckpointDataNV(countingStream, (VkCheckpointDataNV*)(pCheckpointData + i));
            }
        }
    }
    uint32_t packetSize_vkGetQueueCheckpointDataNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetQueueCheckpointDataNV = OP_vkGetQueueCheckpointDataNV;
    stream->write(&opcode_vkGetQueueCheckpointDataNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetQueueCheckpointDataNV, sizeof(uint32_t));
    uint64_t cgen_var_1472;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1472, 1);
    stream->write((uint64_t*)&cgen_var_1472, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1473 = (uint64_t)(uintptr_t)pCheckpointDataCount;
    stream->putBe64(cgen_var_1473);
    if (pCheckpointDataCount)
    {
        stream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1474 = (uint64_t)(uintptr_t)pCheckpointData;
    stream->putBe64(cgen_var_1474);
    if (pCheckpointData)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            marshal_VkCheckpointDataNV(stream, (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetQueueCheckpointDataNV readParams");
    // WARNING PTR CHECK
    uint32_t* check_pCheckpointDataCount;
    check_pCheckpointDataCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pCheckpointDataCount)
    {
        if (!(check_pCheckpointDataCount))
        {
            fprintf(stderr, "fatal: pCheckpointDataCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkCheckpointDataNV* check_pCheckpointData;
    check_pCheckpointData = (VkCheckpointDataNV*)(uintptr_t)stream->getBe64();
    if (pCheckpointData)
    {
        if (!(check_pCheckpointData))
        {
            fprintf(stderr, "fatal: pCheckpointData inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            unmarshal_VkCheckpointDataNV(stream, (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
    if (pCheckpointData)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            transform_fromhost_VkCheckpointDataNV(mImpl->resources(), (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
    AEMU_SCOPED_TRACE("vkGetQueueCheckpointDataNV returnUnmarshal");
    mImpl->log("finish vkGetQueueCheckpointDataNV");;
}

#endif
#ifdef VK_GOOGLE_address_space
VkResult VkEncoder::vkMapMemoryIntoAddressSpaceGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkMapMemoryIntoAddressSpaceGOOGLE encode");
    mImpl->log("start vkMapMemoryIntoAddressSpaceGOOGLE");
    encoderLock.unlock();
    mImpl->resources()->on_vkMapMemoryIntoAddressSpaceGOOGLE_pre(this, VK_SUCCESS, device, memory, pAddress);
    encoderLock.lock();
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    mImpl->resources()->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_1477;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1477, 1);
        countingStream->write((uint64_t*)&cgen_var_1477, 1 * 8);
        uint64_t cgen_var_1478;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1478, 1);
        countingStream->write((uint64_t*)&cgen_var_1478, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1479 = (uint64_t)(uintptr_t)pAddress;
        countingStream->putBe64(cgen_var_1479);
        if (pAddress)
        {
            countingStream->write((uint64_t*)pAddress, sizeof(uint64_t));
        }
    }
    uint32_t packetSize_vkMapMemoryIntoAddressSpaceGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMapMemoryIntoAddressSpaceGOOGLE = OP_vkMapMemoryIntoAddressSpaceGOOGLE;
    stream->write(&opcode_vkMapMemoryIntoAddressSpaceGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkMapMemoryIntoAddressSpaceGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1480;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1480, 1);
    stream->write((uint64_t*)&cgen_var_1480, 1 * 8);
    uint64_t cgen_var_1481;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1481, 1);
    stream->write((uint64_t*)&cgen_var_1481, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1482 = (uint64_t)(uintptr_t)pAddress;
    stream->putBe64(cgen_var_1482);
    if (pAddress)
    {
        stream->write((uint64_t*)pAddress, sizeof(uint64_t));
    }
    AEMU_SCOPED_TRACE("vkMapMemoryIntoAddressSpaceGOOGLE readParams");
    // WARNING PTR CHECK
    uint64_t* check_pAddress;
    check_pAddress = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pAddress)
    {
        if (!(check_pAddress))
        {
            fprintf(stderr, "fatal: pAddress inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pAddress, sizeof(uint64_t));
    }
    AEMU_SCOPED_TRACE("vkMapMemoryIntoAddressSpaceGOOGLE returnUnmarshal");
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    encoderLock.unlock();
    mImpl->resources()->on_vkMapMemoryIntoAddressSpaceGOOGLE(this, vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory, pAddress);
    encoderLock.lock();
    mImpl->log("finish vkMapMemoryIntoAddressSpaceGOOGLE");;
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_color_buffer
VkResult VkEncoder::vkRegisterImageColorBufferGOOGLE(
    VkDevice device,
    VkImage image,
    uint32_t colorBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkRegisterImageColorBufferGOOGLE encode");
    mImpl->log("start vkRegisterImageColorBufferGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    uint32_t local_colorBuffer;
    local_device = device;
    local_image = image;
    local_colorBuffer = colorBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1484;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1484, 1);
        countingStream->write((uint64_t*)&cgen_var_1484, 1 * 8);
        uint64_t cgen_var_1485;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1485, 1);
        countingStream->write((uint64_t*)&cgen_var_1485, 1 * 8);
        countingStream->write((uint32_t*)&local_colorBuffer, sizeof(uint32_t));
    }
    uint32_t packetSize_vkRegisterImageColorBufferGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterImageColorBufferGOOGLE = OP_vkRegisterImageColorBufferGOOGLE;
    stream->write(&opcode_vkRegisterImageColorBufferGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterImageColorBufferGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1486;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1486, 1);
    stream->write((uint64_t*)&cgen_var_1486, 1 * 8);
    uint64_t cgen_var_1487;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1487, 1);
    stream->write((uint64_t*)&cgen_var_1487, 1 * 8);
    stream->write((uint32_t*)&local_colorBuffer, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkRegisterImageColorBufferGOOGLE readParams");
    AEMU_SCOPED_TRACE("vkRegisterImageColorBufferGOOGLE returnUnmarshal");
    VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterImageColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkRegisterImageColorBufferGOOGLE");;
    return vkRegisterImageColorBufferGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkRegisterBufferColorBufferGOOGLE(
    VkDevice device,
    VkBuffer buffer,
    uint32_t colorBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkRegisterBufferColorBufferGOOGLE encode");
    mImpl->log("start vkRegisterBufferColorBufferGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBuffer local_buffer;
    uint32_t local_colorBuffer;
    local_device = device;
    local_buffer = buffer;
    local_colorBuffer = colorBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1488;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1488, 1);
        countingStream->write((uint64_t*)&cgen_var_1488, 1 * 8);
        uint64_t cgen_var_1489;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1489, 1);
        countingStream->write((uint64_t*)&cgen_var_1489, 1 * 8);
        countingStream->write((uint32_t*)&local_colorBuffer, sizeof(uint32_t));
    }
    uint32_t packetSize_vkRegisterBufferColorBufferGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterBufferColorBufferGOOGLE = OP_vkRegisterBufferColorBufferGOOGLE;
    stream->write(&opcode_vkRegisterBufferColorBufferGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterBufferColorBufferGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1490;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1490, 1);
    stream->write((uint64_t*)&cgen_var_1490, 1 * 8);
    uint64_t cgen_var_1491;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1491, 1);
    stream->write((uint64_t*)&cgen_var_1491, 1 * 8);
    stream->write((uint32_t*)&local_colorBuffer, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkRegisterBufferColorBufferGOOGLE readParams");
    AEMU_SCOPED_TRACE("vkRegisterBufferColorBufferGOOGLE returnUnmarshal");
    VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterBufferColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkRegisterBufferColorBufferGOOGLE");;
    return vkRegisterBufferColorBufferGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
void VkEncoder::vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    uint32_t imageInfoCount,
    uint32_t bufferInfoCount,
    uint32_t bufferViewCount,
    const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices,
    const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos,
    const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSizedGOOGLE encode");
    mImpl->log("start vkUpdateDescriptorSetWithTemplateSizedGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    uint32_t local_imageInfoCount;
    uint32_t local_bufferInfoCount;
    uint32_t local_bufferViewCount;
    uint32_t* local_pImageInfoEntryIndices;
    uint32_t* local_pBufferInfoEntryIndices;
    uint32_t* local_pBufferViewEntryIndices;
    VkDescriptorImageInfo* local_pImageInfos;
    VkDescriptorBufferInfo* local_pBufferInfos;
    VkBufferView* local_pBufferViews;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_imageInfoCount = imageInfoCount;
    local_bufferInfoCount = bufferInfoCount;
    local_bufferViewCount = bufferViewCount;
    local_pImageInfoEntryIndices = nullptr;
    if (pImageInfoEntryIndices)
    {
        local_pImageInfoEntryIndices = (uint32_t*)pool->dupArray(pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(const uint32_t));
    }
    local_pBufferInfoEntryIndices = nullptr;
    if (pBufferInfoEntryIndices)
    {
        local_pBufferInfoEntryIndices = (uint32_t*)pool->dupArray(pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(const uint32_t));
    }
    local_pBufferViewEntryIndices = nullptr;
    if (pBufferViewEntryIndices)
    {
        local_pBufferViewEntryIndices = (uint32_t*)pool->dupArray(pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(const uint32_t));
    }
    local_pImageInfos = nullptr;
    if (pImageInfos)
    {
        local_pImageInfos = (VkDescriptorImageInfo*)pool->alloc(((imageInfoCount)) * sizeof(const VkDescriptorImageInfo));
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            deepcopy_VkDescriptorImageInfo(pool, pImageInfos + i, (VkDescriptorImageInfo*)(local_pImageInfos + i));
        }
    }
    local_pBufferInfos = nullptr;
    if (pBufferInfos)
    {
        local_pBufferInfos = (VkDescriptorBufferInfo*)pool->alloc(((bufferInfoCount)) * sizeof(const VkDescriptorBufferInfo));
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            deepcopy_VkDescriptorBufferInfo(pool, pBufferInfos + i, (VkDescriptorBufferInfo*)(local_pBufferInfos + i));
        }
    }
    local_pBufferViews = nullptr;
    if (pBufferViews)
    {
        local_pBufferViews = (VkBufferView*)pool->dupArray(pBufferViews, ((bufferViewCount)) * sizeof(const VkBufferView));
    }
    if (local_pImageInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            transform_tohost_VkDescriptorImageInfo(mImpl->resources(), (VkDescriptorImageInfo*)(local_pImageInfos + i));
        }
    }
    if (local_pBufferInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            transform_tohost_VkDescriptorBufferInfo(mImpl->resources(), (VkDescriptorBufferInfo*)(local_pBufferInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1492;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1492, 1);
        countingStream->write((uint64_t*)&cgen_var_1492, 1 * 8);
        uint64_t cgen_var_1493;
        countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_1493, 1);
        countingStream->write((uint64_t*)&cgen_var_1493, 1 * 8);
        uint64_t cgen_var_1494;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1494, 1);
        countingStream->write((uint64_t*)&cgen_var_1494, 1 * 8);
        countingStream->write((uint32_t*)&local_imageInfoCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_bufferInfoCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_bufferViewCount, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_1495 = (uint64_t)(uintptr_t)local_pImageInfoEntryIndices;
        countingStream->putBe64(cgen_var_1495);
        if (local_pImageInfoEntryIndices)
        {
            countingStream->write((uint32_t*)local_pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1496 = (uint64_t)(uintptr_t)local_pBufferInfoEntryIndices;
        countingStream->putBe64(cgen_var_1496);
        if (local_pBufferInfoEntryIndices)
        {
            countingStream->write((uint32_t*)local_pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1497 = (uint64_t)(uintptr_t)local_pBufferViewEntryIndices;
        countingStream->putBe64(cgen_var_1497);
        if (local_pBufferViewEntryIndices)
        {
            countingStream->write((uint32_t*)local_pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1498 = (uint64_t)(uintptr_t)local_pImageInfos;
        countingStream->putBe64(cgen_var_1498);
        if (local_pImageInfos)
        {
            for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
            {
                marshal_VkDescriptorImageInfo(countingStream, (VkDescriptorImageInfo*)(local_pImageInfos + i));
            }
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1499 = (uint64_t)(uintptr_t)local_pBufferInfos;
        countingStream->putBe64(cgen_var_1499);
        if (local_pBufferInfos)
        {
            for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
            {
                marshal_VkDescriptorBufferInfo(countingStream, (VkDescriptorBufferInfo*)(local_pBufferInfos + i));
            }
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1500 = (uint64_t)(uintptr_t)local_pBufferViews;
        countingStream->putBe64(cgen_var_1500);
        if (local_pBufferViews)
        {
            if (((bufferViewCount)))
            {
                uint64_t* cgen_var_1501;
                countingStream->alloc((void**)&cgen_var_1501, ((bufferViewCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkBufferView_u64(local_pBufferViews, cgen_var_1501, ((bufferViewCount)));
                countingStream->write((uint64_t*)cgen_var_1501, ((bufferViewCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplateSizedGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSetWithTemplateSizedGOOGLE = OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE;
    stream->write(&opcode_vkUpdateDescriptorSetWithTemplateSizedGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSetWithTemplateSizedGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1502;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1502, 1);
    stream->write((uint64_t*)&cgen_var_1502, 1 * 8);
    uint64_t cgen_var_1503;
    stream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_1503, 1);
    stream->write((uint64_t*)&cgen_var_1503, 1 * 8);
    uint64_t cgen_var_1504;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1504, 1);
    stream->write((uint64_t*)&cgen_var_1504, 1 * 8);
    stream->write((uint32_t*)&local_imageInfoCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_bufferInfoCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_bufferViewCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1505 = (uint64_t)(uintptr_t)local_pImageInfoEntryIndices;
    stream->putBe64(cgen_var_1505);
    if (local_pImageInfoEntryIndices)
    {
        stream->write((uint32_t*)local_pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1506 = (uint64_t)(uintptr_t)local_pBufferInfoEntryIndices;
    stream->putBe64(cgen_var_1506);
    if (local_pBufferInfoEntryIndices)
    {
        stream->write((uint32_t*)local_pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1507 = (uint64_t)(uintptr_t)local_pBufferViewEntryIndices;
    stream->putBe64(cgen_var_1507);
    if (local_pBufferViewEntryIndices)
    {
        stream->write((uint32_t*)local_pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1508 = (uint64_t)(uintptr_t)local_pImageInfos;
    stream->putBe64(cgen_var_1508);
    if (local_pImageInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            marshal_VkDescriptorImageInfo(stream, (VkDescriptorImageInfo*)(local_pImageInfos + i));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1509 = (uint64_t)(uintptr_t)local_pBufferInfos;
    stream->putBe64(cgen_var_1509);
    if (local_pBufferInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            marshal_VkDescriptorBufferInfo(stream, (VkDescriptorBufferInfo*)(local_pBufferInfos + i));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1510 = (uint64_t)(uintptr_t)local_pBufferViews;
    stream->putBe64(cgen_var_1510);
    if (local_pBufferViews)
    {
        if (((bufferViewCount)))
        {
            uint64_t* cgen_var_1511;
            stream->alloc((void**)&cgen_var_1511, ((bufferViewCount)) * 8);
            stream->handleMapping()->mapHandles_VkBufferView_u64(local_pBufferViews, cgen_var_1511, ((bufferViewCount)));
            stream->write((uint64_t*)cgen_var_1511, ((bufferViewCount)) * 8);
        }
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSizedGOOGLE readParams");
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSizedGOOGLE returnUnmarshal");
    mImpl->log("finish vkUpdateDescriptorSetWithTemplateSizedGOOGLE");;
}

#endif
#ifdef VK_GOOGLE_async_command_buffers
void VkEncoder::vkBeginCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkBeginCommandBufferAsyncGOOGLE encode");
    mImpl->log("start vkBeginCommandBufferAsyncGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferBeginInfo* local_pBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pBeginInfo = nullptr;
    if (pBeginInfo)
    {
        local_pBeginInfo = (VkCommandBufferBeginInfo*)pool->alloc(sizeof(const VkCommandBufferBeginInfo));
        deepcopy_VkCommandBufferBeginInfo(pool, pBeginInfo, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    if (local_pBeginInfo)
    {
        transform_tohost_VkCommandBufferBeginInfo(mImpl->resources(), (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1512;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1512, 1);
        countingStream->write((uint64_t*)&cgen_var_1512, 1 * 8);
        marshal_VkCommandBufferBeginInfo(countingStream, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    uint32_t packetSize_vkBeginCommandBufferAsyncGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBeginCommandBufferAsyncGOOGLE = OP_vkBeginCommandBufferAsyncGOOGLE;
    stream->write(&opcode_vkBeginCommandBufferAsyncGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkBeginCommandBufferAsyncGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1513;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1513, 1);
    stream->write((uint64_t*)&cgen_var_1513, 1 * 8);
    marshal_VkCommandBufferBeginInfo(stream, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    AEMU_SCOPED_TRACE("vkBeginCommandBufferAsyncGOOGLE readParams");
    AEMU_SCOPED_TRACE("vkBeginCommandBufferAsyncGOOGLE returnUnmarshal");
    mImpl->log("finish vkBeginCommandBufferAsyncGOOGLE");;
}

void VkEncoder::vkEndCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkEndCommandBufferAsyncGOOGLE encode");
    mImpl->log("start vkEndCommandBufferAsyncGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1514;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1514, 1);
        countingStream->write((uint64_t*)&cgen_var_1514, 1 * 8);
    }
    uint32_t packetSize_vkEndCommandBufferAsyncGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEndCommandBufferAsyncGOOGLE = OP_vkEndCommandBufferAsyncGOOGLE;
    stream->write(&opcode_vkEndCommandBufferAsyncGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkEndCommandBufferAsyncGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1515;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1515, 1);
    stream->write((uint64_t*)&cgen_var_1515, 1 * 8);
    AEMU_SCOPED_TRACE("vkEndCommandBufferAsyncGOOGLE readParams");
    AEMU_SCOPED_TRACE("vkEndCommandBufferAsyncGOOGLE returnUnmarshal");
    mImpl->log("finish vkEndCommandBufferAsyncGOOGLE");;
}

void VkEncoder::vkResetCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkResetCommandBufferAsyncGOOGLE encode");
    mImpl->log("start vkResetCommandBufferAsyncGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferResetFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_1516;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1516, 1);
        countingStream->write((uint64_t*)&cgen_var_1516, 1 * 8);
        countingStream->write((VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    }
    uint32_t packetSize_vkResetCommandBufferAsyncGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetCommandBufferAsyncGOOGLE = OP_vkResetCommandBufferAsyncGOOGLE;
    stream->write(&opcode_vkResetCommandBufferAsyncGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkResetCommandBufferAsyncGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1517;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1517, 1);
    stream->write((uint64_t*)&cgen_var_1517, 1 * 8);
    stream->write((VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    AEMU_SCOPED_TRACE("vkResetCommandBufferAsyncGOOGLE readParams");
    AEMU_SCOPED_TRACE("vkResetCommandBufferAsyncGOOGLE returnUnmarshal");
    mImpl->log("finish vkResetCommandBufferAsyncGOOGLE");;
}

void VkEncoder::vkCommandBufferHostSyncGOOGLE(
    VkCommandBuffer commandBuffer,
    uint32_t needHostSync,
    uint32_t sequenceNumber)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCommandBufferHostSyncGOOGLE encode");
    mImpl->log("start vkCommandBufferHostSyncGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_needHostSync;
    uint32_t local_sequenceNumber;
    local_commandBuffer = commandBuffer;
    local_needHostSync = needHostSync;
    local_sequenceNumber = sequenceNumber;
    countingStream->rewind();
    {
        uint64_t cgen_var_1518;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1518, 1);
        countingStream->write((uint64_t*)&cgen_var_1518, 1 * 8);
        countingStream->write((uint32_t*)&local_needHostSync, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_sequenceNumber, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCommandBufferHostSyncGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCommandBufferHostSyncGOOGLE = OP_vkCommandBufferHostSyncGOOGLE;
    stream->write(&opcode_vkCommandBufferHostSyncGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkCommandBufferHostSyncGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1519;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1519, 1);
    stream->write((uint64_t*)&cgen_var_1519, 1 * 8);
    stream->write((uint32_t*)&local_needHostSync, sizeof(uint32_t));
    stream->write((uint32_t*)&local_sequenceNumber, sizeof(uint32_t));
    AEMU_SCOPED_TRACE("vkCommandBufferHostSyncGOOGLE readParams");
    AEMU_SCOPED_TRACE("vkCommandBufferHostSyncGOOGLE returnUnmarshal");
    mImpl->log("finish vkCommandBufferHostSyncGOOGLE");;
}

#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
VkResult VkEncoder::vkCreateImageWithRequirementsGOOGLE(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage,
    VkMemoryRequirements* pMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateImageWithRequirementsGOOGLE encode");
    mImpl->log("start vkCreateImageWithRequirementsGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageCreateInfo*)pool->alloc(sizeof(const VkImageCreateInfo));
        deepcopy_VkImageCreateInfo(pool, pCreateInfo, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    mImpl->resources()->unwrap_VkNativeBufferANDROID(pCreateInfo, local_pCreateInfo);
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageCreateInfo(mImpl->resources(), (VkImageCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1520;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1520, 1);
        countingStream->write((uint64_t*)&cgen_var_1520, 1 * 8);
        marshal_VkImageCreateInfo(countingStream, (VkImageCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1521 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1521);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1522;
        countingStream->handleMapping()->mapHandles_VkImage_u64(pImage, &cgen_var_1522, 1);
        countingStream->write((uint64_t*)&cgen_var_1522, 8);
        marshal_VkMemoryRequirements(countingStream, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkCreateImageWithRequirementsGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateImageWithRequirementsGOOGLE = OP_vkCreateImageWithRequirementsGOOGLE;
    stream->write(&opcode_vkCreateImageWithRequirementsGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateImageWithRequirementsGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1523;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1523, 1);
    stream->write((uint64_t*)&cgen_var_1523, 1 * 8);
    marshal_VkImageCreateInfo(stream, (VkImageCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1524 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1524);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1525;
    stream->handleMapping()->mapHandles_VkImage_u64(pImage, &cgen_var_1525, 1);
    stream->write((uint64_t*)&cgen_var_1525, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    marshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    AEMU_SCOPED_TRACE("vkCreateImageWithRequirementsGOOGLE readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1526;
    stream->read((uint64_t*)&cgen_var_1526, 8);
    stream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_1526, (VkImage*)pImage, 1);
    stream->unsetHandleMapping();
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(mImpl->resources(), (VkMemoryRequirements*)(pMemoryRequirements));
    }
    AEMU_SCOPED_TRACE("vkCreateImageWithRequirementsGOOGLE returnUnmarshal");
    VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImageWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateImageWithRequirementsGOOGLE");;
    return vkCreateImageWithRequirementsGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkCreateBufferWithRequirementsGOOGLE(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkCreateBufferWithRequirementsGOOGLE encode");
    mImpl->log("start vkCreateBufferWithRequirementsGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferCreateInfo*)pool->alloc(sizeof(const VkBufferCreateInfo));
        deepcopy_VkBufferCreateInfo(pool, pCreateInfo, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferCreateInfo(mImpl->resources(), (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1527;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1527, 1);
        countingStream->write((uint64_t*)&cgen_var_1527, 1 * 8);
        marshal_VkBufferCreateInfo(countingStream, (VkBufferCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1528 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1528);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1529;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(pBuffer, &cgen_var_1529, 1);
        countingStream->write((uint64_t*)&cgen_var_1529, 8);
        marshal_VkMemoryRequirements(countingStream, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkCreateBufferWithRequirementsGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateBufferWithRequirementsGOOGLE = OP_vkCreateBufferWithRequirementsGOOGLE;
    stream->write(&opcode_vkCreateBufferWithRequirementsGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateBufferWithRequirementsGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1530;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1530, 1);
    stream->write((uint64_t*)&cgen_var_1530, 1 * 8);
    marshal_VkBufferCreateInfo(stream, (VkBufferCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1531 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1531);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1532;
    stream->handleMapping()->mapHandles_VkBuffer_u64(pBuffer, &cgen_var_1532, 1);
    stream->write((uint64_t*)&cgen_var_1532, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    marshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    AEMU_SCOPED_TRACE("vkCreateBufferWithRequirementsGOOGLE readParams");
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1533;
    stream->read((uint64_t*)&cgen_var_1533, 8);
    stream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_1533, (VkBuffer*)pBuffer, 1);
    stream->unsetHandleMapping();
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(mImpl->resources(), (VkMemoryRequirements*)(pMemoryRequirements));
    }
    AEMU_SCOPED_TRACE("vkCreateBufferWithRequirementsGOOGLE returnUnmarshal");
    VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBufferWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkCreateBufferWithRequirementsGOOGLE");;
    return vkCreateBufferWithRequirementsGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_address_space_info
VkResult VkEncoder::vkGetMemoryHostAddressInfoGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress,
    uint64_t* pSize,
    uint64_t* pHostmemId)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkGetMemoryHostAddressInfoGOOGLE encode");
    mImpl->log("start vkGetMemoryHostAddressInfoGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    mImpl->resources()->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_1534;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1534, 1);
        countingStream->write((uint64_t*)&cgen_var_1534, 1 * 8);
        uint64_t cgen_var_1535;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1535, 1);
        countingStream->write((uint64_t*)&cgen_var_1535, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1536 = (uint64_t)(uintptr_t)pAddress;
        countingStream->putBe64(cgen_var_1536);
        if (pAddress)
        {
            countingStream->write((uint64_t*)pAddress, sizeof(uint64_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1537 = (uint64_t)(uintptr_t)pSize;
        countingStream->putBe64(cgen_var_1537);
        if (pSize)
        {
            countingStream->write((uint64_t*)pSize, sizeof(uint64_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1538 = (uint64_t)(uintptr_t)pHostmemId;
        countingStream->putBe64(cgen_var_1538);
        if (pHostmemId)
        {
            countingStream->write((uint64_t*)pHostmemId, sizeof(uint64_t));
        }
    }
    uint32_t packetSize_vkGetMemoryHostAddressInfoGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryHostAddressInfoGOOGLE = OP_vkGetMemoryHostAddressInfoGOOGLE;
    stream->write(&opcode_vkGetMemoryHostAddressInfoGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryHostAddressInfoGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1539;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1539, 1);
    stream->write((uint64_t*)&cgen_var_1539, 1 * 8);
    uint64_t cgen_var_1540;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1540, 1);
    stream->write((uint64_t*)&cgen_var_1540, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1541 = (uint64_t)(uintptr_t)pAddress;
    stream->putBe64(cgen_var_1541);
    if (pAddress)
    {
        stream->write((uint64_t*)pAddress, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1542 = (uint64_t)(uintptr_t)pSize;
    stream->putBe64(cgen_var_1542);
    if (pSize)
    {
        stream->write((uint64_t*)pSize, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1543 = (uint64_t)(uintptr_t)pHostmemId;
    stream->putBe64(cgen_var_1543);
    if (pHostmemId)
    {
        stream->write((uint64_t*)pHostmemId, sizeof(uint64_t));
    }
    AEMU_SCOPED_TRACE("vkGetMemoryHostAddressInfoGOOGLE readParams");
    // WARNING PTR CHECK
    uint64_t* check_pAddress;
    check_pAddress = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pAddress)
    {
        if (!(check_pAddress))
        {
            fprintf(stderr, "fatal: pAddress inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pAddress, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t* check_pSize;
    check_pSize = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pSize)
    {
        if (!(check_pSize))
        {
            fprintf(stderr, "fatal: pSize inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pSize, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t* check_pHostmemId;
    check_pHostmemId = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pHostmemId)
    {
        if (!(check_pHostmemId))
        {
            fprintf(stderr, "fatal: pHostmemId inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pHostmemId, sizeof(uint64_t));
    }
    AEMU_SCOPED_TRACE("vkGetMemoryHostAddressInfoGOOGLE returnUnmarshal");
    VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->log("finish vkGetMemoryHostAddressInfoGOOGLE");;
    return vkGetMemoryHostAddressInfoGOOGLE_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_free_memory_sync
VkResult VkEncoder::vkFreeMemorySyncGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    AutoLock encoderLock(mImpl->lock);
    AEMU_SCOPED_TRACE("vkFreeMemorySyncGOOGLE encode");
    mImpl->log("start vkFreeMemorySyncGOOGLE");
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_memory = memory;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    mImpl->resources()->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_1547;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1547, 1);
        countingStream->write((uint64_t*)&cgen_var_1547, 1 * 8);
        uint64_t cgen_var_1548;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1548, 1);
        countingStream->write((uint64_t*)&cgen_var_1548, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1549 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1549);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkFreeMemorySyncGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeMemorySyncGOOGLE = OP_vkFreeMemorySyncGOOGLE;
    stream->write(&opcode_vkFreeMemorySyncGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeMemorySyncGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1550;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1550, 1);
    stream->write((uint64_t*)&cgen_var_1550, 1 * 8);
    uint64_t cgen_var_1551;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1551, 1);
    stream->write((uint64_t*)&cgen_var_1551, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1552 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1552);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    AEMU_SCOPED_TRACE("vkFreeMemorySyncGOOGLE readParams");
    AEMU_SCOPED_TRACE("vkFreeMemorySyncGOOGLE returnUnmarshal");
    VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkFreeMemorySyncGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    resources->destroyMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)&memory);
    mImpl->log("finish vkFreeMemorySyncGOOGLE");;
    return vkFreeMemorySyncGOOGLE_VkResult_return;
}

#endif

} // namespace goldfish_vk
