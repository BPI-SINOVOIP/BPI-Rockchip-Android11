/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* A list of commands useable in documentation comments                       *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

namespace {
const CommandInfo Commands[] = {
  { "a", "", 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "abstract", "", 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "addtogroup", "", 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "anchor", "", 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "arg", "", 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "attention", "", 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "author", "", 6, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "authors", "", 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "b", "", 8, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "brief", "", 9, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "bug", "", 10, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "c", "", 11, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "callback", "", 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "category", "", 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "class", "", 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "classdesign", "", 15, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "coclass", "", 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "code", "endcode", 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endcode", "", 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "const", "", 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "constant", "", 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "copyright", "", 21, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "date", "", 22, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "def", "", 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "defgroup", "", 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "dependency", "", 25, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "deprecated", "", 26, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "details", "", 27, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "discussion", "", 28, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "dot", "enddot", 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "enddot", "", 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "e", "", 31, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "em", "", 32, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "enum", "", 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "exception", "", 34, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "f{", "f}", 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "f}", "", 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "f[", "f]", 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "f]", "", 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "f$", "f$", 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "fn", "", 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "function", "", 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "functiongroup", "", 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "headerfile", "", 43, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "helper", "", 44, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "helperclass", "", 45, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "helps", "", 46, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "htmlonly", "endhtmlonly", 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endhtmlonly", "", 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "ingroup", "", 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "instancesize", "", 50, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "interface", "", 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "invariant", "", 52, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "latexonly", "endlatexonly", 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endlatexonly", "", 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "li", "", 55, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "link", "/link", 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "/link", "", 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "mainpage", "", 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "manonly", "endmanonly", 59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endmanonly", "", 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "method", "", 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "methodgroup", "", 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "msc", "endmsc", 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endmsc", "", 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "name", "", 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "namespace", "", 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "note", "", 67, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "overload", "", 68, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "ownership", "", 69, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "p", "", 70, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "par", "", 71, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "paragraph", "", 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "param", "", 73, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "performance", "", 74, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "post", "", 75, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "pre", "", 76, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "property", "", 77, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "protocol", "", 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "ref", "", 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "related", "", 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "relatedalso", "", 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "relates", "", 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "relatesalso", "", 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "remark", "", 84, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "remarks", "", 85, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "result", "", 86, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "return", "", 87, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "returns", "", 88, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "retval", "", 89, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "rtfonly", "endrtfonly", 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endrtfonly", "", 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "sa", "", 92, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "section", "", 93, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "security", "", 94, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "see", "", 95, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "seealso", "", 96, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "short", "", 97, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "since", "", 98, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "struct", "", 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "subpage", "", 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "subsection", "", 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "subsubsection", "", 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "superclass", "", 103, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "template", "", 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "templatefield", "", 105, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "textblock", "/textblock", 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "/textblock", "", 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "throw", "", 108, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "throws", "", 109, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "todo", "", 110, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "tparam", "", 111, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "typedef", "", 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "union", "", 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "var", "", 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "verbatim", "endverbatim", 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endverbatim", "", 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "version", "", 117, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "warning", "", 118, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "weakgroup", "", 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "xmlonly", "endxmlonly", 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endxmlonly", "", 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }
};
} // unnamed namespace

const CommandInfo *CommandTraits::getBuiltinCommandInfo(
                                         StringRef Name) {
  switch (Name.size()) {
  default: break;
  case 1:	 // 5 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      return &Commands[0];	 // "a"
    case 'b':	 // 1 string to match.
      return &Commands[8];	 // "b"
    case 'c':	 // 1 string to match.
      return &Commands[11];	 // "c"
    case 'e':	 // 1 string to match.
      return &Commands[31];	 // "e"
    case 'p':	 // 1 string to match.
      return &Commands[70];	 // "p"
    }
    break;
  case 2:	 // 9 strings to match.
    switch (Name[0]) {
    default: break;
    case 'e':	 // 1 string to match.
      if (Name[1] != 'm')
        break;
      return &Commands[32];	 // "em"
    case 'f':	 // 6 strings to match.
      switch (Name[1]) {
      default: break;
      case '$':	 // 1 string to match.
        return &Commands[39];	 // "f$"
      case '[':	 // 1 string to match.
        return &Commands[37];	 // "f["
      case ']':	 // 1 string to match.
        return &Commands[38];	 // "f]"
      case 'n':	 // 1 string to match.
        return &Commands[40];	 // "fn"
      case '{':	 // 1 string to match.
        return &Commands[35];	 // "f{"
      case '}':	 // 1 string to match.
        return &Commands[36];	 // "f}"
      }
      break;
    case 'l':	 // 1 string to match.
      if (Name[1] != 'i')
        break;
      return &Commands[55];	 // "li"
    case 's':	 // 1 string to match.
      if (Name[1] != 'a')
        break;
      return &Commands[92];	 // "sa"
    }
    break;
  case 3:	 // 10 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "rg", 2) != 0)
        break;
      return &Commands[4];	 // "arg"
    case 'b':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ug", 2) != 0)
        break;
      return &Commands[10];	 // "bug"
    case 'd':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 1 string to match.
        if (Name[2] != 'f')
          break;
        return &Commands[23];	 // "def"
      case 'o':	 // 1 string to match.
        if (Name[2] != 't')
          break;
        return &Commands[29];	 // "dot"
      }
      break;
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "sc", 2) != 0)
        break;
      return &Commands[63];	 // "msc"
    case 'p':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (Name[2] != 'r')
          break;
        return &Commands[71];	 // "par"
      case 'r':	 // 1 string to match.
        if (Name[2] != 'e')
          break;
        return &Commands[76];	 // "pre"
      }
      break;
    case 'r':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ef", 2) != 0)
        break;
      return &Commands[79];	 // "ref"
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ee", 2) != 0)
        break;
      return &Commands[95];	 // "see"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ar", 2) != 0)
        break;
      return &Commands[114];	 // "var"
    }
    break;
  case 4:	 // 8 strings to match.
    switch (Name[0]) {
    default: break;
    case 'c':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ode", 3) != 0)
        break;
      return &Commands[17];	 // "code"
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ate", 3) != 0)
        break;
      return &Commands[22];	 // "date"
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "num", 3) != 0)
        break;
      return &Commands[33];	 // "enum"
    case 'l':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ink", 3) != 0)
        break;
      return &Commands[56];	 // "link"
    case 'n':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "me", 2) != 0)
          break;
        return &Commands[65];	 // "name"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "te", 2) != 0)
          break;
        return &Commands[67];	 // "note"
      }
      break;
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ost", 3) != 0)
        break;
      return &Commands[75];	 // "post"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "odo", 3) != 0)
        break;
      return &Commands[110];	 // "todo"
    }
    break;
  case 5:	 // 10 strings to match.
    switch (Name[0]) {
    default: break;
    case '/':	 // 1 string to match.
      if (memcmp(Name.data()+1, "link", 4) != 0)
        break;
      return &Commands[57];	 // "/link"
    case 'b':	 // 1 string to match.
      if (memcmp(Name.data()+1, "rief", 4) != 0)
        break;
      return &Commands[9];	 // "brief"
    case 'c':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'l':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ass", 3) != 0)
          break;
        return &Commands[14];	 // "class"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nst", 3) != 0)
          break;
        return &Commands[19];	 // "const"
      }
      break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "elps", 4) != 0)
        break;
      return &Commands[46];	 // "helps"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "aram", 4) != 0)
        break;
      return &Commands[73];	 // "param"
    case 's':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'h':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ort", 3) != 0)
          break;
        return &Commands[97];	 // "short"
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nce", 3) != 0)
          break;
        return &Commands[98];	 // "since"
      }
      break;
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "hrow", 4) != 0)
        break;
      return &Commands[108];	 // "throw"
    case 'u':	 // 1 string to match.
      if (memcmp(Name.data()+1, "nion", 4) != 0)
        break;
      return &Commands[113];	 // "union"
    }
    break;
  case 6:	 // 13 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'n':	 // 1 string to match.
        if (memcmp(Name.data()+2, "chor", 4) != 0)
          break;
        return &Commands[3];	 // "anchor"
      case 'u':	 // 1 string to match.
        if (memcmp(Name.data()+2, "thor", 4) != 0)
          break;
        return &Commands[6];	 // "author"
      }
      break;
    case 'e':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "nd", 2) != 0)
        break;
      switch (Name[3]) {
      default: break;
      case 'd':	 // 1 string to match.
        if (memcmp(Name.data()+4, "ot", 2) != 0)
          break;
        return &Commands[30];	 // "enddot"
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+4, "sc", 2) != 0)
          break;
        return &Commands[64];	 // "endmsc"
      }
      break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "elper", 5) != 0)
        break;
      return &Commands[44];	 // "helper"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ethod", 5) != 0)
        break;
      return &Commands[61];	 // "method"
    case 'r':	 // 4 strings to match.
      if (Name[1] != 'e')
        break;
      switch (Name[2]) {
      default: break;
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ark", 3) != 0)
          break;
        return &Commands[84];	 // "remark"
      case 's':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ult", 3) != 0)
          break;
        return &Commands[86];	 // "result"
      case 't':	 // 2 strings to match.
        switch (Name[3]) {
        default: break;
        case 'u':	 // 1 string to match.
          if (memcmp(Name.data()+4, "rn", 2) != 0)
            break;
          return &Commands[87];	 // "return"
        case 'v':	 // 1 string to match.
          if (memcmp(Name.data()+4, "al", 2) != 0)
            break;
          return &Commands[89];	 // "retval"
        }
        break;
      }
      break;
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "truct", 5) != 0)
        break;
      return &Commands[99];	 // "struct"
    case 't':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'h':	 // 1 string to match.
        if (memcmp(Name.data()+2, "rows", 4) != 0)
          break;
        return &Commands[109];	 // "throws"
      case 'p':	 // 1 string to match.
        if (memcmp(Name.data()+2, "aram", 4) != 0)
          break;
        return &Commands[111];	 // "tparam"
      }
      break;
    }
    break;
  case 7:	 // 18 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "uthors", 6) != 0)
        break;
      return &Commands[7];	 // "authors"
    case 'c':	 // 1 string to match.
      if (memcmp(Name.data()+1, "oclass", 6) != 0)
        break;
      return &Commands[16];	 // "coclass"
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "etails", 6) != 0)
        break;
      return &Commands[27];	 // "details"
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ndcode", 6) != 0)
        break;
      return &Commands[18];	 // "endcode"
    case 'i':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ngroup", 6) != 0)
        break;
      return &Commands[49];	 // "ingroup"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "anonly", 6) != 0)
        break;
      return &Commands[59];	 // "manonly"
    case 'r':	 // 5 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 4 strings to match.
        switch (Name[2]) {
        default: break;
        case 'l':	 // 2 strings to match.
          if (memcmp(Name.data()+3, "ate", 3) != 0)
            break;
          switch (Name[6]) {
          default: break;
          case 'd':	 // 1 string to match.
            return &Commands[80];	 // "related"
          case 's':	 // 1 string to match.
            return &Commands[82];	 // "relates"
          }
          break;
        case 'm':	 // 1 string to match.
          if (memcmp(Name.data()+3, "arks", 4) != 0)
            break;
          return &Commands[85];	 // "remarks"
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+3, "urns", 4) != 0)
            break;
          return &Commands[88];	 // "returns"
        }
        break;
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+2, "fonly", 5) != 0)
          break;
        return &Commands[90];	 // "rtfonly"
      }
      break;
    case 's':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'c':	 // 1 string to match.
          if (memcmp(Name.data()+3, "tion", 4) != 0)
            break;
          return &Commands[93];	 // "section"
        case 'e':	 // 1 string to match.
          if (memcmp(Name.data()+3, "also", 4) != 0)
            break;
          return &Commands[96];	 // "seealso"
        }
        break;
      case 'u':	 // 1 string to match.
        if (memcmp(Name.data()+2, "bpage", 5) != 0)
          break;
        return &Commands[100];	 // "subpage"
      }
      break;
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ypedef", 6) != 0)
        break;
      return &Commands[112];	 // "typedef"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ersion", 6) != 0)
        break;
      return &Commands[117];	 // "version"
    case 'w':	 // 1 string to match.
      if (memcmp(Name.data()+1, "arning", 6) != 0)
        break;
      return &Commands[118];	 // "warning"
    case 'x':	 // 1 string to match.
      if (memcmp(Name.data()+1, "mlonly", 6) != 0)
        break;
      return &Commands[120];	 // "xmlonly"
    }
    break;
  case 8:	 // 14 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "bstract", 7) != 0)
        break;
      return &Commands[1];	 // "abstract"
    case 'c':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'l':	 // 1 string to match.
          if (memcmp(Name.data()+3, "lback", 5) != 0)
            break;
          return &Commands[12];	 // "callback"
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+3, "egory", 5) != 0)
            break;
          return &Commands[13];	 // "category"
        }
        break;
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nstant", 6) != 0)
          break;
        return &Commands[20];	 // "constant"
      }
      break;
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "efgroup", 7) != 0)
        break;
      return &Commands[24];	 // "defgroup"
    case 'f':	 // 1 string to match.
      if (memcmp(Name.data()+1, "unction", 7) != 0)
        break;
      return &Commands[41];	 // "function"
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "tmlonly", 7) != 0)
        break;
      return &Commands[47];	 // "htmlonly"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ainpage", 7) != 0)
        break;
      return &Commands[58];	 // "mainpage"
    case 'o':	 // 1 string to match.
      if (memcmp(Name.data()+1, "verload", 7) != 0)
        break;
      return &Commands[68];	 // "overload"
    case 'p':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "ro", 2) != 0)
        break;
      switch (Name[3]) {
      default: break;
      case 'p':	 // 1 string to match.
        if (memcmp(Name.data()+4, "erty", 4) != 0)
          break;
        return &Commands[77];	 // "property"
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+4, "ocol", 4) != 0)
          break;
        return &Commands[78];	 // "protocol"
      }
      break;
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ecurity", 7) != 0)
        break;
      return &Commands[94];	 // "security"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "emplate", 7) != 0)
        break;
      return &Commands[104];	 // "template"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "erbatim", 7) != 0)
        break;
      return &Commands[115];	 // "verbatim"
    }
    break;
  case 9:	 // 11 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ttention", 8) != 0)
        break;
      return &Commands[5];	 // "attention"
    case 'c':	 // 1 string to match.
      if (memcmp(Name.data()+1, "opyright", 8) != 0)
        break;
      return &Commands[21];	 // "copyright"
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "xception", 8) != 0)
        break;
      return &Commands[34];	 // "exception"
    case 'i':	 // 2 strings to match.
      if (Name[1] != 'n')
        break;
      switch (Name[2]) {
      default: break;
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+3, "erface", 6) != 0)
          break;
        return &Commands[51];	 // "interface"
      case 'v':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ariant", 6) != 0)
          break;
        return &Commands[52];	 // "invariant"
      }
      break;
    case 'l':	 // 1 string to match.
      if (memcmp(Name.data()+1, "atexonly", 8) != 0)
        break;
      return &Commands[53];	 // "latexonly"
    case 'n':	 // 1 string to match.
      if (memcmp(Name.data()+1, "amespace", 8) != 0)
        break;
      return &Commands[66];	 // "namespace"
    case 'o':	 // 1 string to match.
      if (memcmp(Name.data()+1, "wnership", 8) != 0)
        break;
      return &Commands[69];	 // "ownership"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "aragraph", 8) != 0)
        break;
      return &Commands[72];	 // "paragraph"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "extblock", 8) != 0)
        break;
      return &Commands[106];	 // "textblock"
    case 'w':	 // 1 string to match.
      if (memcmp(Name.data()+1, "eakgroup", 8) != 0)
        break;
      return &Commands[119];	 // "weakgroup"
    }
    break;
  case 10:	 // 11 strings to match.
    switch (Name[0]) {
    default: break;
    case '/':	 // 1 string to match.
      if (memcmp(Name.data()+1, "textblock", 9) != 0)
        break;
      return &Commands[107];	 // "/textblock"
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ddtogroup", 9) != 0)
        break;
      return &Commands[2];	 // "addtogroup"
    case 'd':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 2 strings to match.
        if (Name[2] != 'p')
          break;
        switch (Name[3]) {
        default: break;
        case 'e':	 // 1 string to match.
          if (memcmp(Name.data()+4, "ndency", 6) != 0)
            break;
          return &Commands[25];	 // "dependency"
        case 'r':	 // 1 string to match.
          if (memcmp(Name.data()+4, "ecated", 6) != 0)
            break;
          return &Commands[26];	 // "deprecated"
        }
        break;
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+2, "scussion", 8) != 0)
          break;
        return &Commands[28];	 // "discussion"
      }
      break;
    case 'e':	 // 3 strings to match.
      if (memcmp(Name.data()+1, "nd", 2) != 0)
        break;
      switch (Name[3]) {
      default: break;
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+4, "anonly", 6) != 0)
          break;
        return &Commands[60];	 // "endmanonly"
      case 'r':	 // 1 string to match.
        if (memcmp(Name.data()+4, "tfonly", 6) != 0)
          break;
        return &Commands[91];	 // "endrtfonly"
      case 'x':	 // 1 string to match.
        if (memcmp(Name.data()+4, "mlonly", 6) != 0)
          break;
        return &Commands[121];	 // "endxmlonly"
      }
      break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "eaderfile", 9) != 0)
        break;
      return &Commands[43];	 // "headerfile"
    case 's':	 // 2 strings to match.
      if (Name[1] != 'u')
        break;
      switch (Name[2]) {
      default: break;
      case 'b':	 // 1 string to match.
        if (memcmp(Name.data()+3, "section", 7) != 0)
          break;
        return &Commands[101];	 // "subsection"
      case 'p':	 // 1 string to match.
        if (memcmp(Name.data()+3, "erclass", 7) != 0)
          break;
        return &Commands[103];	 // "superclass"
      }
      break;
    }
    break;
  case 11:	 // 8 strings to match.
    switch (Name[0]) {
    default: break;
    case 'c':	 // 1 string to match.
      if (memcmp(Name.data()+1, "lassdesign", 10) != 0)
        break;
      return &Commands[15];	 // "classdesign"
    case 'e':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "nd", 2) != 0)
        break;
      switch (Name[3]) {
      default: break;
      case 'h':	 // 1 string to match.
        if (memcmp(Name.data()+4, "tmlonly", 7) != 0)
          break;
        return &Commands[48];	 // "endhtmlonly"
      case 'v':	 // 1 string to match.
        if (memcmp(Name.data()+4, "erbatim", 7) != 0)
          break;
        return &Commands[116];	 // "endverbatim"
      }
      break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "elperclass", 10) != 0)
        break;
      return &Commands[45];	 // "helperclass"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ethodgroup", 10) != 0)
        break;
      return &Commands[62];	 // "methodgroup"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "erformance", 10) != 0)
        break;
      return &Commands[74];	 // "performance"
    case 'r':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "elate", 5) != 0)
        break;
      switch (Name[6]) {
      default: break;
      case 'd':	 // 1 string to match.
        if (memcmp(Name.data()+7, "also", 4) != 0)
          break;
        return &Commands[81];	 // "relatedalso"
      case 's':	 // 1 string to match.
        if (memcmp(Name.data()+7, "also", 4) != 0)
          break;
        return &Commands[83];	 // "relatesalso"
      }
      break;
    }
    break;
  case 12:	 // 2 strings to match.
    switch (Name[0]) {
    default: break;
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ndlatexonly", 11) != 0)
        break;
      return &Commands[54];	 // "endlatexonly"
    case 'i':	 // 1 string to match.
      if (memcmp(Name.data()+1, "nstancesize", 11) != 0)
        break;
      return &Commands[50];	 // "instancesize"
    }
    break;
  case 13:	 // 3 strings to match.
    switch (Name[0]) {
    default: break;
    case 'f':	 // 1 string to match.
      if (memcmp(Name.data()+1, "unctiongroup", 12) != 0)
        break;
      return &Commands[42];	 // "functiongroup"
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ubsubsection", 12) != 0)
        break;
      return &Commands[102];	 // "subsubsection"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "emplatefield", 12) != 0)
        break;
      return &Commands[105];	 // "templatefield"
    }
    break;
  }
  return nullptr;
}

